<rss version="2.0">
<script/>
<channel>
<title>estar987</title>
<link>https://estar987.com/</link>
<description/>
<language>ko</language>
<pubDate>Thu, 14 Nov 2024 20:51:19 +0900</pubDate>
<generator>TISTORY</generator>
<ttl>100</ttl>
<managingEditor>Yoon_estar</managingEditor>
<image>
<title>estar987</title>
<url>https://tistory1.daumcdn.net/tistory/6753063/attach/50be86ffcacf4549897741618cc24143</url>
<link>https://estar987.com</link>
</image>
<item>
<title>Putty 글씨 설정</title>
<link>https://estar987.com/entry/Putty-%EA%B8%80%EC%94%A8-%EC%84%A4%EC%A0%95</link>
<description><p data-ke-size="size16">Putty를 사용하다보면 기본으로 터미널을 열면 글씨가 너무 작고 잘 안보이는 경우가 많다. 그래서 내가 주로 사용하는 환경을 추천하려고 한다.</p> <p data-ke-size="size16">&nbsp;</p> <!-- 반응형 --> <p data-ke-size="size16">&nbsp;</p> <script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8813779215678829"></script> <!-- 반응형 --> <p><ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-8813779215678829" data-ad-slot="1064332557" data-ad-format="auto" data-full-width-responsive="true"></ins></p> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="451" data-origin-height="437"><span data-url="https://blog.kakaocdn.net/dn/cVFrrw/btsKzI2uqxR/qcRZ76fsHEqDiatlfC2LwK/img.png" data-phocus="https://blog.kakaocdn.net/dn/cVFrrw/btsKzI2uqxR/qcRZ76fsHEqDiatlfC2LwK/img.png"><img src="https://blog.kakaocdn.net/dn/cVFrrw/btsKzI2uqxR/qcRZ76fsHEqDiatlfC2LwK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcVFrrw%2FbtsKzI2uqxR%2FqcRZ76fsHEqDiatlfC2LwK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="451" data-origin-height="437"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="450" data-origin-height="439"><span data-url="https://blog.kakaocdn.net/dn/bBjm6X/btsKCgv3jsi/MdVvkipX9MDj8ztxxexubK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bBjm6X/btsKCgv3jsi/MdVvkipX9MDj8ztxxexubK/img.png"><img src="https://blog.kakaocdn.net/dn/bBjm6X/btsKCgv3jsi/MdVvkipX9MDj8ztxxexubK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbBjm6X%2FbtsKCgv3jsi%2FMdVvkipX9MDj8ztxxexubK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="450" data-origin-height="439"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="429" data-origin-height="464"><span data-url="https://blog.kakaocdn.net/dn/TFSci/btsKBk60YCA/p4aBOU4cqSPjljEvkuJyc0/img.png" data-phocus="https://blog.kakaocdn.net/dn/TFSci/btsKBk60YCA/p4aBOU4cqSPjljEvkuJyc0/img.png"><img src="https://blog.kakaocdn.net/dn/TFSci/btsKBk60YCA/p4aBOU4cqSPjljEvkuJyc0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTFSci%2FbtsKBk60YCA%2Fp4aBOU4cqSPjljEvkuJyc0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="429" data-origin-height="464"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="450" data-origin-height="436"><span data-url="https://blog.kakaocdn.net/dn/cqKLVe/btsKBfLpYcq/gNoVk2jmyLWNFwn39599iK/img.png" data-phocus="https://blog.kakaocdn.net/dn/cqKLVe/btsKBfLpYcq/gNoVk2jmyLWNFwn39599iK/img.png"><img src="https://blog.kakaocdn.net/dn/cqKLVe/btsKBfLpYcq/gNoVk2jmyLWNFwn39599iK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcqKLVe%2FbtsKBfLpYcq%2FgNoVk2jmyLWNFwn39599iK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="450" data-origin-height="436"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="450" data-origin-height="436"><span data-url="https://blog.kakaocdn.net/dn/SQPqr/btsKADlRE3R/vXPyh8pDkYoS9vPSKOvZMk/img.png" data-phocus="https://blog.kakaocdn.net/dn/SQPqr/btsKADlRE3R/vXPyh8pDkYoS9vPSKOvZMk/img.png"><img src="https://blog.kakaocdn.net/dn/SQPqr/btsKADlRE3R/vXPyh8pDkYoS9vPSKOvZMk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSQPqr%2FbtsKADlRE3R%2FvXPyh8pDkYoS9vPSKOvZMk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="450" data-origin-height="436"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="453" data-origin-height="436"><span data-url="https://blog.kakaocdn.net/dn/bUGrs6/btsKAGpd0XU/99B82Wkn7MV7M9QAZYPpF0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bUGrs6/btsKAGpd0XU/99B82Wkn7MV7M9QAZYPpF0/img.png" data-alt="UP을 클릭해 최 상단으로 올림"><img src="https://blog.kakaocdn.net/dn/bUGrs6/btsKAGpd0XU/99B82Wkn7MV7M9QAZYPpF0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUGrs6%2FbtsKAGpd0XU%2F99B82Wkn7MV7M9QAZYPpF0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="453" data-origin-height="436"/></span><figcaption>UP을 클릭해 최 상단으로 올림</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="450" data-origin-height="438"><span data-url="https://blog.kakaocdn.net/dn/FucPE/btsKAWZDFAS/IJ1i07AFFtnZy7hqEGpUhk/img.png" data-phocus="https://blog.kakaocdn.net/dn/FucPE/btsKAWZDFAS/IJ1i07AFFtnZy7hqEGpUhk/img.png" data-alt="지금 설정한 값을 저장하여 필요할 때마다 불러올 수 있음"><img src="https://blog.kakaocdn.net/dn/FucPE/btsKAWZDFAS/IJ1i07AFFtnZy7hqEGpUhk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFucPE%2FbtsKAWZDFAS%2FIJ1i07AFFtnZy7hqEGpUhk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="450" data-origin-height="438"/></span><figcaption>지금 설정한 값을 저장하여 필요할 때마다 불러올 수 있음</figcaption> </figure> </p> <p data-ke-size="size16">&nbsp;</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="453" data-origin-height="440"><span data-url="https://blog.kakaocdn.net/dn/bcicfu/btsKAKdUFEd/tSHs1TKEcgZ0Ssq86wizgK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bcicfu/btsKAKdUFEd/tSHs1TKEcgZ0Ssq86wizgK/img.png" data-alt="저장해둔 설정 불러와서 터미널 열기"><img src="https://blog.kakaocdn.net/dn/bcicfu/btsKAKdUFEd/tSHs1TKEcgZ0Ssq86wizgK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbcicfu%2FbtsKAKdUFEd%2FtSHs1TKEcgZ0Ssq86wizgK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="453" data-origin-height="440"/></span><figcaption>저장해둔 설정 불러와서 터미널 열기</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1018" data-origin-height="427"><span data-url="https://blog.kakaocdn.net/dn/KJGpa/btsKBjmJ0Oz/MRbUCoyLnRprlXK57cpVs1/img.png" data-phocus="https://blog.kakaocdn.net/dn/KJGpa/btsKBjmJ0Oz/MRbUCoyLnRprlXK57cpVs1/img.png" data-alt="putty 실행창"><img src="https://blog.kakaocdn.net/dn/KJGpa/btsKBjmJ0Oz/MRbUCoyLnRprlXK57cpVs1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKJGpa%2FbtsKBjmJ0Oz%2FMRbUCoyLnRprlXK57cpVs1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1018" data-origin-height="427"/></span><figcaption>putty 실행창</figcaption> </figure> </p></description>
<category>Linux</category>
<category>Linux</category>
<category>putty</category>
<category>terminal</category>
<category>리눅스</category>
<category>오블완</category>
<category>원격</category>
<category>터미널</category>
<category>티스토리챌린지</category>
<category>푸티</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/233</guid>
<comments>https://estar987.com/entry/Putty-%EA%B8%80%EC%94%A8-%EC%84%A4%EC%A0%95#entry233comment</comments>
<pubDate>Sun, 10 Nov 2024 12:00:57 +0900</pubDate>
</item>
<item>
<title>[DevOps]인프라 자동화의 핵심 도구들: Terraform, cloud-init, Helm, Ansible, Vagrant</title>
<link>https://estar987.com/entry/DevOps%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%9E%90%EB%8F%99%ED%99%94%EC%9D%98-%ED%95%B5%EC%8B%AC-%EB%8F%84%EA%B5%AC%EB%93%A4-Terraform-cloud-init-Helm-Ansible-Vagrant</link>
<description><p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1100" data-origin-height="621"><span data-url="https://blog.kakaocdn.net/dn/dyjIKy/btsKyBU26dq/fOnkq9hhakZmOjfBfSqggK/img.png" data-phocus="https://blog.kakaocdn.net/dn/dyjIKy/btsKyBU26dq/fOnkq9hhakZmOjfBfSqggK/img.png"><img src="https://blog.kakaocdn.net/dn/dyjIKy/btsKyBU26dq/fOnkq9hhakZmOjfBfSqggK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdyjIKy%2FbtsKyBU26dq%2FfOnkq9hhakZmOjfBfSqggK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1100" data-origin-height="621"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">자동화와 인프라 관리는 이제 IT 환경에서 필수적인 요소로 자리 잡았습니다. 인프라를 코드로 관리하는 <b>IaC(Infrastructure as Code)</b> 도구들이 발전하면서, 개발과 운영 환경에서 시간과 비용을 절감하고 일관성을 높일 수 있는 다양한 방법이 생겼습니다. 이번 포스팅에서는 Terraform, cloud-init, Helm, Ansible, Vagrant와 같은 대표적인 자동화 도구들을 살펴보고, 이들을 <b>가상머신</b>, <b>컨테이너</b>, <b>Kubernetes</b> 환경에 적용하는 방법을 소개하겠습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Terraform: 인프라를 코드로 선언하기</h3> <p data-ke-size="size16"><b>Terraform</b>은 클라우드 리소스를 코드로 선언하고 프로비저닝하는 도구입니다. AWS, GCP, Azure 같은 주요 클라우드 서비스 제공자뿐 아니라, vSphere, OpenStack과 같은 가상화 플랫폼에서도 사용할 수 있습니다. Terraform을 활용하면 복잡한 인프라 설정을 코드로 정의해 일관성 있는 환경을 빠르게 배포할 수 있습니다. Terraform의 코드 작성 방식은 선언적이기 때문에, 코드만 작성하면 Terraform이 필요한 리소스를 알아서 프로비저닝해줍니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20"><b>예시</b></h4> <p data-ke-size="size16">AWS에서 Kubernetes 클러스터를 생성하고 싶다면, Terraform 코드에서 EKS와 관련 네트워크 설정을 정의해 두면 자동으로 클러스터와 필요한 자원이 생성됩니다. 이후 Kubernetes 애플리케이션 배포는 Helm을 통해 관리할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Helm: Kubernetes 패키지 관리자로 자동화된 애플리케이션 배포</h3> <p data-ke-size="size16"><b>Helm</b>은 Kubernetes 애플리케이션을 패키지 형태로 관리하고 배포하는 도구입니다. Kubernetes 클러스터에 여러 리소스(Pod, Service, ConfigMap 등)를 한 번에 배포할 수 있는 설정 파일을 Helm 차트로 정의해두면, 복잡한 애플리케이션도 손쉽게 배포할 수 있습니다. Terraform과 연동하면, Terraform으로 생성된 Kubernetes 클러스터에 Helm 차트를 이용해 애플리케이션을 자동으로 배포할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>예시</b></h4> <p data-ke-size="size16">Terraform으로 Kubernetes 클러스터를 구성하고, Helm을 통해 NGINX, Prometheus와 같은 서비스를 손쉽게 배포합니다. 이를 통해 Kubernetes 클러스터에 필요한 모든 애플리케이션과 설정을 코드로 관리할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">cloud-init: 가상머신 초기 설정 자동화</h3> <p data-ke-size="size16"><b>cloud-init</b>은 클라우드 환경에서 가상머신(VM)이 처음 부팅될 때 초기 설정을 자동으로 적용하는 도구입니다. Terraform으로 VM을 생성하는 과정에서 cloud-init 스크립트를 추가해두면, VM이 시작될 때 자동으로 네트워크 설정, 패키지 설치, 계정 생성 등이 완료됩니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>예시</b></h4> <p data-ke-size="size16">Terraform을 사용해 가상머신을 생성하고, cloud-init을 통해 필요 패키지 설치와 초기 환경을 설정하면 모든 VM이 동일한 상태로 배포됩니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Ansible: 상태 관리와 서버 구성 관리</h3> <p data-ke-size="size16"><b>Ansible</b>은 서버의 구성과 설정을 코드로 관리하는 도구로, 대규모 서버 환경에서 일관성 있는 설정과 배포를 가능하게 합니다. Agentless 방식이기 때문에 별도의 설치 없이 SSH를 통해 원격 서버를 관리할 수 있으며, 여러 서버에 동시에 패키지 설치, 서비스 설정, 파일 배포 등을 수행할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>예시</b></h4> <p data-ke-size="size16">서버에 필요한 패키지나 설정이 자주 변경되는 경우 Ansible을 사용해 간단한 Playbook으로 여러 서버를 동시에 관리할 수 있습니다. Kubernetes 환경에서는 Helm이 주로 사용되지만, 서버 운영체제 설정이나 설정 파일 배포에는 Ansible이 효율적입니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Vagrant: 가상 머신 개발 환경 자동화</h3> <p data-ke-size="size16"><b>Vagrant</b>는 개발 환경에서 가상머신을 쉽게 생성하고 설정할 수 있게 도와주는 도구입니다. Vagrantfile에 정의된 설정을 통해, 동일한 개발 환경을 쉽게 배포하고 관리할 수 있어, 팀원 간의 환경 불일치 문제를 해결할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>예시</b></h4> <p data-ke-size="size16">개발팀에서 공통 환경을 맞춰야 하는 경우 Vagrant를 사용하여 동일한 VM 설정을 배포합니다. 여러 버전의 VM이 필요할 경우에도 Vagrantfile만 수정하면 되기 때문에 편리합니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">자동화 도구 조합하여 사용하는 예시: 가상머신, 컨테이너, Kubernetes 환경</h3> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">가상머신 환경 자동화</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b> Terraform + cloud-init</b>: 클라우드 환경에 가상머신을 생성하고, cloud-init으로 네트워크, 사용자 계정, 기본 패키지를 설정합니다.</li> <li><b> Terraform + Ansible</b>: cloud-init으로 기본 설정이 끝난 후 Ansible로 세부 설정을 추가하고 서비스 배포를 진행합니다.</li> </ul> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">컨테이너 및 Kubernetes 환경 자동화</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b> Terraform + Helm</b>: Kubernetes 클러스터를 생성하고, Helm을 통해 컨테이너화된 애플리케이션을 패키지 형태로 배포합니다.</li> <li><b> Vagrant + Ansible</b>: 로컬 개발 환경에서 컨테이너와 애플리케이션 설정을 일관성 있게 유지합니다. Vagrant로 VM을 생성하고, Ansible로 필요한 설정을 추가합니다.</li> </ul> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>ansible</category>
<category>cloud init</category>
<category>DevOps</category>
<category>helm</category>
<category>Terraform</category>
<category>가상머신 자동화</category>
<category>도커</category>
<category>오블완</category>
<category>자동화</category>
<category>컨테이너 자동화</category>
<category>쿠버네티스</category>
<category>티스토리챌린지</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/232</guid>
<comments>https://estar987.com/entry/DevOps%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%9E%90%EB%8F%99%ED%99%94%EC%9D%98-%ED%95%B5%EC%8B%AC-%EB%8F%84%EA%B5%AC%EB%93%A4-Terraform-cloud-init-Helm-Ansible-Vagrant#entry232comment</comments>
<pubDate>Sat, 9 Nov 2024 12:00:06 +0900</pubDate>
</item>
<item>
<title>[Ubuntu24.04] XRDP로 윈도우에서 리눅스 화면 열기</title>
<link>https://estar987.com/entry/Ubuntu2404-XRDP%EB%A1%9C-%EC%9C%88%EB%8F%84%EC%9A%B0%EC%97%90%EC%84%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%99%94%EB%A9%B4-%EC%97%B4%EA%B8%B0</link>
<description><p data-ke-size="size16"><a href="https://estar987.com/109" target="_blank" rel="noopener">2024.04.01 - [Linux] - 리눅스 우분투 설치 후 기본 설정</a></p> <figure id="og_1730785100690" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="리눅스 우분투 설치 후 기본 설정" data-og-description="패키지 설치 $ sudo apt -y update $ sudo passwd root $ su - # apt -y install openssh-server vim net-tools ssh 설정 root 계정으로 ssh 접속하기 위한 설정 # vi /etc/ssh/sshd_config 34 PermitRootLogin yes // yes로 변경 58 PasswordAuthentic" data-og-host="estar987.com" data-og-source-url="https://estar987.com/109" data-og-url="https://estar987.com/109" data-og-image="https://scrap.kakaocdn.net/dn/OQTGS/hyXsSQQG75/7NfSuFUbAhMREDV17skRmK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/d8RcAj/hyXsXYUNzJ/svSSOFqvAnVkdr4Kvq1hok/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800"><a href="https://estar987.com/109" target="_blank" rel="noopener" data-source-url="https://estar987.com/109"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/OQTGS/hyXsSQQG75/7NfSuFUbAhMREDV17skRmK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/d8RcAj/hyXsXYUNzJ/svSSOFqvAnVkdr4Kvq1hok/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">리눅스 우분투 설치 후 기본 설정</p> <p class="og-desc" data-ke-size="size16">패키지 설치 $ sudo apt -y update $ sudo passwd root $ su - # apt -y install openssh-server vim net-tools ssh 설정 root 계정으로 ssh 접속하기 위한 설정 # vi /etc/ssh/sshd_config 34 PermitRootLogin yes // yes로 변경 58 PasswordAuthentic</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">시작전...</h3> <p data-ke-size="size16">이전에 포스팅 한 우분투 기본 설정을 한 후 진행한다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">인터넷(외부망)이 안되는 환경에서 XRDP를 설치하여 실행하는 과정을 포스팅하려고 한다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">필요한 deb 파일들</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>apt-get download &lt;패키지 명&gt; 으로 받으면 된다.</li> </ul> <pre id="code_1730785184309" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ls keyboard-configuration_1.226ubuntu1_all.deb libudev1_255.4-1ubuntu8.4_amd64.deb libaudit1_1%3a3.1.2-2.1build1_amd64.deb libunwind8_1.6.2-3build1_amd64.deb libc6_2.39-0ubuntu8.3_amd64.deb libxau6_1%3a1.0.9-1build6_amd64.deb libdbus-1-3_1.14.10-4ubuntu4.1_amd64.deb libxcvt0_0.1.2-1build1_amd64.deb libdrm2_2.4.120-2build1_amd64.deb libxdmcp6_1%3a1.1.3-0ubuntu6_amd64.deb libegl1_1.7.0-1build1_amd64.deb libxfont2_1%3a2.0.6-1build1_amd64.deb libepoxy0_1.5.10-1build1_amd64.deb libxshmfence1_1.3-1build5_amd64.deb libfuse2t64_2.9.9-8.1build1_amd64.deb pipewire-module-xrdp_0.2-2_all.deb libgbm1_24.0.9-0ubuntu0.2_amd64.deb udev_255.4-1ubuntu8.4_amd64.deb libgcrypt20_1.10.3-2build1_amd64.deb x11proto-dev_2023.2-1_all.deb libgl1_1.7.0-1build1_amd64.deb xfce4_4.18_all.deb libpciaccess0_0.17-3build1_amd64.deb xorg-sgml-doctools_1%3a1.11-1.1_all.deb libpixman-1-0_0.42.2-1build1_amd64.deb xserver-common_2%3a21.1.12-1ubuntu1.1_all.deb libselinux1_3.5-2ubuntu2_amd64.deb xserver-xorg-core_2%3a21.1.12-1ubuntu1.1_amd64.deb libsystemd0_255.4-1ubuntu8.4_amd64.deb xtrans-dev_1.4.0-1_all.deb</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>xrdp deb 파일 <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>설치하면 데몬이 생성될 것이다.&nbsp;</li> </ul> </li> </ul> <pre id="code_1730785315146" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ls xorgxrdp_1%3a0.9.19-1_amd64.deb xrdp_0.9.24-4_amd64.deb</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>패키지 설치</li> </ul> <pre id="code_1730786181179" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>dpkg -i &lt;패키지 명.deb&gt;</code></pre> <h3 data-ke-size="size23">데몬 확인</h3> <pre id="code_1730786343211" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># systemctl status xrdp xrdp.service xrdp-sesman.service root@fianl:~/xrdp# systemctl status xrdp.service ● xrdp.service - xrdp daemon Loaded: loaded (/usr/lib/systemd/system/xrdp.service; enabled; preset: enabled) Active: active (running) since Tue 2024-11-05 14:58:25 KST; 16s ago Docs: man:xrdp(8) man:xrdp.ini(5) Process: 20582 ExecStartPre=/bin/sh /usr/share/xrdp/socksetup (code=exited, status=0/SUCCESS) Process: 20591 ExecStart=/usr/sbin/xrdp $XRDP_OPTIONS (code=exited, status=0/SUCCESS) Main PID: 20592 (xrdp) Tasks: 1 (limit: 4613) Memory: 860.0K (peak: 1.6M) CPU: 41ms CGroup: /system.slice/xrdp.service └─20592 /usr/sbin/xrdp Nov 05 14:58:24 fianl systemd[1]: Starting xrdp.service - xrdp daemon... Nov 05 14:58:24 fianl xrdp[20591]: [INFO ] address [0.0.0.0] port [3389] mode 1 Nov 05 14:58:24 fianl xrdp[20591]: [INFO ] listening to port 3389 on 0.0.0.0 Nov 05 14:58:24 fianl xrdp[20591]: [INFO ] xrdp_listen_pp done Nov 05 14:58:24 fianl systemd[1]: xrdp.service: Can't open PID file /run/xrdp/xrdp.pid (yet?) after start: No such file or d&gt; Nov 05 14:58:25 fianl systemd[1]: Started xrdp.service - xrdp daemon. Nov 05 14:58:26 fianl xrdp[20592]: [INFO ] starting xrdp with pid 20592 Nov 05 14:58:26 fianl xrdp[20592]: [INFO ] address [0.0.0.0] port [3389] mode 1 Nov 05 14:58:26 fianl xrdp[20592]: [INFO ] listening to port 3389 on 0.0.0.0 Nov 05 14:58:26 fianl xrdp[20592]: [INFO ] xrdp_listen_pp done</code></pre> <pre id="code_1730786358612" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># systemctl status xrdp-sesman.service ● xrdp-sesman.service - xrdp session manager Loaded: loaded (/usr/lib/systemd/system/xrdp-sesman.service; enabled; preset: enabled) Active: active (running) since Tue 2024-11-05 14:58:24 KST; 25s ago Docs: man:xrdp-sesman(8) man:sesman.ini(5) Process: 20579 ExecStart=/usr/sbin/xrdp-sesman $SESMAN_OPTIONS (code=exited, status=0/SUCCESS) Main PID: 20580 (xrdp-sesman) Tasks: 1 (limit: 4613) Memory: 888.0K (peak: 1.5M) CPU: 12ms CGroup: /system.slice/xrdp-sesman.service └─20580 /usr/sbin/xrdp-sesman Nov 05 14:58:24 fianl systemd[1]: Starting xrdp-sesman.service - xrdp session manager... Nov 05 14:58:24 fianl xrdp-sesman[20580]: [INFO ] starting xrdp-sesman with pid 20580 Nov 05 14:58:24 fianl systemd[1]: Started xrdp-sesman.service - xrdp session manager. root@fianl:~/xrdp#</code></pre> <h3 data-ke-size="size23">접속할 사용자 추가 및 패스워드 설</h3> <pre id="code_1730786413356" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>useradd -m -s /bin/bash user1 ... useradd -m -s /bin/bash user4 passwd user1 ... passwd user4</code></pre> <h3 data-ke-size="size23">방화벽 포트 추가 및 방화벽 활성화</h3> <pre id="code_1730786504029" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo ufw allow 3389/tcp ufw disable systemctl stop ufw.service systemctl disable ufw.service systemctl status ufw.service ufw status Sattus: inactive</code></pre> <h3 data-ke-size="size23">데몬 방화벽 확인</h3> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="815" data-origin-height="233"><span data-url="https://blog.kakaocdn.net/dn/nWhzh/btsKwZJblhh/6xVvvrLtSbofBQ4hg5ctOk/img.png" data-phocus="https://blog.kakaocdn.net/dn/nWhzh/btsKwZJblhh/6xVvvrLtSbofBQ4hg5ctOk/img.png"><img src="https://blog.kakaocdn.net/dn/nWhzh/btsKwZJblhh/6xVvvrLtSbofBQ4hg5ctOk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnWhzh%2FbtsKwZJblhh%2F6xVvvrLtSbofBQ4hg5ctOk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="815" data-origin-height="233"/></span></figure> </p> <h3 data-ke-size="size23">재부팅</h3> <pre id="code_1730786585366" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>reboot</code></pre> <h3 data-ke-size="size23">윈도우에서 XRDP 실행</h3> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="197" data-origin-height="43"><span data-url="https://blog.kakaocdn.net/dn/MlyP9/btsKxjm3qZ0/SRAmM50TkkkG90ZvefXSb0/img.png" data-phocus="https://blog.kakaocdn.net/dn/MlyP9/btsKxjm3qZ0/SRAmM50TkkkG90ZvefXSb0/img.png"><img src="https://blog.kakaocdn.net/dn/MlyP9/btsKxjm3qZ0/SRAmM50TkkkG90ZvefXSb0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMlyP9%2FbtsKxjm3qZ0%2FSRAmM50TkkkG90ZvefXSb0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="197" data-origin-height="43"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="471" data-origin-height="288"><span data-url="https://blog.kakaocdn.net/dn/Rdp4q/btsKxtiE9no/Aw1vmZNwVZbKAydJKG8R51/img.png" data-phocus="https://blog.kakaocdn.net/dn/Rdp4q/btsKxtiE9no/Aw1vmZNwVZbKAydJKG8R51/img.png"><img src="https://blog.kakaocdn.net/dn/Rdp4q/btsKxtiE9no/Aw1vmZNwVZbKAydJKG8R51/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRdp4q%2FbtsKxtiE9no%2FAw1vmZNwVZbKAydJKG8R51%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="471" data-origin-height="288"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="456" data-origin-height="262"><span data-url="https://blog.kakaocdn.net/dn/vE77V/btsKw2eNMf1/gsOoW5Jd4QJK0kWzQxuKk1/img.png" data-phocus="https://blog.kakaocdn.net/dn/vE77V/btsKw2eNMf1/gsOoW5Jd4QJK0kWzQxuKk1/img.png"><img src="https://blog.kakaocdn.net/dn/vE77V/btsKw2eNMf1/gsOoW5Jd4QJK0kWzQxuKk1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvE77V%2FbtsKw2eNMf1%2FgsOoW5Jd4QJK0kWzQxuKk1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="456" data-origin-height="262"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="353" data-origin-height="434"><span data-url="https://blog.kakaocdn.net/dn/bk45vI/btsKyDx3YvY/6cCT8mveSXNuztAAqmXkjK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bk45vI/btsKyDx3YvY/6cCT8mveSXNuztAAqmXkjK/img.png"><img src="https://blog.kakaocdn.net/dn/bk45vI/btsKyDx3YvY/6cCT8mveSXNuztAAqmXkjK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbk45vI%2FbtsKyDx3YvY%2F6cCT8mveSXNuztAAqmXkjK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="353" data-origin-height="434"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="351" data-origin-height="427"><span data-url="https://blog.kakaocdn.net/dn/T0qqz/btsKw0ad0XY/XT48KZRqO5dCHUWfpg3nT0/img.png" data-phocus="https://blog.kakaocdn.net/dn/T0qqz/btsKw0ad0XY/XT48KZRqO5dCHUWfpg3nT0/img.png"><img src="https://blog.kakaocdn.net/dn/T0qqz/btsKw0ad0XY/XT48KZRqO5dCHUWfpg3nT0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FT0qqz%2FbtsKw0ad0XY%2FXT48KZRqO5dCHUWfpg3nT0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="351" data-origin-height="427"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2556" data-origin-height="1438"><span data-url="https://blog.kakaocdn.net/dn/M9x4T/btsKwNhEEcm/Z9QPMc4TYmITItdhdcGzPK/img.png" data-phocus="https://blog.kakaocdn.net/dn/M9x4T/btsKwNhEEcm/Z9QPMc4TYmITItdhdcGzPK/img.png"><img src="https://blog.kakaocdn.net/dn/M9x4T/btsKwNhEEcm/Z9QPMc4TYmITItdhdcGzPK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FM9x4T%2FbtsKwNhEEcm%2FZ9QPMc4TYmITItdhdcGzPK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2556" data-origin-height="1438"/></span></figure> </p></description>
<category>Linux</category>
<category>Linux</category>
<category>Protocol</category>
<category>RDP</category>
<category>ubuntu</category>
<category>Windows</category>
<category>xrdp</category>
<category>오블완</category>
<category>원격</category>
<category>원격 프로토콜</category>
<category>티스토리챌린지</category>
<category>프로토콜</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/231</guid>
<comments>https://estar987.com/entry/Ubuntu2404-XRDP%EB%A1%9C-%EC%9C%88%EB%8F%84%EC%9A%B0%EC%97%90%EC%84%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%99%94%EB%A9%B4-%EC%97%B4%EA%B8%B0#entry231comment</comments>
<pubDate>Fri, 8 Nov 2024 10:32:26 +0900</pubDate>
</item>
<item>
<title>[Ubuntu24] TurboVNC</title>
<link>https://estar987.com/entry/Ubuntu24-TurboVNC</link>
<description><h2 data-ke-size="size26">TurboVNC 설치&nbsp;</h2> <h3 data-ke-size="size23">서버(Ubuntu 24.04)</h3> <p data-ke-size="size16"><a href="https://sourceforge.net/projects/turbovnc/files/3.1/turbovnc_3.1_amd64.deb/download" target="_blank" rel="noopener&nbsp;noreferrer">https://sourceforge.net/projects/turbovnc/files/3.1/turbovnc_3.1_amd64.deb/download</a></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">설치 파일 받기 설치</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">아래 블로그 참고</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><a href="https://estar987.com/110" target="_blank" rel="noopener">2024.04.01 - [Virtual] - Ubuntu에 VNC 설치</a></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">클라이언트(접속하려는 Windows)</h3> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1107" data-origin-height="1096"><span data-url="https://blog.kakaocdn.net/dn/Va8Vj/btsKwzXwRRl/8kCWCL9VIY15VDSCV7wPAK/img.png" data-phocus="https://blog.kakaocdn.net/dn/Va8Vj/btsKwzXwRRl/8kCWCL9VIY15VDSCV7wPAK/img.png"><img src="https://blog.kakaocdn.net/dn/Va8Vj/btsKwzXwRRl/8kCWCL9VIY15VDSCV7wPAK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVa8Vj%2FbtsKwzXwRRl%2F8kCWCL9VIY15VDSCV7wPAK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1107" data-origin-height="1096"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <p><figure class="imageblock widthContent" data-ke-mobileStyle="widthOrigin" data-origin-width="147" data-origin-height="32"><span data-url="https://blog.kakaocdn.net/dn/cEgUmH/btsKvdBCRrp/ZiqxuIAPEiwphekoKCa6rK/img.png" data-phocus="https://blog.kakaocdn.net/dn/cEgUmH/btsKvdBCRrp/ZiqxuIAPEiwphekoKCa6rK/img.png"><img src="https://blog.kakaocdn.net/dn/cEgUmH/btsKvdBCRrp/ZiqxuIAPEiwphekoKCa6rK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcEgUmH%2FbtsKvdBCRrp%2FZiqxuIAPEiwphekoKCa6rK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="147" data-origin-height="32"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="491" data-origin-height="395"><span data-url="https://blog.kakaocdn.net/dn/0gYOO/btsKv7gfNio/vEuGi98nUH5KHYxOQOmCb0/img.png" data-phocus="https://blog.kakaocdn.net/dn/0gYOO/btsKv7gfNio/vEuGi98nUH5KHYxOQOmCb0/img.png"><img src="https://blog.kakaocdn.net/dn/0gYOO/btsKv7gfNio/vEuGi98nUH5KHYxOQOmCb0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F0gYOO%2FbtsKv7gfNio%2FvEuGi98nUH5KHYxOQOmCb0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="491" data-origin-height="395"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="499" data-origin-height="391"><span data-url="https://blog.kakaocdn.net/dn/bO4ju6/btsKw4CNEFp/ar1ikrDqvkHkXsDhz8Wd7k/img.png" data-phocus="https://blog.kakaocdn.net/dn/bO4ju6/btsKw4CNEFp/ar1ikrDqvkHkXsDhz8Wd7k/img.png"><img src="https://blog.kakaocdn.net/dn/bO4ju6/btsKw4CNEFp/ar1ikrDqvkHkXsDhz8Wd7k/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbO4ju6%2FbtsKw4CNEFp%2Far1ikrDqvkHkXsDhz8Wd7k%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="499" data-origin-height="391"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="500" data-origin-height="386"><span data-url="https://blog.kakaocdn.net/dn/bQ89Zq/btsKvMXLmml/63Q9p7ZE5enzWbklWnnxj0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bQ89Zq/btsKvMXLmml/63Q9p7ZE5enzWbklWnnxj0/img.png"><img src="https://blog.kakaocdn.net/dn/bQ89Zq/btsKvMXLmml/63Q9p7ZE5enzWbklWnnxj0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQ89Zq%2FbtsKvMXLmml%2F63Q9p7ZE5enzWbklWnnxj0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="500" data-origin-height="386"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="501" data-origin-height="393"><span data-url="https://blog.kakaocdn.net/dn/dnipKR/btsKvIOzyP1/7L0yDQfQuEEFP0Atkc7Fm0/img.png" data-phocus="https://blog.kakaocdn.net/dn/dnipKR/btsKvIOzyP1/7L0yDQfQuEEFP0Atkc7Fm0/img.png"><img src="https://blog.kakaocdn.net/dn/dnipKR/btsKvIOzyP1/7L0yDQfQuEEFP0Atkc7Fm0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdnipKR%2FbtsKvIOzyP1%2F7L0yDQfQuEEFP0Atkc7Fm0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="501" data-origin-height="393"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="494" data-origin-height="390"><span data-url="https://blog.kakaocdn.net/dn/bnIa3q/btsKxwFLBZS/GbOlHNo0VDhNuRmPGVlbQ0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bnIa3q/btsKxwFLBZS/GbOlHNo0VDhNuRmPGVlbQ0/img.png"><img src="https://blog.kakaocdn.net/dn/bnIa3q/btsKxwFLBZS/GbOlHNo0VDhNuRmPGVlbQ0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbnIa3q%2FbtsKxwFLBZS%2FGbOlHNo0VDhNuRmPGVlbQ0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="494" data-origin-height="390"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-filename="blob" data-origin-width="483" data-origin-height="139"><span data-url="https://blog.kakaocdn.net/dn/vO0Tb/btsKxqezzfB/SwHzCaBKgovVkxSBLnstN0/img.png" data-phocus="https://blog.kakaocdn.net/dn/vO0Tb/btsKxqezzfB/SwHzCaBKgovVkxSBLnstN0/img.png"><img src="https://blog.kakaocdn.net/dn/vO0Tb/btsKxqezzfB/SwHzCaBKgovVkxSBLnstN0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvO0Tb%2FbtsKxqezzfB%2FSwHzCaBKgovVkxSBLnstN0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-filename="blob" data-origin-width="483" data-origin-height="139"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="416" data-origin-height="95"><span data-url="https://blog.kakaocdn.net/dn/bDyjM4/btsKvCnsypv/wH9vt2KRUxMFnB0ODlflOK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bDyjM4/btsKvCnsypv/wH9vt2KRUxMFnB0ODlflOK/img.png"><img src="https://blog.kakaocdn.net/dn/bDyjM4/btsKvCnsypv/wH9vt2KRUxMFnB0ODlflOK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDyjM4%2FbtsKvCnsypv%2FwH9vt2KRUxMFnB0ODlflOK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="416" data-origin-height="95"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="469" data-origin-height="113"><span data-url="https://blog.kakaocdn.net/dn/dwg0YC/btsKvBoBcgc/mkRbGytwT8tCYKazY82ji0/img.png" data-phocus="https://blog.kakaocdn.net/dn/dwg0YC/btsKvBoBcgc/mkRbGytwT8tCYKazY82ji0/img.png"><img src="https://blog.kakaocdn.net/dn/dwg0YC/btsKvBoBcgc/mkRbGytwT8tCYKazY82ji0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdwg0YC%2FbtsKvBoBcgc%2FmkRbGytwT8tCYKazY82ji0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="469" data-origin-height="113"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1237" data-origin-height="951"><span data-url="https://blog.kakaocdn.net/dn/bSB7Xa/btsKxjUa0Lc/ZaoChjzWxHJxg3KHTUKXQK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bSB7Xa/btsKxjUa0Lc/ZaoChjzWxHJxg3KHTUKXQK/img.png"><img src="https://blog.kakaocdn.net/dn/bSB7Xa/btsKxjUa0Lc/ZaoChjzWxHJxg3KHTUKXQK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbSB7Xa%2FbtsKxjUa0Lc%2FZaoChjzWxHJxg3KHTUKXQK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1237" data-origin-height="951"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>Linux</category>
<category>GUI</category>
<category>Linux</category>
<category>ubuntu</category>
<category>vnc\</category>
<category>xrdp</category>
<category>리눅스</category>
<category>외부 접속</category>
<category>우분투</category>
<category>클라이언트</category>
<category>프로토콜</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/230</guid>
<comments>https://estar987.com/entry/Ubuntu24-TurboVNC#entry230comment</comments>
<pubDate>Thu, 7 Nov 2024 12:00:58 +0900</pubDate>
</item>
<item>
<title>[Devops] Terraform + Cloud-init &amp; Ansible</title>
<link>https://estar987.com/entry/Devops-Terraform-Cloud-init-Ansible</link>
<description><p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1100" data-origin-height="621"><span data-url="https://blog.kakaocdn.net/dn/cmMVLj/btsKw61ziEN/Duco4HVpRKC38ELrFBm2x1/img.png" data-phocus="https://blog.kakaocdn.net/dn/cmMVLj/btsKw61ziEN/Duco4HVpRKC38ELrFBm2x1/img.png"><img src="https://blog.kakaocdn.net/dn/cmMVLj/btsKw61ziEN/Duco4HVpRKC38ELrFBm2x1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmMVLj%2FbtsKw61ziEN%2FDuco4HVpRKC38ELrFBm2x1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1100" data-origin-height="621"/></span></figure> </p> <p data-ke-size="size16">현대의 IT 인프라 환경에서, 시스템 관리자와 DevOps 엔지니어들은 인프라를 효율적으로 관리하기 위해 다양한 자동화 도구를 사용합니다. 이 글에서는 <b>Terraform + Cloud-init</b> 조합과 <b>Ansible</b>을 비교하여 각 도구의 역할과 사용 목적을 살펴보겠습니다. 특히 위의 이미지에서 각 도구의 주요 사용 영역을 시각적으로 표현하고 있으니 참고하시기 바랍니다.</p> <p data-ke-size="size16">&nbsp;</p> <h2 data-ke-size="size26">1. Terraform과 Cloud-init의 조합: 인프라 프로비저닝 및 초기 설정</h2> <h3 data-ke-size="size23">Terraform의 역할: 인프라 생성 및 관리</h3> <p data-ke-size="size16">Terraform은<b> Infrastructure as Code (IaC)</b>를 지원하여 AWS, Azure, GCP와 같은 클라우드 환경에서 인프라 리소스를 선언적 코드로 정의하고 관리합니다. 이를 통해 EC2 인스턴스, S3 버킷, 네트워크 구성 등의 리소스를 쉽게 생성하고, 변경 사항을 관리할 수 있습니다.</p> <h3 data-ke-size="size23">Cloud-init의 역할: 초기 설정 자동화</h3> <p data-ke-size="size16">Terraform으로 인프라를 생성한 후, <b>Cloud-init</b>을 사용하여 인스턴스의 초기 설정을 자동화할 수 있습니다. Cloud-init은 인스턴스가 처음 시작될 때 자동으로 실행되어 필요한 설정을 적용합니다. 예를 들어, 특정 패키지 설치, 사용자 생성, 초기 설정 등을 자동으로 처리합니다.</p> <h4 data-ke-size="size20">예시</h4> <pre id="code_1730724311863" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>#cloud-config packages: - nginx - git runcmd: - systemctl start nginx - echo "Hello World" &gt; /var/www/html/index.html</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">이 Cloud-init 스크립트를 통해 서버가 부팅될 때 Nginx 웹 서버를 자동으로 설치하고, 기본 웹 페이지를 설정할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">Terraform + Cloud-init 조합의 주요 특징</h4> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>인프라 생성 및 초기 설정 자동화</b>: <b>Terraform</b>으로 인프라 리소스를 생성하고, <b>Cloud-init</b>으로 필요한 초기 설정을 자동화할 수 있습니다.</li> <li><b>반복적인 인프라 구축에 유리</b>: 동일한 인프라 환경을 여러 번 반복해서 구축해야 할 때 유용합니다.</li> <li><b>초기 설정에 중점</b>: Terraform + Cloud-init 조합은 주로 인프라가 최초로 생성될 때 필요한 설정을 처리하며, 지속적인 설정 관리는 부족한 편입니다.</li> </ul> <h3 data-ke-size="size23">2. Ansible: 지속적인 구성 관리와 애플리케이션 배포</h3> <p data-ke-size="size16">반면, <b>Ansible</b>은 <b>지속적인 구성 관리와 애플리케이션 배포</b>에 강점을 가지고 있습니다. Ansible은 에이전트가 필요 없는 구조로 SSH를 통해 여러 서버에 동시에 명령을 실행할 수 있으며, 지속적인 설정 변경, 애플리케이션 업데이트, 보안 패치 관리 등과 같은 작업을 자동화하는 데 유용합니다.</p> <h4 data-ke-size="size20">Ansible의 역할: 구성 관리 및 애플리케이션 배포</h4> <p data-ke-size="size16">Ansible은 YAML 기반의 Playbook을 사용하여 서버의 구성 관리와 애플리케이션 배포를 코드로 정의합니다. 이를 통해 서버에 패키지를 설치하거나 설정을 변경하고, 애플리케이션을 배포하는 등 운영 중인 서버의 설정을 지속적으로 관리할 수 있습니다.</p> <h4 data-ke-size="size20">Ansible Playbook 예시:</h4> <pre id="code_1730724498297" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>- name: Install and configure Nginx hosts: web_servers tasks: - name: Install Nginx apt: name: nginx state: present - name: Start Nginx service: name: nginx state: started - name: Deploy index.html copy: content: "Hello World" dest: /var/www/html/index.html</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">이 Playbook을 실행하면 지정된 서버 그룹(web_servers)에 Nginx가 설치되고, 기본 페이지가 설정됩니다. 이처럼 Ansible은 서버가 이미 운영 중인 상황에서 추가적인 설정을 적용하고, 서버 설정을 지속적으로 관리하는 데 효과적입니다.</p> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">Ansible의 주요 특징</h4> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>지속적인 구성 관리</b>: 서버가 운영되는 동안에도 설정을 변경하거나 업데이트할 수 있어 운영 환경에서 유연하게 대처할 수 있습니다.</li> <li><b>애플리케이션 배포 및 업데이트</b>: Ansible은 애플리케이션 배포, 보안 패치, 시스템 설정 변경 등을 쉽게 수행할 수 있어 DevOps 파이프라인에 적합합니다.</li> <li><b>확장성</b>: 여러 서버에 동시에 작업을 적용할 수 있어, 대규모 서버 환경에서도 일관된 설정을 유지할 수 있습니다.</li> </ul> <h3 data-ke-size="size23">3. Terraform + Cloud-init과 Ansible의 차이점 요약</h3> <table style="border-collapse: collapse; width: 100%; height: 105px;" border="1" data-ke-align="alignLeft" data-ke-style="style12"> <tbody> <tr style="height: 20px;"> <td style="width: 18.217%; height: 20px;">기능</td> <td style="width: 41.8217%; height: 20px;">Terraform + Cloud init</td> <td style="width: 39.9612%; height: 20px;">Ansible</td> </tr> <tr style="height: 17px;"> <td style="width: 18.217%; height: 17px;">주요 역할</td> <td style="width: 41.8217%; height: 17px;">인프라 생성 및&nbsp; 초기 설정</td> <td style="width: 39.9612%; height: 17px;">지속적인 구성 및 애플리케이션 배포</td> </tr> <tr style="height: 17px;"> <td style="width: 18.217%; height: 17px;">설정 관리 방식</td> <td style="width: 41.8217%; height: 17px;">초기 설정에 중점(주로 부팅 시 1회 실행)</td> <td style="width: 39.9612%; height: 17px;">지속적인 설정 및 업데이트 관리</td> </tr> <tr style="height: 17px;"> <td style="width: 18.217%; height: 17px;">사용 예시</td> <td style="width: 41.8217%; height: 17px;">AWS EC2 인스턴스 생성 및 초기 패키지 설치</td> <td style="width: 39.9612%; height: 17px;">애플리케이션 배포, 보안 패치 적용</td> </tr> <tr style="height: 17px;"> <td style="width: 18.217%; height: 17px;">주요 특징</td> <td style="width: 41.8217%; height: 17px;">인파라의 일관된 생성과 초기 구성 자동화</td> <td style="width: 39.9612%; height: 17px;">에이전트리스 방식으로 운영 환경 관리 가능</td> </tr> <tr style="height: 17px;"> <td style="width: 18.217%; height: 17px;">적합한 사용 사례</td> <td style="width: 41.8217%; height: 17px;">새로운 인프라 환경 생성 및 초기 설정</td> <td style="width: 39.9612%; height: 17px;">운영 중인 서버의 지속적 관리 배포</td> </tr> </tbody> </table> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>ansible</category>
<category>cloud</category>
<category>cloudinit</category>
<category>DevOps</category>
<category>Linux</category>
<category>Terraform</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/229</guid>
<comments>https://estar987.com/entry/Devops-Terraform-Cloud-init-Ansible#entry229comment</comments>
<pubDate>Wed, 6 Nov 2024 12:00:36 +0900</pubDate>
</item>
<item>
<title>[Devops]AWS ECR vs Docker Hub: 왜 AWS ECR을 선택해야 할까?</title>
<link>https://estar987.com/entry/DevopsAWS-ECR-vs-Docker-Hub-%EC%99%9C-AWS-ECR%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">클라우드 기반 애플리케이션 개발에서 컨테이너 이미지를 저장하고 관리하는 일은 필수적인 과정입니다. 많은 개발자들이 Docker Hub를 이미지 저장소로 사용하지만, AWS 클라우드 환경에서 운영되는 애플리케이션에는 AWS ECR (Elastic Container Registry)을 사용하는 것이 훨씬 더 효율적일 수 있습니다. 이 글에서는 AWS ECR이 Docker Hub에 비해 어떤 장점을 제공하는지, 그리고 실제 운영 환경에서 ECR을 사용하는 이유에 대해 알아보겠습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">1. AWS ECR 이란?</h3> <p data-ke-size="size16">AWS ECR은 AWS에서 제공하는 <b>Docker 이미지 저장소 서비스</b>입니다. Docker Hub처럼 컨테이너 이미지를 저장하고 버전 관리할 수 있지만, AWS 환경에 최적화되어 있어 클라우드 기반 애플리케이션을 배포할 때 유용합니다. ECR은 AWS의 IAM, VPC, ECS, EKS 등과 통합되어 AWS 내부에서 안전하고 효율적으로 컨테이너 이미지를 관리할 수 있도록 설계되었습니다.</p> <h3 data-ke-size="size23">2. AWS ECR vs Docker Hub: 주요 차이점과 ECR의 장점</h3> <h4 data-ke-size="size20">2.1) 보안 및 IAM 통합</h4> <p data-ke-size="size16">AWS ECR은 <b>AWS IAM (Identity and Access Management)</b>과 통합되어 있어, <b>세밀한 접근 제어가 가능합니다</b>. 개발팀에서 각 팀원이나 서비스 계정별로 접근 권한을 설정할 수 있으며, 이를 통해 코드와 이미지를 안전하게 보호할 수 있습니다. 특히, ECR은 AWS VPC와도 통합되어 있어 퍼블릭 네트워크로 노출되지 않고 <b>프라이빗하게 사용할 수 있어 보안이 중요한 환경에 적합합니다</b>.</p> <p data-ke-size="size16">또한, ECR은 이미지 푸시 시 자동으로 <b>보안 스캔</b>을 수행해 이미지의 취약점을 분석합니다. 이렇게 함으로써 운영 환경에서 안전하지 않은 이미지가 배포되는 일을 방지할 수 있습니다.</p> <h4 data-ke-size="size20">2.2) AWS 서비스와의 통합성</h4> <p data-ke-size="size16">ECR은 <b>AWS ECS (Elastic Container Service)</b>, <b>EKS (Elastic Kubernetes Service)</b>와 같은 컨테이너 오케스트레이션 서비스와 원활하게 연동됩니다. 이를 통해 ECR에 저장된 이미지를 바로 ECS나 EKS로 가져와 사용할 수 있어 컨테이너 애플리케이션의 배포가 간편해집니다.</p> <p data-ke-size="size16">또한, ECR은 <b>AWS CodePipeline, CodeBuild</b>와도 쉽게 통합됩니다. CodePipeline을 통해 GitHub나 CodeCommit에 코드가 푸시될 때 자동으로 ECR에 이미지를 빌드하고 푸시하는 CI/CD 파이프라인을 구축할 수 있습니다. AWS 내에서 이 모든 과정을 일관된 워크플로우로 처리할 수 있어 생산성과 유지 관리성이 높아집니다.</p> <h4 data-ke-size="size20">2.3) 비용 효율성</h4> <p data-ke-size="size16">AWS 환경 내에서 ECR을 사용할 경우 <b>데이터 전송 비용이 발생하지 않거나 매우 저렴</b>합니다. Docker Hub와 같은 외부 레지스트리에서 이미지를 가져오는 경우에는 AWS와 외부 간의 데이터 전송 비용이 발생할 수 있지만, ECR을 사용하면 이러한 비용을 절감할 수 있습니다.</p> <p data-ke-size="size16">또한, ECR은 <b>프리 티어</b>를 제공하여 소규모 프로젝트나 일정 용량을 넘지 않는 경우 무료로 사용할 수 있습니다. 이로 인해 클라우드 인프라 비용을 줄이는 데도 도움이 됩니다.</p> <h4 data-ke-size="size20">2.4) 네트워크 성능 최적화</h4> <p data-ke-size="size16">AWS 내부 네트워크를 통해 ECR에 접근하면 <b>이미지 다운로드 속도가 Docker Hub에 비해 훨씬 빠릅니다</b>. 특히, 대규모 클러스터 환경에서 여러 노드가 동시에 이미지를 가져와야 하는 경우, 외부 네트워크를 통한 다운로드는 배포 시간을 늘릴 수 있지만, ECR을 사용하면 빠르고 안정적으로 이미지를 다운로드할 수 있어 전체 배포 속도가 개선됩니다.</p> <h4 data-ke-size="size20">2.5) 다운로드 제한 및 안정성</h4> <p data-ke-size="size16">Docker Hub는 무료 계정에 대해 일정한 다운로드 제한(rate limiting)을 두고 있습니다. 이 때문에, 특정 기간 동안 많은 이미지를 다운로드해야 하는 경우 한도를 초과하여 작업이 지연될 수 있습니다. 반면, ECR은 <b>AWS 내에서 제한 없이 안정적인 이미지 제공이 가능</b>하며, AWS의 고가용성 인프라를 통해 이미지 저장소의 안정성을 보장받을 수 있습니다.</p> <h3 data-ke-size="size23">3. Trraform 과 ECR의 관계</h3> <p data-ke-size="size16">AWS ECR 리포지토리를 만들고 관리할 때는 <b>Terraform</b>과 같은 인프라 자동화 도구를 사용하는 것이 유리합니다. Terraform을 통해 ECR 리포지토리를 코드로 관리하면, 팀 전체가 동일한 설정을 공유할 수 있고, 여러 환경(개발, 스테이징, 프로덕션)에 동일한 리포지토리를 손쉽게 배포할 수 있습니다. 예를 들어, 다음과 같은 Terraform 코드를 사용하면 ECR 리포지토리를 자동으로 생성할 수 있습니다</p> <pre id="code_1730700378257" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>provider "aws" { region = "us-west-2" } resource "aws_ecr_repository" "my_repository" { name = "my-app-repo" image_tag_mutability = "MUTABLE" image_scanning_configuration { scan_on_push = true } }</code></pre> <p data-ke-size="size16">위의 코드를 통해 ECR 리포지토리를 생성하고, 자동으로 이미지 스캔을 활성화할 수 있습니다. 이를 통해 일관된 인프라 구성을 코드로 관리하면서 ECR 리포지토리를 효율적으로 운영할 수 있습니다.</p> <h3 data-ke-size="size23">4. ECR을 선택해야하는 이유 요약</h3> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>보안 강화</b>: IAM 및 VPC 통합으로 안전한 접근 제어 및 프라이빗 네트워크 액세스 가능.</li> <li><b>통합성</b>: AWS ECS, EKS, CodePipeline 등과 연동하여 원활한 컨테이너 배포 워크플로우 구축.</li> <li><b>비용 절감</b>: AWS 내 데이터 전송 비용 절감 및 프리 티어로 소규모 사용 무료.</li> <li><b>성능 최적화</b>: AWS 내부 네트워크를 통한 빠른 이미지 다운로드.</li> <li><b>다운로드 제한 없음</b>: Docker Hub의 다운로드 한도 문제 없이 안정적 사용 가능.</li> </ul> <h3 data-ke-size="size23">결론</h3> <p data-ke-size="size16">AWS 환경에서의 운영이나 대규모 배포가 필요할 때, <b>ECR은 Docker Hub보다 훨씬 더 효율적인 선택</b>이 될 수 있습니다. 특히 AWS 서비스와의 통합이 필요하거나 보안 및 비용 효율성이 중요한 경우, ECR은 이상적인 Docker 이미지 저장소로 작동할 것입니다. Terraform을 통해 ECR 리포지토리를 코드로 생성하고 관리하면, 더 나은 일관성 및 효율성을 얻을 수 있으며, 전체 인프라의 자동화를 촉진할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>AWS</category>
<category>DevOps</category>
<category>docker</category>
<category>docker hub</category>
<category>ecr</category>
<category>ECS</category>
<category>EKS</category>
<category>kubernetes</category>
<category>Terraform</category>
<category>저장소</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/228</guid>
<comments>https://estar987.com/entry/DevopsAWS-ECR-vs-Docker-Hub-%EC%99%9C-AWS-ECR%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C#entry228comment</comments>
<pubDate>Tue, 5 Nov 2024 12:00:30 +0900</pubDate>
</item>
<item>
<title>운영체제와 GCC, glibc, 커널, libstdc++의 상호작용 및 컴파일 원리</title>
<link>https://estar987.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-GCC-glibc-%EC%BB%A4%EB%84%90-libstdc%EC%9D%98-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9-%EB%B0%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%9B%90%EB%A6%AC</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16"><span data-token-index="0">운영체제에서 GCC가 컴파일러로 작동하는 원리와 관계 운영체제의 개발 환경을 다루다 보면 커널, glibc, GCC, 그리고 libstdc++ 간의 관계를 이해하는 것이 중요합니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0">이들은 각자의 역할을 수행하며 상호작용하여 프로그램을 실제로 실행 가능하게 만듭니다. 이번 포스트에서는 운영체제의 역할부터 프로그램이 소스 코드에서 실행 파일로 변환되는 과정을 단계별로 살펴보겠습니다. </span></p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">1. 운영체제와 커널</h3> <p data-ke-size="size16"><b>핵</b><span data-token-index="0"><b>심 구조 운영체제 (Operating System)</b>: 시스템 자원을 관리하고 사용자와 응용 프로그램이 하드웨어를 이용할 수 있게 하는 인터페이스 역할을 합니다. </span><span data-token-index="0">파일 시스템, 네트워킹, 프로세스 관리 등의 기능을 제공합니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0"><b>커널 (Kernel)</b>: 운영체제의 핵심으로 하드웨어와 소프트웨어 사이의 다리 역할을 합니다. 프로세스 관리, 메모리 할당, 파일 시스템 등 자원을 직접 제어하며, 사용자 모드의 프로그램이 자원에 접근할 수 있도록 시스템 호출(System Call)이라는 인터페이스를 제공합니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23"><span data-token-index="0">2. glibc의 역할</span></h3> <p data-ke-size="size16"><span data-token-index="0"><b>glibc (GNU C Library)</b>: C 표준 라이브러리로, 프로그램이 커널의 시스템 호출을 쉽게 사용할 수 있게 해주는 인터페이스입니다. 파일 입출력, 메모리 관리 등 저수준 기능들을 커널을 통해 실행하는 역할을 담당합니다. C 프로그램뿐만 아니라 C++ 프로그램에서도 glibc의 다양한 기능을 호출하여 OS의 자원을 활용합니다. </span></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0"><b>glibc와 커널의 관계</b>: glibc는 사용자 프로그램과 커널 사이에서 표준 라이브러리 인터페이스 역할을 수행하며, 프로그램이 직접 커널에 접근하지 않고도 고수준의 기능을 이용할 수 있게 합니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23"><span data-token-index="0"> <span data-token-index="0">3. GCC의 역할</span> </span></h3> <p data-ke-size="size16"><span data-token-index="0"><b>GCC (GNU Compiler Collection) 컴파일러 </b>: gcc는 주로 C, C++ 코드를 기계어로 컴파일하여 실행 가능한 바이너리를 생성합니다. C 및 C++ 프로그램을 컴파일할 때 glibc나 libstdc++(C++ 표준 라이브러리)를 링크하여 프로그램이 시스템 자원과 상호작용할 수 있도록 합니다. 컴파일 과정에서의 glibc 및 libstdc++: 프로그램이 gcc에 의해 컴파일될 때, 시스템 호출 인터페이스를 제공하는 glibc 및 C++ 표준 라이브러리 기능을 제공하는 libstdc++와 링크되어 프로그램이 운영체제와 원활히 상호작용할 수 있게 됩니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23"><span data-token-index="0"> <span data-token-index="0">4. libstdc++의 역할</span> </span></h3> <p data-ke-size="size16"><span data-token-index="0"><b>C++ 표준 라이브러리 libstdc++ (GNU Standard C++ Library)</b>: libstdc++는 벡터, 리스트와 같은 자료구조와 표준 입출력, 문자열 처리 등 C++ 표준 기능을 제공합니다. 이는 C++ 프로그램이 gcc로 컴파일될 때 자동으로 링크되어 C++ 표준 기능을 사용할 수 있게 합니다. glibc와 libstdc++의 상호작용: C++ 프로그램에서 표준 입출력이나 문자열 처리를 할 때, libstdc++는 glibc의 다양한 함수를 호출하여 OS의 기능을 활용하게 됩니다.</span></p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23"><span data-token-index="0"> <span data-token-index="0">운영체제에서 GCC가 작동하는 원리: 단계별 설명</span></span></h3> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20"><span data-token-index="0"> <span data-token-index="0">1. 운영체제 초기화 및 커널 실행</span> </span></h4> <p data-ke-size="size16"><span data-token-index="0">컴퓨터가 부팅되면, 하드웨어는 부트로더(Bootloader)를 실행하여 커널을 메모리에 로드하고 초기화합니다. 커널은 메모리, 프로세서, 장치 드라이버 등을 설정하고, 이후 사용자 애플리케이션이 실행될 수 있는 환경을 준비합니다. 시스템 초기화가 완료되면 커널은 첫 번째 사용자 프로세스를 시작하여 시스템이 응용 프로그램을 실행할 준비를 마칩니다. </span></p> <h4 data-ke-size="size20"><span data-token-index="0">2. 사용자 애플리케이션과 glibc의 상호작용</span></h4> <p data-ke-size="size16"><span data-token-index="0">사용자가 터미널에서 C/C++ 프로그램을 컴파일하려고 하면, 운영체제는 터미널 애플리케이션을 프로세스로 실행하여 명령을 입력받습니다. gcc 명령을 입력하면, 운영체제는 해당 바이너리를 로드하고 새로운 프로세스를 생성하여 컴파일 작업을 시작합니다. gcc는 이 과정에서 glibc 함수를 사용해 파일을 열고, 소스 코드를 읽으며, 컴파일 중 필요한 시스템 자원에 접근합니다.</span></p> <h4 data-ke-size="size20"><span data-token-index="0">3. GCC의 컴파일 및 링크 과정</span></h4> <p data-ke-size="size16"><span data-token-index="0">gcc는 소스 파일을 읽고 구문 분석, 최적화, 기계어 변환 등의 과정을 거치게 됩니다. 필요한 경우 glibc와 libstdc++를 링크하여 프로그램이 시스템 자원과 표준 라이브러리 기능을 사용할 수 있도록 합니다. 최종적으로 gcc는 소스 코드에서 필요한 glibc 시스템 호출을 감지하여, 생성된 바이너리가 커널과 원활하게 상호작용할 수 있게 설정합니다.</span></p> <h4 data-ke-size="size20"><span data-token-index="0"> <span data-token-index="0"> 4. 컴파일된 프로그램의 실행</span></span></h4> <p data-ke-size="size16"><span data-token-index="0">컴파일이 완료되면 실행 파일(예: a.out)이 생성되고, 이를 실행하면 운영체제가 해당 파일을 메모리에 로드하고 프로세스를 생성하게 됩니다. 실행 파일이 특정 OS 기능(예: 파일 입출력, 메모리 할당 등)을 사용해야 할 경우, 이러한 요청은 glibc를 통해 커널의 시스템 호출로 전달됩니다. 커널은 이러한 시스템 호출을 처리하여 프로그램이 요청한 작업을 수행하고, 그 결과를 프로그램에 반환합니다.</span></p> <h3 data-ke-size="size23"><span data-token-index="0">결론</span></h3> <p data-ke-size="size16"><span data-token-index="0">운영체제와 개발 환경의 조화 운영체제는 하드웨어와 사용자 프로그램 사이에서 중재자 역할을 수행하며, 그 핵심에는 커널이 자리잡고 있습니다. 커널은 시스템 호출을 통해 프로그램이 시스템 자원에 접근할 수 있게 해주고, glibc는 이러한 시스템 호출을 쉽게 사용할 수 있도록 도와줍니다. gcc는 이러한 환경에서 소스 코드를 바이너리로 컴파일하여 실행 파일을 생성하며, glibc와 libstdc++를 연결하여 프로그램이 실제로 실행될 수 있게 합니다. 이렇게 운영체제, 커널, glibc, gcc, libstdc++가 서로 긴밀히 협력하면서, 우리가 작성한 코드가 실제로 실행 가능한 상태로 만들어지는 것입니다.</span></p></description>
<category>Linux</category>
<category>C</category>
<category>C++</category>
<category>gcc</category>
<category>glibc</category>
<category>libstdc</category>
<category>Linux</category>
<category>OS</category>
<category>운영체제</category>
<category>커널</category>
<category>컴파일러</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/227</guid>
<comments>https://estar987.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-GCC-glibc-%EC%BB%A4%EB%84%90-libstdc%EC%9D%98-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9-%EB%B0%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%9B%90%EB%A6%AC#entry227comment</comments>
<pubDate>Fri, 1 Nov 2024 12:00:57 +0900</pubDate>
</item>
<item>
<title>[NETWORK] 네트워크(인피니밴드) 장애 처리</title>
<link>https://estar987.com/entry/NETWORK-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%B8%ED%94%BC%EB%8B%88%EB%B0%B4%EB%93%9C-%EC%9E%A5%EC%95%A0-%EC%B2%98%EB%A6%AC</link>
<description><h3 data-ke-size="size23">상황</h3> <p data-ke-size="size16">ifconfig에서는 ip가 할당된 것을 확인했음에도 통신이 되니 않는 경우(ping X)</p> <h3 data-ke-size="size23">1단계 : 링크 상태 확인</h3> <p data-ke-size="size16">네트워크 링크가 제대로 감지되었는지 확인하려면 다음 명령어를 사용한다.</p> <pre id="code_1730206471147" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ethtool br0</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">Link detected : no 가 보인다면 링크가 활성화되지 않았음. 이 경우 물리적 연결 문제나 인터페이스 설정 문제일 가능성이 높음</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">2단계 : 인피니밴드 인터페이스 상태 확인(ip addr vs nmtui)</h3> <p data-ke-size="size16">ip addr 명령어는 인터페이스의 상태와 IP 주소를 직접적으로 확인하고 설정할 수 있는 강력한 CLI 도구이다.</p> <p data-ke-size="size16">이 명령어를 사용하면 다음과 같이 인피니 밴드 인터페이스 상태를 확인할 수 있다.</p> <pre id="code_1730206584883" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ip addr show ib0</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">출력에서는 UP 상태인지, IP가 제대로 할당되었는지 등을 확인할 수 있음. 이넡펭스가 활성화되어 있지 않다면 다음 명령어로 활성화 가능</p> <pre id="code_1730206648757" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ip link set ib0 up</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">nmtui는 CLI 환경에서 네트워크 설정을 더 직관적으로 관리할 수 있는 텍스트 기반 사용자 인터페이스이다. ip addr 처럼 명령어 입력이 필요하지 않고, 메뉴를 통해 인터페이스를 설정하고 관리할 수 있다.</p> <pre id="code_1730206703596" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>nmtui</code></pre> <p data-ke-size="size16">이후 네트워크 연결 편집 메뉴에서 인터페이스를 선택하고 설정할 수 있음. nmtui는 IP 설정, DNS 구성 등 간편하게 설정 값을 수정할 수 있음</p> <h3 data-ke-size="size23">3단계 : ibstat 명령어로 인피니밴드 상태 확인</h3> <pre id="code_1730206825757" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ibstat</code></pre> <p data-ke-size="size16">물리적 연결 상태와 장치의 활성 상태를 보여줌</p> <p data-ke-size="size16">여기서 연결 상태가 DOWN으로 표시되면 케이블 연결 문제나 장치 설정이 문제일 수 있음</p> <h3 data-ke-size="size23">4단계 : 주소 수동 설정</h3> <p data-ke-size="size16">인터페이스가 정상적으로 활성화 되었으나 여전히 IP 문제로 네트워크가 작동하지 않는다면 IP를 수동으로 설정할 수 있음</p> <pre id="code_1730206889922" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ip addr add 192.168.100.2/24 dev ib0</code></pre> <h3 data-ke-size="size23">5단계 : 연결 테스트(ping test)</h3> <h3 data-ke-size="size23">6단계 : 하드 리셋 및 재 연결</h3> <p data-ke-size="size16">모든 소프트웨어 설정을 확인한 후에도 문제가 해결되지 않는다면 하드웨어 전체를 전원을 재부팅해보는 것도 추천한다.</p> <p data-ke-size="size16">전원 코드 및 모든 선을 제거 후 파워 버튼을 3~5초간 5~7번 눌러 잔여 전기를 모두 날려준 후 다시 케이블들을 연결하여 재부팅하면 문제가 해결되는 경우도 종종 있다.</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>Trouble Shooting</category>
<category>Hardware</category>
<category>HPC</category>
<category>InfiniBand</category>
<category>Linuix</category>
<category>Server</category>
<category>Trouble Shooting</category>
<category>경험</category>
<category>리눅스</category>
<category>서버</category>
<category>하드웨어</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/226</guid>
<comments>https://estar987.com/entry/NETWORK-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%B8%ED%94%BC%EB%8B%88%EB%B0%B4%EB%93%9C-%EC%9E%A5%EC%95%A0-%EC%B2%98%EB%A6%AC#entry226comment</comments>
<pubDate>Thu, 31 Oct 2024 12:00:12 +0900</pubDate>
</item>
<item>
<title>[Linux] MATE &amp; GNOME</title>
<link>https://estar987.com/entry/Linux-MATE-GNOME</link>
<description><p data-ke-size="size16">MATE 와 GNOME은 모두 Linux 환경에서 사용되는 데스크톱 환경입니다.&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">MATE</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>MATE는 GNOME2의 포크로, GNOME2의 클래식한 데스크톱 인터페이스를 유지하고 있습니다.&nbsp;</li> <li>GNOME3 으로 넘어가면서 변화된 UI와 UX에 불만이 있던 사용자들이 기존의 GNOME2 인터페이스를 계속 사용할 수 있도록 만들어졌습니다.</li> <li>가볍고 자원이 적게 소모되어, 저사양 시스템에서도 원활하게 동작합니다.</li> <li>전통적인 메뉴 시스템과 패널 기반의 사용성을 제공하며, UI가 비교적 직관적이고 익숙한 느낌을 줍니다.</li> </ul> <h3 data-ke-size="size23">GNOME</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>GNOME은 현재 버전 3 이상에서 매우 현대적이고 단순화된 인터페이스를 제공합니다.</li> <li>GNOME3 이후로는 새로운 방색의 UI 즉, GNOME 셸을 도입했으며, 기존의 전통적인 데스크톱 환경과는 다른 접근을 취하고 있습니다.</li> <li>확장 프로그램을 통해 기능을 확장할 수 있고, UI를 사용자에 맞게 커스터마이징할 수 있지만 기본적으로는 모던하고 최소화된 디자인을 지향합니다.</li> <li>최신 GNOME은 자원을 많이 소모할 수 있으며, 매우 시각적이고 애니메이션이 많은 인터페이스를 제공합니다.</li> </ul> <h3 data-ke-size="size23">startx VS ini 5</h3> <h4 data-ke-size="size20">startx</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>startx는 사용자가 직접 X 서버 (그래픽 서버)를 시작하는 명령입니다.</li> <li>일반적으로 텍스트 모드(콘솔)로 로그인한 후, 수동으로 X 윈도우 시스템을 시작하기 위해 사용됩니다.</li> <li>X 윈도우 시스템이 시작되면 기본적으로 설정된 데스크톱 환경 또는 윈도우 매니저가 실행됩니다.</li> <li>데스크톱 환경을 GUI로 변경하거나 여러 사용자 정의 설정을 할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">init 5</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>init 5는 시스템의 런레벨을 5로 변경하는 명령으로 이는 일반적으로 GUI 모드를 의미합니다.</li> <li>디부분의 linux 배포판에서 런레벨 5는 그래픽 로그인 모드를 활성화합니다.</li> <li>이 명령을 사용하면 텍스트 모드에서 시스템이 X 서버와 함께 데스크톱 환경으로 부팅되며, 디스플레이 매니저(GDM, LightDM 등)가 실해됩니다.</li> <li>이는 시스템 전반에 적용되며, 리부팅 이후에도 GUI 모드로 시작하게 됩니다.</li> </ul> <h4 data-ke-size="size20">주요 차이점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>startx 는 사용자가 직접 X 윈도우를 시작하는 데 사용되고, 텍스트 모드에서 한 번씩 실행해야 합니다.</li> <li>init 5는 시스템 런레벨을 변경해 시스템 전체를 GUI 모드로 전환하며, 재부팅해도 GUI 모드가 유지됩니다.</li> </ul> <p data-ke-size="size16">&nbsp;</p></description>
<category>Linux</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/225</guid>
<comments>https://estar987.com/entry/Linux-MATE-GNOME#entry225comment</comments>
<pubDate>Wed, 30 Oct 2024 12:00:50 +0900</pubDate>
</item>
<item>
<title>[Linux] 리눅스에서 디렉토리를 분할하여 압축하는 방법</title>
<link>https://estar987.com/entry/Linux-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EC%95%95%EC%B6%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95</link>
<description><h3 data-ke-size="size23">디렉토리 압축하기</h3> <pre id="code_1730000999072" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>tar -czvf v3.12.7.tar.gz v3.12.7/</code></pre> <h3 data-ke-size="size23">압축된 파일을 25MB 단위로 분할하기</h3> <pre id="code_1730001067423" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>split -b 25M v3.12.7.tar.gz v3.12.7.part.</code></pre> <h3 data-ke-size="size23">압축된 파일을 5개로 분할하기</h3> <pre id="code_1730001765043" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>split -n 5 v3.12.7.tar.gz v3.12.7.part.</code></pre> <h3 data-ke-size="size23">분할된 파일 복원 및 디렉토리 추출하기</h3> <pre id="code_1730001124021" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>cat v3.12.7.part.* &gt; v3.12.7.tar.gz tar -xzvf v3.12.7.tar.gz</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>Linux</category>
<category>Linux</category>
<category>Split</category>
<category>tar</category>
<category>리눅스</category>
<category>분할압축</category>
<category>압축</category>
<category>파일 묶기</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/224</guid>
<comments>https://estar987.com/entry/Linux-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EC%95%95%EC%B6%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95#entry224comment</comments>
<pubDate>Mon, 28 Oct 2024 12:00:02 +0900</pubDate>
</item>
<item>
<title>[Linux_Ubuntu24.04] Module 설정(CUDA 설치 후 module 설정)</title>
<link>https://estar987.com/entry/Linux-Module-%EC%84%A4%EC%A0%95CUDA-%EC%84%A4%EC%B9%98-%ED%9B%84-module-%EC%84%A4%EC%A0%95</link>
<description><h3 data-ke-size="size23">환경 모듈 설치</h3> <pre id="code_1729239043782" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo apt-get install environment-modules</code></pre> <h3 data-ke-size="size23">모듈 시스템 초기화</h3> <pre id="code_1729239055887" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>source /etc/profile.d/modules.sh</code></pre> <h3 data-ke-size="size23">environment module 설정파일</h3> <pre id="code_1729239069195" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code> mkdir /usr/share/modules/modulefiles/cuda cp /usr/share/modules/modulefiles/modules /usr/share/modules/modulefiles/cuda/cuda-12.4 vi /usr/share/modules/modulefiles/cuda/cuda-12.4 ---- #%Module ## modules modulefile module-whatis "cuda-12.4" prepend-path PATH /usr/local/cuda-12.4/bin prepend-path PATH /usr/local/cuda-12.4/lib64/:/usr/local/cuda-12.4/extras/CUPTI/lib64 # enable module versioning modulepath #module use /usr/share/modules/versions ----</code></pre> <h3 data-ke-size="size23">모듈 목록 확인</h3> <pre id="code_1729239081750" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># module avail ---------------------------------------------- /usr/share/modules/modulefiles ----------------------------------------------- cuda/cuda-12.4 dot module-git module-info modules null use.own Key: loaded modulepath</code></pre> <h3 data-ke-size="size23">모듈 로드</h3> <pre id="code_1729239093643" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>module load cuda/cuda-12.4</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>Linux</category>
<category>CentOS</category>
<category>CUDA</category>
<category>Linux</category>
<category>module</category>
<category>nvidia</category>
<category>rocky</category>
<category>ubuntu</category>
<category>리눅스</category>
<category>모듈</category>
<category>환경변수</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/223</guid>
<comments>https://estar987.com/entry/Linux-Module-%EC%84%A4%EC%A0%95CUDA-%EC%84%A4%EC%B9%98-%ED%9B%84-module-%EC%84%A4%EC%A0%95#entry223comment</comments>
<pubDate>Fri, 25 Oct 2024 12:00:11 +0900</pubDate>
</item>
<item>
<title>[Docker, NVIDIA] MIG 를 할당한 컨테이너 생성</title>
<link>https://estar987.com/entry/Docker-NVIDIA-MIG-%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1</link>
<description><h3 data-ke-size="size23">MIG 활성화하기</h3> <h4 data-ke-size="size20">활성화 전</h4> <pre id="code_1729215820150" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Fri Oct 18 10:04:07 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | 0 | | N/A 57C P0 57W / 350W | 0MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre> <h4 data-ke-size="size20">활성화</h4> <pre id="code_1729215862213" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -mig 1</code></pre> <h4 data-ke-size="size20">활성화 후</h4> <pre id="code_1729215885635" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Fri Oct 18 10:03:47 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | On | | N/A 58C P0 88W / 350W | 0MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | No MIG devices found | +-----------------------------------------------------------------------------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre> <h4 data-ke-size="size20">GPU 리셋(활성 / 비활성 시 gpu 리셋)</h4> <pre id="code_1729215949918" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>nvidia-smi --gpu-reset</code></pre> <h3 data-ke-size="size23">GI 생성 후 GI 조회</h3> <pre id="code_1729215978763" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -cgi 19 Successfully created GPU instance ID 13 on GPU 0 using profile MIG 1g.10gb (ID 19) # nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 0 MIG 1g.10gb 19 13 6:1 | +-------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">CI 생성 후 CI 조회</h3> <pre id="code_1729216000589" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -cci -gi 13 Successfully created compute instance ID 0 on GPU 0 GPU instance ID 13 using profile MIG 1g.10gb (ID 0) # nvidia-smi mig -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 0 13 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">MIG 생성 확인</h3> <pre id="code_1729216017024" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Fri Oct 18 10:10:55 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | On | | N/A 54C P0 55W / 350W | 12MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 0 13 0 0 | 12MiB / 9984MiB | 14 0 | 1 0 1 0 1 | | | 0MiB / 16383MiB | | | +------------------+----------------------------------+-----------+-----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre> <h4 data-ke-size="size20">MIG 의 UUID 확인</h4> <pre id="code_1729216031908" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -L GPU 0: NVIDIA H100 PCIe (UUID: GPU-c48bbfa5-9a67-255a-a6a3-8fecf44951b4) MIG 1g.10gb Device 0: (UUID: MIG-d56fa0ad-7e21-56d6-aee3-fa508d0e6fc9)</code></pre> <h3 data-ke-size="size23">도커 실행</h3> <pre id="code_1729216069561" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run --gpus '"device=MIG-d56fa0ad-7e21-56d6-aee3-fa508d0e6fc9"' -it --rm tensorflow/tensorflow:latest-gpu ________ _______________ ___ __/__________________________________ ____/__ /________ __ __ / _ _ \_ __ \_ ___/ __ \_ ___/_ /_ __ /_ __ \_ | /| / / _ / / __/ / / /(__ )/ /_/ / / _ __/ _ / / /_/ /_ |/ |/ / /_/ \___//_/ /_//____/ \____//_/ /_/ /_/ \____/____/|__/ WARNING: You are running this container as root, which can cause new files in mounted volumes to be created as the root user on your host machine. To avoid this, run the container by specifying your user's userid: $ docker run -u $(id -u):$(id -g) args... root@fc4dbfe09ff8:/# nvidia-smi Fri Oct 18 01:28:02 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | On | | N/A 53C P0 54W / 350W | N/A | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 0 13 0 0 | 12MiB / 9984MiB | 14 0 | 1 0 1 0 1 | | | 0MiB / 16383MiB | | | +------------------+----------------------------------+-----------+-----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre></description>
<category>Docker</category>
<category>AI</category>
<category>docker</category>
<category>H100</category>
<category>Linux</category>
<category>MIG</category>
<category>nvidia</category>
<category>도커</category>
<category>엔비디아</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/222</guid>
<comments>https://estar987.com/entry/Docker-NVIDIA-MIG-%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1#entry222comment</comments>
<pubDate>Thu, 24 Oct 2024 12:00:21 +0900</pubDate>
</item>
<item>
<title>[Docker] GPU 컨테이너 생성</title>
<link>https://estar987.com/entry/GPU-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1</link>
<description><h3 data-ke-size="size23">일반 도커 생성 시 gpu 명령(nvidia-smi) 사용 불가 확인</h3> <pre id="code_1729212202680" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run -it --rm ubuntu:latest root@27325dccffa0:/# nvidia-smi bash: nvidia-smi: command not found</code></pre> <h4 data-ke-size="size20">docker run 할 때 --gpu 옵션으로 도커 컨테이너에 gpu 할당</h4> <pre id="code_1729212217338" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run --gpus all -it --rm ubuntu root@95e0b226698f:/# nvidia-smi Fri Oct 18 00:38:36 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | On | | N/A 56C P0 56W / 350W | 13MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | No MIG devices found | +-----------------------------------------------------------------------------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| +-----------------------------------------------------------------------------------------+</code></pre> <pre id="code_1729212225934" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run --gpus all -it --rm tensorflow/tensorflow:latest-gpu ________ _______________ ___ __/__________________________________ ____/__ /________ __ __ / _ _ \_ __ \_ ___/ __ \_ ___/_ /_ __ /_ __ \_ | /| / / _ / / __/ / / /(__ )/ /_/ / / _ __/ _ / / /_/ /_ |/ |/ / /_/ \___//_/ /_//____/ \____//_/ /_/ /_/ \____/____/|__/ WARNING: You are running this container as root, which can cause new files in mounted volumes to be created as the root user on your host machine. To avoid this, run the container by specifying your user's userid: $ docker run -u $(id -u):$(id -g) args... root@f093e355de6d:/# nvidia-smi Fri Oct 18 00:36:34 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | On | | N/A 56C P0 56W / 350W | 13MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | No MIG devices found | +-----------------------------------------------------------------------------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| +-----------------------------------------------------------------------------------------+</code></pre></description>
<category>Docker</category>
<category>docker</category>
<category>GPU</category>
<category>MIG</category>
<category>nvidia</category>
<category>ubuntu</category>
<category>도커</category>
<category>리눅스</category>
<category>엔비디아</category>
<category>우분투</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/221</guid>
<comments>https://estar987.com/entry/GPU-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1#entry221comment</comments>
<pubDate>Wed, 23 Oct 2024 12:00:45 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] Cuda Toolkit 설치</title>
<link>https://estar987.com/entry/Nvidia-Cuda-Toolkit-%EC%84%A4%EC%B9%98</link>
<description><pre id="code_1729149864945" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Thu Oct 17 16:23:44 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.54.14 Driver Version: 550.54.14 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 PCIe Off | 00000000:B8:00.0 Off | 0 | | N/A 56C P0 56W / 350W | 13MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | 0 N/A N/A 3049 G /usr/lib/xorg/Xorg 4MiB | +-----------------------------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">설치 파일 다운로드</h3> <p data-ke-size="size16"><a href="https://developer.nvidia.com/downloads" target="_blank" rel="noopener&nbsp;noreferrer">https://developer.nvidia.com/downloads</a></p> <figure id="og_1729149919360" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="Developer Download Centers" data-og-description="Download toolkits, SDKs, and more for faster development and deployment." data-og-host="developer.nvidia.com" data-og-source-url="https://developer.nvidia.com/downloads" data-og-url="https://developer.nvidia.com/downloads" data-og-image="https://scrap.kakaocdn.net/dn/b7Sf6W/hyXhRZkuuk/Sr0aPyiLqdW7ko9RKWoMG1/img.png?width=630&amp;height=354&amp;face=0_0_630_354,https://scrap.kakaocdn.net/dn/bm4otP/hyXlVsdo9G/8T678KzlTPnRzb5Tm8zxF0/img.png?width=630&amp;height=354&amp;face=0_0_630_354,https://scrap.kakaocdn.net/dn/ktJXg/hyXhOBvPvw/DVZV9Aw3dAUxWzpUevOd91/img.png?width=630&amp;height=354&amp;face=0_0_630_354"><a href="https://developer.nvidia.com/downloads" target="_blank" rel="noopener" data-source-url="https://developer.nvidia.com/downloads"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/b7Sf6W/hyXhRZkuuk/Sr0aPyiLqdW7ko9RKWoMG1/img.png?width=630&amp;height=354&amp;face=0_0_630_354,https://scrap.kakaocdn.net/dn/bm4otP/hyXlVsdo9G/8T678KzlTPnRzb5Tm8zxF0/img.png?width=630&amp;height=354&amp;face=0_0_630_354,https://scrap.kakaocdn.net/dn/ktJXg/hyXhOBvPvw/DVZV9Aw3dAUxWzpUevOd91/img.png?width=630&amp;height=354&amp;face=0_0_630_354');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">Developer Download Centers</p> <p class="og-desc" data-ke-size="size16">Download toolkits, SDKs, and more for faster development and deployment.</p> <p class="og-host" data-ke-size="size16">developer.nvidia.com</p> </div> </a></figure> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1115" data-origin-height="418"><span data-url="https://blog.kakaocdn.net/dn/5SnPP/btsKauhBLZ1/OMreH9MV1f2rhnYyIB4gK1/img.png" data-phocus="https://blog.kakaocdn.net/dn/5SnPP/btsKauhBLZ1/OMreH9MV1f2rhnYyIB4gK1/img.png"><img src="https://blog.kakaocdn.net/dn/5SnPP/btsKauhBLZ1/OMreH9MV1f2rhnYyIB4gK1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5SnPP%2FbtsKauhBLZ1%2FOMreH9MV1f2rhnYyIB4gK1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1115" data-origin-height="418"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <pre id="code_1729150136845" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>./cuda_12.6.2_560.35.03_linux.run --toolkit --samples --silent</code></pre> <h3 data-ke-size="size23">설치 확인</h3> <pre id="code_1729150237003" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH # nvcc -V nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2024 NVIDIA Corporation Built on Thu_Sep_12_02:18:05_PDT_2024 Cuda compilation tools, release 12.6, V12.6.77 Build cuda_12.6.r12.6/compiler.34841621_0</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>NVIDIA</category>
<category>CUDA</category>
<category>H100</category>
<category>Linux</category>
<category>nvidia</category>
<category>nvidia-smi</category>
<category>toolkit</category>
<category>ubuntu</category>
<category>엔비디아</category>
<category>인공지능</category>
<category>파이썬</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/220</guid>
<comments>https://estar987.com/entry/Nvidia-Cuda-Toolkit-%EC%84%A4%EC%B9%98#entry220comment</comments>
<pubDate>Tue, 22 Oct 2024 12:00:13 +0900</pubDate>
</item>
<item>
<title>[Kubernetes] 클러스터 구성 중 접한 ERR</title>
<link>https://estar987.com/entry/Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%84%B1-%EC%A4%91-%EC%A0%91%ED%95%9C-ERR</link>
<description><h3 data-ke-size="size23">ERR</h3> <pre id="code_1729132661290" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubeadm init --pod-network-cidr=10.96.0.0/12 --apiserver-advertise-address=192.168.207.231 I1017 11:20:16.467463 4146 version.go:256] remote version is much newer: v1.31.1; falling back to: stable-1.28 [init] Using Kubernetes version: v1.28.14 [preflight] Running pre-flight checks [WARNING FileExisting-socat]: socat not found in system path error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables does not exist [preflight] If you know what you are doing, you can make a check non-fatal with --ignore-preflight-errors=... To see the stack trace of this error execute with --v=5 or higher # kubeadm version kubeadm version: &amp;version.Info{Major:"1", Minor:"28", GitVersion:"v1.28.14", GitCommit:"66f3325d5562da565def802b8bacf431b082991d", GitTreeState:"clean", BuildDate:"2024-09-11T08:26:11Z", GoVersion:"go1.22.6", Compiler:"gc", Platform:"linux/amd64"}</code></pre> <h3 data-ke-size="size23">해결</h3> <p data-ke-size="size16">socat 설치</p> <pre id="code_1729132839680" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo apt-get install socat</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">이 문제는 br_netfilter 모듈이 로드되지 않아서 발생할 수 있습니다.</p> <pre id="code_1729132877537" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo modprobe br_netfilter echo '1' | sudo tee /proc/sys/net/bridge/bridge-nf-call-iptables echo '1' | sudo tee /proc/sys/net/bridge/bridge-nf-call-ip6tables</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">재부팅 후에도 이 설정이 유지되도록 /etc/sysctl.conf 파일에 다음 내용을 추가하세요</p> <pre id="code_1729132899192" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo echo 'net.bridge.bridge-nf-call-iptables = 1' &gt;&gt; /etc/sysctl.conf sudo echo 'net.bridge.bridge-nf-call-ip6tables = 1' &gt;&gt; /etc/sysctl.conf</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">적용</p> <pre id="code_1729132913885" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo sysctl -p</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">다시 키를 생성하면 제대로 생성됩니다.</p> <h3 data-ke-size="size23">키 생성후 클러스터 구성 확인</h3> <pre id="code_1729132993232" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubectl get no NAME STATUS ROLES AGE VERSION master NotReady control-plane 17m v1.28.14 node NotReady &lt;none&gt; 15m v1.28.14</code></pre></description>
<category>DevOps</category>
<category>cluster</category>
<category>kubeadm</category>
<category>kubectl</category>
<category>kubernetes</category>
<category>ubuntu</category>
<category>쿠버네티스</category>
<category>클러스터</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/219</guid>
<comments>https://estar987.com/entry/Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%84%B1-%EC%A4%91-%EC%A0%91%ED%95%9C-ERR#entry219comment</comments>
<pubDate>Mon, 21 Oct 2024 12:00:13 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] In use by another client(프로세스 충돌)</title>
<link>https://estar987.com/entry/NVIDIA-In-use-by-another-client%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%B6%A9%EB%8F%8C</link>
<description><h3 data-ke-size="size23">ERR 로그</h3> <pre id="code_1729067303732" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi --gpu-reset The following GPUs could not be reset: GPU 00000000:B8:00.0: In use by another client 1 device is currently being used by one or more other processes (e.g., Fabric Manager, CUDA application, graphics application such as an X server, or a monitoring application such as another instance of nvidia-smi). Please first kill all processes using this device and all compute applications running in the system. root@clunix:~# nvidia-smi -lgipp ERROR: Option -lgipp is not recognized. Please run 'nvidia-smi -h'. # nvidia-smi mig -lgipp GPU 0 Profile ID 19 Placements: {0,1,2,3,4,5,6}:1 GPU 0 Profile ID 20 Placements: {0,1,2,3,4,5,6}:1 GPU 0 Profile ID 15 Placements: {0,2,4,6}:2 GPU 0 Profile ID 14 Placements: {0,2,4}:2 GPU 0 Profile ID 9 Placements: {0,4}:4 GPU 0 Profile ID 5 Placement : {0}:4 GPU 0 Profile ID 0 Placement : {0}:8 # nvidia-smi mig -lgip +-----------------------------------------------------------------------------+ | GPU instance profiles: | | GPU Name ID Instances Memory P2P SM DEC ENC | | Free/Total GiB CE JPEG OFA | |=============================================================================| | 0 MIG 1g.10gb 19 7/7 9.75 No 14 1 0 | | 1 1 0 | +-----------------------------------------------------------------------------+ | 0 MIG 1g.10gb+me 20 1/1 9.75 No 14 1 0 | | 1 1 1 | +-----------------------------------------------------------------------------+ | 0 MIG 1g.20gb 15 4/4 19.62 No 14 1 0 | | 1 1 0 | +-----------------------------------------------------------------------------+ | 0 MIG 2g.20gb 14 3/3 19.62 No 30 2 0 | | 2 2 0 | +-----------------------------------------------------------------------------+ | 0 MIG 3g.40gb 9 2/2 39.38 No 46 3 0 | | 3 3 0 | +-----------------------------------------------------------------------------+ | 0 MIG 4g.40gb 5 1/1 39.38 No 62 4 0 | | 4 4 0 | +-----------------------------------------------------------------------------+ | 0 MIG 7g.80gb 0 1/1 79.12 No 114 7 0 | | 8 7 1 | +-----------------------------------------------------------------------------+ # nvidia-smi mig -cgi 19 Unable to create a GPU instance on GPU 0 using profile 19: In use by another client Failed to create GPU instances: In use by another client</code></pre> <h3 data-ke-size="size23">해결</h3> <p data-ke-size="size16">CUDA 드라이버를 설치하고 ~/.bashrc 에 자동으로 환경변수를 잡도록 설정하여서 프로세스 충돌 오류가 발생하였다.&nbsp;</p> <pre id="code_1729068538258" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -cgi 19 Successfully created GPU instance ID 13 on GPU 0 using profile MIG 1g.10gb (ID 19)</code></pre></description>
<category>NVIDIA</category>
<category>Linux</category>
<category>MIG</category>
<category>nvidia</category>
<category>rockylinux</category>
<category>ubuntu</category>
<category>그래픽카드</category>
<category>환경변수</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/218</guid>
<comments>https://estar987.com/entry/NVIDIA-In-use-by-another-client%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%B6%A9%EB%8F%8C#entry218comment</comments>
<pubDate>Fri, 18 Oct 2024 12:00:09 +0900</pubDate>
</item>
<item>
<title>DevOps 관점에서 VM 생성 및 Kubernetes 클러스터 구축 자동화</title>
<link>https://estar987.com/entry/DevOps-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-VM-%EC%83%9D%EC%84%B1-%EB%B0%8F-Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%B6%95-%EC%9E%90%EB%8F%99%ED%99%94</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">DevOps는 개발(Development)과 <span data-token-index="1">운영(Operations)</span> 간의 협업을 통해 소프트웨어의 배포 및 인프라 관리 자동화를 달성하는 데 중점을 둡니다. 이를 위해 다양한 도구와 스크립트를 사용하여 가상화 환경을 구축하고, 어플리케이션의 확장성과 유연성을 보장하는 <span data-token-index="3">Kubernetes</span> 클러스터를 자동화하는 작업이 핵심입니다. 이 글에서는 <span data-token-index="5">Vagrant, Ansible, Python, Bash, PowerShell, ESXi 명령어</span>와 같은 다양한 도구를 사용하여 가상 머신을 자동으로 생성하고, 생성된 VM들에 Kubernetes 클러스터를 구축하는 DevOps 파이프라인을 설계하는 방법을 설명합니다.</p> <h3 data-ke-size="size23">1. 가상 머신 생성 도구의 비교와 DevOps 활용 방안</h3> <h4 data-ke-size="size20">Vagrant &amp; Ansible(소~대규모)</h4> <p data-ke-size="size16"><span data-token-index="0">Vagrant</span>는 개발 환경의 생성 및 관리를 자동화하는 도구로, 간단히 여러 가상 머신을 생성할 수 있습니다. <span data-token-index="2">Ansible</span>은 생성된 가상 머신의 소프트웨어 설치와 구성 관리를 자동으로 처리하는 구성 관리 도구입니다.</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0">DevOps 활용 방안</span>: Vagrant는 일관된 개발 및 테스트 환경을 구축하는 데 매우 유용하며, Ansible을 사용하면 VM에 필요한 모든 소프트웨어와 설정을 코드로 정의하여 자동화할 수 있습니다. 이를 통해 DevOps 파이프라인에서 안정적인 환경 배포와 관리가 가능합니다.</p> <h4 data-ke-size="size20">Python 스크립트 (중소 규모)</h4> <p data-ke-size="size16">Python은 VMware API와 통합하여 VM을 생성하거나 관리하는 유연한 스크립트를 작성할 수 있습니다. 라이브러리, 예를 들어 <span data-token-index="1">pyVmomi</span>를 통해 ESXi와 상호작용할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0">DevOps 활용 방안</span>: Python은 복잡한 로직이나 특정 조건을 기반으로 한 VM 프로비저닝 작업에 적합합니다. 여러 클라우드 및 하이퍼바이저 API를 사용하여 유연한 통합이 가능하기 때문에 DevOps 파이프라인에서 맞춤형 자동화를 구현할 때 유리합니다.</p> <h4 data-ke-size="size20">Bash 및 PowerShell 스크립트(중소 규모)</h4> <p data-ke-size="size16"><span data-token-index="0">Bash</span>는 주로 리눅스 환경에서 사용되며, <span data-token-index="2">PowerShell</span>은 윈도우 환경에서 주로 사용됩니다. 두 스크립팅 언어는 각각의 운영 체제에서 자동화를 수행할 수 있는 강력한 도구입니다.</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0">DevOps 활용 방안</span>: Bash는 리눅스 서버의 프로비저닝에 유리하며, <span data-token-index="2">govc</span> 같은 도구와 함께 사용하여 VMware 관리 작업을 스크립트로 작성할 수 있습니다. PowerShell은 Windows 기반 인프라에서 유용하며, VMware와 연동 시 <span data-token-index="4">PowerCLI</span> 모듈을 사용하여 가상화 작업을 자동화할 수 있습니다.</p> <h4 data-ke-size="size20">ESXi 명령어 (ESXi Shell 또는 SSH)(소규모)</h4> <p data-ke-size="size16">ESXi 호스트의 셸에 직접 접근하여 명령어를 실행하는 방식으로, 기본적인 VM 관리와 설정을 수행할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><span data-token-index="0">DevOps 활용 방안</span>: ESXi 명령어는 호스트 수준에서 직접 제어를 하기에 효율적입니다. 다만 대규모 환경에서는 자동화 및 관리 측면에서 Bash 스크립트와 같은 다른 도구와 결합하여 사용하는 것이 더 효율적입니다.</p> <h3 data-ke-size="size23">2. 가상 머신 생성 및 Kubernetes 클러스터 구축의 전체적인 흐름</h3> <p data-ke-size="size16">여기에서는 VM 생성에서 Kubernetes 클러스터 구축까지의 DevOps 관점에서의 자동화 과정을 단계별로 설명합니다.</p> <h4 data-ke-size="size20">1단계: VM 생성 자동화</h4> <p data-ke-size="size16">가상 머신을 생성하기 위한 첫 번째 단계는 VM 프로비저닝을 자동화하는 것입니다. 이를 위해 사용할 수 있는 몇 가지 도구 조합이 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Vagrant &amp; Ansible: Vagrant로 VM을 생성하고, Ansible을 사용해 각 VM에 Kubernetes 설치에 필요한 초기 설정을 적용합니다. 이 과정에서는 Docker 설치, 네트워크 설정 등 Kubernetes 클러스터를 구축하는 데 필요한 모든 사전 조건을 설정합니다.</li> <li><span data-token-index="0">Python 스크립트</span>: Python과 pyVmomi 라이브러리를 사용해 vCenter 또는 ESXi와 상호작용하여 가상 머신을 생성합니다. Python은 이 과정에서 사용자 정의 요구 사항에 맞춘 프로비저닝 작업을 자동으로 수행할 수 있습니다.</li> <li><span data-token-index="0">Bash 또는 PowerShell 스크립트</span>: 간단한 프로비저닝이라면 Bash 스크립트 또는 PowerShell 스크립트를 사용하여 ESXi에서 직접 가상 머신을 생성할 수도 있습니다. 이러한 방법은 소규모 환경에서 매우 효율적입니다.</li> </ul> <h4 data-ke-size="size20">2단계: Kubernetes 클러스터 구성 자동화</h4> <p data-ke-size="size16">VM이 준비되면 다음 단계는 각 VM에 Kubernetes 클러스터를 구축하는 것입니다. 이 과정 역시 DevOps 관점에서 자동화가 가능합니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><span data-token-index="0">Ansible을 사용한 클러스터 구성</span>: Ansible Playbook을 작성하여 VM들에 Kubernetes를 설치하고 설정합니다. 이 과정에는 <span data-token-index="2">마스터 노드와 워커 노드를 구성</span>하고, 쿠버네티스 네트워크 플러그인(CNI)을 설치하며, 클러스터 토폴로지를 설정하는 작업이 포함됩니다.</li> <li><span data-token-index="0">Bash 스크립트</span>: 각 VM에 Kubernetes 구성 요소 (kubeadm, kubelet, kubectl)를 설치하는 Bash 스크립트를 작성하여, 각 노드에서 <span style="color: #000000;" data-token-index="2">kubeadm init</span> 또는 <span style="color: #000000;" data-token-index="4">kubeadm join</span> 명령을 실행해 클러스터에 참여하도록 합니다.</li> </ul> <h4 data-ke-size="size20">3단계: 클러스터 검증 및 CI/CD 파이프라인 통합</h4> <p data-ke-size="size16">쿠버네티스 클러스터가 구축되면, DevOps 파이프라인의 마지막 단계로 클러스터가 정상적으로 작동하는지 검증하고, 클러스터를 CI/CD 파이프라인에 통합합니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><span data-token-index="0">kubectl 명령어를 사용한 검증</span>: 클러스터에 정상적으로 접근 가능한지, 모든 노드와 파드가 정상적으로 작동하는지 확인하기 위해 <span style="color: #000000;">kubectl get nodes, kubectl get pods -A</span> 등의 명령어를 사용합니다.</li> <li><span data-token-index="0">CI/CD 파이프라인 통합</span>: 클러스터가 정상적으로 작동하면, Jenkins와 같은 CI/CD 도구를 통해 애플리케이션을 클러스터에 배포합니다. 이 과정은 Ansible 또는 Kubernetes 배포 스크립트를 사용하여 자동으로 진행될 수 있습니다.</li> </ul> <h3 data-ke-size="size23">3. 도구 선택 및 권장 사용 사례</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><span data-token-index="0">작은 규모의 자동화</span>: 소규모 환경에서는 <span data-token-index="2">Bash 스크립트</span>와 <span data-token-index="4">ESXi 명령어</span>로 간단히 VM을 생성하고 Kubernetes를 설정할 수 있습니다. 복잡한 구성을 필요로 하지 않기 때문에 간단한 도구가 더 적합합니다.</li> <li><span data-token-index="0">중간 규모 환경</span>: <span data-token-index="2">Vagrant와 Ansible</span> 조합이 가장 효율적입니다. Vagrant로 일관된 VM 환경을 쉽게 만들고 Ansible로 이를 구성하여 Kubernetes 클러스터를 구축하는 것은 관리 용이성 측면에서 큰 이점을 제공합니다.</li> <li><span data-token-index="0">대규모 환경</span>: 대규모 환경에서는 <span data-token-index="2">Python 스크립트</span>와 <span data-token-index="4">Ansible</span>을 결합하는 방식이 유리합니다. Python은 가상 머신 생성과 초기 프로비저닝에 사용되고, Ansible은 Kubernetes 클러스터 설정과 지속적인 구성을 관리합니다. 클라우드 인프라와 연동하는 경우에도 Python을 사용한 맞춤형 자동화가 매우 강력한 선택입니다.</li> </ul> <h3 data-ke-size="size23">결론</h3> <p data-ke-size="size16">VM 생성 및 Kubernetes 클러스터 구축을 자동화하는 과정은 DevOps에서 매우 중요한 부분을 차지하며, 이를 통해 일관된 개발 환경과 안정적인 배포 파이프라인을 구성할 수 있습니다. <span data-token-index="1">Vagrant &amp; Ansible</span>, <span data-token-index="3">Python</span>, <span data-token-index="5">Bash</span>, <span data-token-index="7">PowerShell</span> 등의 도구를 활용하여 환경의 규모와 목적에 맞는 솔루션을 선택하는 것이 중요합니다. 이를 통해 DevOps 파이프라인의 자동화 수준을 높이고, 개발에서 운영까지의 과정을 빠르고 안정적으로 유지할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">앞으로 포스팅할 글들은 위의 내용을 토대로 자동화에 관련하여 포스팅을 이어가겠습니다.</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/217</guid>
<comments>https://estar987.com/entry/DevOps-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-VM-%EC%83%9D%EC%84%B1-%EB%B0%8F-Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%B6%95-%EC%9E%90%EB%8F%99%ED%99%94#entry217comment</comments>
<pubDate>Thu, 17 Oct 2024 12:00:15 +0900</pubDate>
</item>
<item>
<title>[Rocky linux8] Vagrant 구성하기</title>
<link>https://estar987.com/entry/Rocky-linux8-Vagrant-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">Vagrant는 개발 환경을 쉽게 생성하고 관리할 수 있도록 도와주는 오픈 소스 도구입니다. 이를 통해 동일한 개발 환경을 여러 개발자 간에 쉽게 공유할 수 있고, 운영체제, 소프트웨어 버전, 네트워크 설정 등을 손쉽게 가상 환경에서 설정할 수 있습니다. Vagrant는 주로 가상 머신(VM)이나 컨테이너를 관리하며, 개발자는 이를 통해 호스트 운영체제와 독립적인 환경에서 애플리케이션을 개발 및 테스트할 수 있습니다.</p> <h3 data-ke-size="size23">주요 기능</h3> <p data-ke-size="size16">Vagrant의 주요 기능은 다음과 같습니다:</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li><b>간편한 가상 환경 설정</b>: Vagrantfile이라는 설정 파일을 통해 필요한 가상 머신의 스펙(운영체제, 네트워크, 디스크 등)을 정의합니다.</li> <li><b>다양한 프로바이더 지원</b>: Vagrant는 VirtualBox, VMware, Docker와 같은 여러 가상화 도구를 지원하여, 다양한 환경에서 가상 머신을 관리할 수 있습니다.</li> <li><b>환경 공유</b>: Vagrant 환경을 공유하기 쉽게 해주므로, 개발자는 동일한 환경에서 작업하고 테스트할 수 있어 환경 불일치로 인한 문제를 줄일 수 있습니다.</li> <li><b>프로비저닝</b>: 쉘 스크립트나 Ansible, Puppet, Chef 같은 도구를 사용해 가상 머신이 생성될 때 필요한 소프트웨어를 자동으로 설치하고 설정할 수 있습니다.</li> </ol> <p data-ke-size="size16">Vagrant는 주로 개발자와 DevOps 엔지니어들이 개발 환경을 통일하고, 로컬에서 가상 머신을 쉽게 관리하기 위해 사용됩니다.</p> <h3 data-ke-size="size23">구성하기</h3> <h4 data-ke-size="size20">1. HashiCorp의 공식 저장소 추가하기</h4> <pre id="code_1728907139053" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo dnf install -y dnf-plugins-core sudo dnf config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo</code></pre> <h4 data-ke-size="size20">2. Vagrant 설치</h4> <pre id="code_1728907160464" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>sudo dnf install vagrant</code></pre> <h4 data-ke-size="size20">3. 설치 확인</h4> <pre id="code_1728907175946" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vagrant --version</code></pre> <h4 data-ke-size="size20">4. VMware ESXI 플러그인 설치</h4> <pre id="code_1728907193165" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vagrant plugin install vagrant-vmware-esxi</code></pre></description>
<category>DevOps</category>
<category>DevOps</category>
<category>Hashicorp</category>
<category>Linux</category>
<category>rockylinux</category>
<category>Vagrant</category>
<category>데봅스</category>
<category>데브옵스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/216</guid>
<comments>https://estar987.com/entry/Rocky-linux8-Vagrant-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0#entry216comment</comments>
<pubDate>Tue, 15 Oct 2024 12:00:23 +0900</pubDate>
</item>
<item>
<title>[Docker] Podman</title>
<link>https://estar987.com/entry/Docker-Podman</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">Podman은 컨테이너와 관련된 작업을 수행할 수 있는 컨테이너 엔진으로, Docker와 유사한 기능을 제공하지만 몇 가지 중요한 차이점이 있는 도구입니다. Podman은 주로 컨테이너를 생성, 관리, 배포할 수 있는 CLI(Command Line Interface)를 제공하며, 무거운 데몬 프로세스를 사용하지 않는 점에서 Docker와 구별됩니다.</p> <h3 data-ke-size="size23"><span data-token-index="0">Podman의 특징</span></h3> <h4 data-ke-size="size20">1. 무데몬 (Daemonless) 구조</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Docker와 달리 Podman은 별도의 데몬 프로세스를 필요로 하지 않습니다.</li> <li>Docker는 모든 컨테이너와 이미지를 관리하기 위해 중앙의 dockerd 데몬을 사용하지만, Podman은 각각의 컨테이너가 독립적인 프로세스로 실행되므로 시스템 리소스가 더 효율적으로 사용됩니다.</li> <li>무데몬 구조 덕분에 데몬 종료나 충돌로 인한 문제가 줄어들며, 보안 측면에서도 더 안전합니다.</li> </ul> <h4 data-ke-size="size20">2. Rootless 모드 지원</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Podman은 root 권한 없이도 컨테이너를 실행할 수 있는 <b>Rootless 모드</b>를 제공합니다.</li> <li>일반 사용자가 자신의 홈 디렉토리에서 컨테이너를 관리하고 실행할 수 있으므로 보안에 민감한 환경에서 안전하게 사용할 수 있습니다.</li> <li>Rootless 모드는 root 권한을 가진 사용자만이 컨테이너를 실행할 수 있는 Docker에 비해 강력한 보안 장점을 제공합니다.</li> </ul> <h4 data-ke-size="size20">3. Docker CLI 와 호환 가능</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Podman의 CLI 명령어는 Docker와 매우 유사합니다. 따라서 기존 Docker 사용자들이 쉽게 Podman으로 전환할 수 있습니다.</li> <li>예를 들어 podman run 명령어는 docker run 명령어와 동일한 방식으로 작동합니다.</li> <li>대부분의 Docker 명령어가 Podman에서도 동일하게 사용될 수 있어 학습 곡선이 낮습니다.</li> </ul> <h4 data-ke-size="size20">4. Kubernetes와의 연동</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Podman은 컨테이너를 관리할 뿐만 아니라, 컨테이너 그룹(포드)을 관리할 수 있는 기능도 제공합니다.</li> <li>Podman의 "pod" 개념은 Kubernetes의 Pod와 유사하며, Kubernetes 클러스터로 쉽게 이전할 수 있도록 YAML 형식으로 파일을 생성할 수 있습니다.</li> <li>podman generate kube 명령어를 사용하여 Kubernetes 매니페스트 파일을 생성하고, 이를 Kubernetes 클러스터에서 사용할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">5. Systemd 통합</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Podman은 Systemd와의 통합을 쉽게 지원합니다. podman generate systemd 명령어를 통해 컨테이너를 systemd 서비스로 변환할 수 있습니다.</li> <li>이를 통해 컨테이너를 Systemd 서비스를 이용해 관리하고, 부팅 시 자동으로 실행되도록 설정할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">6. 보안 및 호환성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Podman은 보안과 호환성 측면에서 강점을 가지고 있습니다.</li> <li>SELinux, AppArmor 등 Linux 커널 보안 기능을 지원하여 컨테이너의 보안을 강화할 수 있으며, 컨테이너별로 별도의 네임스페이스를 사용하므로 컨테이너 격리가 더욱 철저합니다.</li> <li>Docker Compose와의 호환성을 위해 podman-compose라는 툴도 제공하여, 기존 Docker Compose 파일을 사용할 수 있게 지원합니다.</li> </ul></description>
<category>Docker</category>
<category>DevOps</category>
<category>docker</category>
<category>kubernetes</category>
<category>Linux</category>
<category>POD</category>
<category>podman</category>
<category>리눅스</category>
<category>컨테이너</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/213</guid>
<comments>https://estar987.com/entry/Docker-Podman#entry213comment</comments>
<pubDate>Fri, 11 Oct 2024 12:00:51 +0900</pubDate>
</item>
<item>
<title>[DevOps] Nis lsync ldap AD 로밍 Cloudinit</title>
<link>https://estar987.com/entry/DevOps-Nis-lsync-ldap-AD-%EB%A1%9C%EB%B0%8D-Cloudinit</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">NIS, Lsync, LDAP, AD로밍, 그리고 Cloudinit은 모두 시스템 관리, 사용자 관리, 그리고 서버 초기화 및 설정과 관련된 기술로, 각기 다른 목적을 가지고 있지만 상호 보완적인 방식으로 사용할 수 있습니다. 이러한 기술들을 크게 세 가지로 묶어서 설명할 수 있습니다. (사용자 관리, 파일 및 데이터 동기화, 서버 초기화 및 구성)</p> <h3 data-ke-size="size23">1. 사용자 관리</h3> <p data-ke-size="size16">이 범주에 해당하는 기술은 NIS, LDAP, AD 로밍입니다. 이들은 모두 사용자 및 그룹 정보의 중앙 집중화 및 인증을 목표로 하고 있습니다.</p> <h4 data-ke-size="size20">NIS(Network Information Service)</h4> <p data-ke-size="size16">NIS는 주로 Unix/Linux 시스템에서 사용자 계정, 그룹, 호스트명, 메일 별칭 등의 정보를 중앙 서버에서 관리하고 이를 네트워크를 통해 클라이언트가 참조할 수 있게 해주는 서비스입니다.</p> <p data-ke-size="size16">다수의 서버가 있을 때 각 서버의 사용자 정보가 따로 관리되지 않고, 중앙에서 일괄적으로 관리함으로써 사용자 계정의 일관성을 유지할 수 있습니다.</p> <p data-ke-size="size16">주로 로컬 네트워크 내에서 사용되며, LDAP과 같은 최신 기술에 밀려 많이 사용도디지는 않지만, 여전히 기존 환경에서 사용될 수 있습니다.</p> <h4 data-ke-size="size20">LDAP(Lightweight Directory Access Protocol)</h4> <p data-ke-size="size16">LDAP는 계층 구조로 사용자, 그룹, 디바이스 등을 관리할 수 있는 디렉터리 서비스입니다.</p> <p data-ke-size="size16">사용자가 중앙 서버에 저장된 디렉터리 정보를 사용하여 인증 및 권한 관리를 수행합니다.</p> <p data-ke-size="size16">NIS보다 확장성이 뛰어나고, 보안 프로토콜을 지원하므로 현재 많이 사용되고 있습니다.</p> <p data-ke-size="size16">Active Directory, OpenLDAP, FreeIPA 등의 형태로 사용될 수 있으며, 다양한 서비스와의 연동이 용이합니다.</p> <h4 data-ke-size="size20">AD(Active Directory) 로밍 프로파일</h4> <p data-ke-size="size16">AD는 Microsoft에서 제공하는 디렉터리 서비스로, LDAP 기반의 프로토콜을 사용하지만, 좀 더 많은 기능(그룹 정책관리, 인증, 권한 관리)을 제공합니다.</p> <p data-ke-size="size16">AD 로밍은 사용자가 로그인할 때마다 사용자 프로필을 서버에서 다운로드하고, 로그아웃 할 때 다시 업로드하여 어디서든 동일한 환경을 사용할 수 있게 합니다.</p> <p data-ke-size="size16">로밍 프로파일은 보통 Windows 환경에서 사용되며, 사용자 설정 및 데이터를 중앙 서버에서 관리하여, 물리적 PC의 위치와 무관하게 동일한 환경을 제공하는 데 사용됩니다.</p> <h3 data-ke-size="size23">2. 파일 및 데이터 동기화</h3> <p data-ke-size="size16">여기서는 Lsync와 같은 파일 동기화 도구를 다룰 수 있습니다.</p> <h4 data-ke-size="size20">Lsync</h4> <p data-ke-size="size16">Lsync는 Linux 시스템 간 파일을 동기화하기 위해 사용되는 툴로, Rsync와 Inotify를 결합하여 실시간으로 파일을 동기화 할 수 있게 해줍니다.</p> <p data-ke-size="size16">사용자 계정 정보, 설정파일, 혹은 애플리케이션 데이터를 여러 서버 간 실시간으로 일관되게 유지하는 데 사용될 수 있습니다.</p> <p data-ke-size="size16">주로 웹 서버의 콘텐츠 파일 동기화, 데이터베이스 백업 파일 관리 등 파일 동기화가 중요한 환경에 사용됩니다.</p> <h3 data-ke-size="size23">3. 서버 초기화 및 구성</h3> <p data-ke-size="size16">Cloudinit은 클라우드 환경에서 서버 초기화와 관련된 기능을 제공합니다.</p> <h3 data-ke-size="size23">4. 통합 및 연관성</h3> <h4 data-ke-size="size20">1. 사용자 관리와 파일 동기화</h4> <p data-ke-size="size16">LDAP이나 AD에서 사용자 계정을 관리하면서, Lsync를 이용해 사용자 홈 디렉터리를 여러 서버 간 실시간 동기화할 수 있습니다.</p> <p data-ke-size="size16">이는 사용자가 여러 서버에서 동일한 계정으로 접근하더라도 항상 같은 파일 환경을 제공할 수 있게 해줍니다.</p> <h4 data-ke-size="size20">2. 사용자 관리와 서버 초기화</h4> <p data-ke-size="size16">Cloudinit을 사용해 새로운 서버를 초기화할 때, LDAP을 이용해 중앙 사용자 관리 서버와 연동하여 사용자 계정 정보를 가져올 수 있습니다.</p> <p data-ke-size="size16">LDAP/NIS 와 같은 사용자 관리 시스템을 통해 서버 초기화시 사용자 및 그룹 설정을 일관되게 유지할 수 있습니다.</p> <h4 data-ke-size="size20">3. 전체 통합</h4> <p data-ke-size="size16">AD 로밍을 설정하여 Windows 환경의 사용자들이 어디서든 동일한 환경을 유지할 수 있게 하면서, Linux 환경의 NIS / LDAP 과 연동하여 이질적인 환경을 관리할 수 있습니다.</p> <p data-ke-size="size16">이러한 방식으로 다양한 운영체제와 환경 간의 사용자 관리 및 동기화 문제를 해결할 수 있습니다.</p> <h3 data-ke-size="size23">결론</h3> <p data-ke-size="size16">즉, 이 기술들은 각자의 영역에서 사용자 관리, 파일 동기화, 초기화 설정을 담당하며, 시스템 관리자나 DevOps 엔지니어가 이러한 기능들을 조합하여 서버 환경을 구성하고 운영할 때 효과적으로 활용할 수 있습니다.</p></description>
<category>DevOps</category>
<category>AD</category>
<category>adds</category>
<category>cloud</category>
<category>cloudinit</category>
<category>LDAP</category>
<category>lsync</category>
<category>nis</category>
<category>rsync</category>
<category>Windows</category>
<category>서버</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/212</guid>
<comments>https://estar987.com/entry/DevOps-Nis-lsync-ldap-AD-%EB%A1%9C%EB%B0%8D-Cloudinit#entry212comment</comments>
<pubDate>Thu, 10 Oct 2024 12:00:19 +0900</pubDate>
</item>
<item>
<title>[Hardware] 실제 서버 마운트 풀 때 유의사항(참고)(lsof)</title>
<link>https://estar987.com/entry/Hardware-%EC%8B%A4%EC%A0%9C-%EC%84%9C%EB%B2%84-%EB%A7%88%EC%9A%B4%ED%8A%B8-%ED%92%80-%EB%95%8C-%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD%EC%B0%B8%EA%B3%A0lsof</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">하드웨어를 umount 할 때 umount: /mnt: target is busy. 이러한 메시지를 본 경험이 많을 것이다. 근데 터미널에서 모두 사용중이지 않을 것을 확인하였는데도 계속 이 메세지가 출력된다면 아래 방법을 시도해보는 것을 권장한다.</p> <p data-ke-size="size16">제대로 마운트를 풀지 않고 물리적으로 연결을 끊으면 파일이 깨지거나 다양한 오류가 발생할 수 있기에 주의해야한다.</p> <h3 data-ke-size="size23">현재 상태</h3> <pre id="code_1728262423688" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># df df: /run/user/0/gvfs: Transport endpoint is not connected df: /run/user/0/gvfs: Transport endpoint is not connected Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 8043280 0 8043280 0% /dev tmpfs 8062324 0 8062324 0% /dev/shm tmpfs 8062324 157488 7904836 2% /run tmpfs 8062324 0 8062324 0% /sys/fs/cgroup /dev/sda2 2850099728 764257884 1940990032 29% / tmpfs 1612464 60 1612404 1% /run/user/0 /dev/sdd1 29412236 18260180 9632648 66% /mnt # df -Th df: /run/user/0/gvfs: Transport endpoint is not connected df: /run/user/0/gvfs: Transport endpoint is not connected Filesystem Type Size Used Avail Use% Mounted on devtmpfs devtmpfs 7.7G 0 7.7G 0% /dev tmpfs tmpfs 7.7G 0 7.7G 0% /dev/shm tmpfs tmpfs 7.7G 154M 7.6G 2% /run tmpfs tmpfs 7.7G 0 7.7G 0% /sys/fs/cgroup /dev/sda2 ext4 2.7T 729G 1.9T 29% / tmpfs tmpfs 1.6G 60K 1.6G 1% /run/user/0 /dev/sdd1 ext4 29G 18G 9.2G 66% /mnt # umount /mnt umount: /mnt: target is busy.</code></pre> <h3 data-ke-size="size23">lsof 명령어(확인)</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><span style="color: #333333; text-align: start;"><span>&nbsp;</span>lisf open files의 약자로, 열려진 파일들을 보는 명령어이다.</span></li> <li><span style="color: #333333; text-align: start;">프로세스 종료한다.</span></li> </ul> <pre id="code_1728262443939" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># lsof /mnt lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/0/gvfs Output information may be incomplete. lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/0/gvfs Output information may be incomplete. COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME bash 1388788 root cwd DIR 8,49 4096 2 /mnt bash 1427722 root cwd DIR 8,49 4096 2 /mnt # kill -9 1388788 # kill -9 1427722</code></pre> <h3 data-ke-size="size23">재확인</h3> <pre id="code_1728262520179" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># lsof /mnt lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/0/gvfs Output information may be incomplete. lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/0/gvfs Output information may be incomplete.</code></pre> <h3 data-ke-size="size23">Umount</h3> <pre id="code_1728262536818" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># umount /mnt # df df: /run/user/0/gvfs: Transport endpoint is not connected df: /run/user/0/gvfs: Transport endpoint is not connected Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 8043280 0 8043280 0% /dev tmpfs 8062324 0 8062324 0% /dev/shm tmpfs 8062324 157468 7904856 2% /run tmpfs 8062324 0 8062324 0% /sys/fs/cgroup /dev/sda2 2850099728 764257928 1940989988 29% / tmpfs 1612464 60 1612404 1% /run/user/0</code></pre></description>
<category>Hardware</category>
<category>Kill</category>
<category>lsof</category>
<category>mount</category>
<category>Process</category>
<category>PS</category>
<category>umount</category>
<category>리눅스</category>
<category>마운트</category>
<category>서버</category>
<category>프로세스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/211</guid>
<comments>https://estar987.com/entry/Hardware-%EC%8B%A4%EC%A0%9C-%EC%84%9C%EB%B2%84-%EB%A7%88%EC%9A%B4%ED%8A%B8-%ED%92%80-%EB%95%8C-%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD%EC%B0%B8%EA%B3%A0lsof#entry211comment</comments>
<pubDate>Tue, 8 Oct 2024 12:00:10 +0900</pubDate>
</item>
<item>
<title>[Linux]Cgroup</title>
<link>https://estar987.com/entry/Cgroup</link>
<description><h2 data-ke-size="size26">Cgroup 이란?</h2> <p data-ke-size="size16">Cgroup(Control Group)은 프로세스들이 사용하는 시스템 자원의 사용 정보를 수집하고, 이를 제한할 수 있도록 해주는 리눅스 커널 기술입니다. 이를 통해 특정 프로세스 그룹의 CPU, 메모리, 네트워크, 디스크 I/O와 같은 리소스 사용량을 제어하고 관리할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Cgroup의 주요 기능</h3> <h4 data-ke-size="size20">1. 자원 제한</h4> <p data-ke-size="size16">cgroups를 사용하면 관리자는 프로세스 그룹이 사용할 수 있는 자원 양을 제한할 수 있습니다. 여기에는 CPU 사용량, 메모리, 블록 장치 I/O 등이 포함됩니다. 이러한 경계를 설정함으로써 시스템 리소스의 남용을 방지할 수 있습니다</p> <h4 data-ke-size="size20">2. 우선순위 지정</h4> <p data-ke-size="size16">자원 제한과는 다르게, 우선순위 지정을 통해 특정 프로세스가 다른 프로세스보다 더 많은 시스템 시간을 갖도록 할 수 있습니다. 이를 통해 중요한 작업이 원활히 수행될 수 있습니다</p> <h4 data-ke-size="size20">3. 회계 처리</h4> <p data-ke-size="size16">cgroups는 어떤 프로세스가 어떤 자원을 얼마나 사용하고 있는지 추적할 수 있습니다. 이는 주로 성능 모니터링과 자원 사용의 투명성을 제공하기 위해 사용됩니다</p> <h4 data-ke-size="size20">4. 프로세스 제어</h4> <p data-ke-size="size16">cgroups의 freezer 기능을 통해 특정 프로세스의 스냅샷을 찍고 이동시킬 수 있습니다. 이는 프로세스 관리와 마이그레이션에 유용합니다</p> <h3 data-ke-size="size23">Cgroup의 구조</h3> <p data-ke-size="size16">cgroups는 계층적으로 구성되어 있으며, 각 자원 컨트롤러는 트리 구조를 가집니다. 각 트리의 브랜치나 리프는 자체적인 가중치나 제한을 가질 수 있습니다. 이로 인해 자원 사용을 세밀하게 조정할 수 있습니다</p> <h4 data-ke-size="size20">주요 서브 시스템</h4> <p data-ke-size="size16">Cgroup은 자원별로 다양한 서브 시스템을 통해 자원을 관리하고 제어합니다. 대표적으로 다음과 같은 서브 시스템이 있습니다</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>cpu: CPU 사용량을 제한하거나 특정 프로세스 그룹이 사용할 수 있는 CPU 자원을 할당합니다.</li> <li>memory: 메모리 사용량을 제한하고 메모리 누수 등을 방지할 수 있습니다.</li> <li>cpuacct: CPU 사용량을 계정 단위로 수집하여 보고합니다.</li> <li>blkio: 블록 장치(예: HDD, SSD)의 I/O 속도를 제어합니다.</li> <li>devices: 특정 프로세스 그룹이 사용할 수 있는 디바이스(예: 특정 디스크나 네트워크 장치)를 제한합니다.</li> <li>freezer: 프로세스 그룹을 일시적으로 정지하거나 재개할 수 있습니다.</li> <li>net_cls: 네트워크 트래픽을 특정 클래스(Class)로 구분하여 QoS (Quality of Service)를 적용할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">활용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>컨테이너 관리: Docker, runc, LXC와 같은 컨테이너 기술은 Cgroup을 이용하여 컨테이너별 리소스 사용량을 제어합니다.</li> <li>클러스터 관리: YARN(Hadoop)과 같은 클러스터 리소스 관리 시스템도 Cgroup을 사용하여 리소스를 효율적으로 관리합니다.</li> <li>모바일 OS: Android에서도 애플리케이션 간 리소스 관리에 Cgroup이 사용됩니다.</li> <li>가상화 환경: 리소스를 분리하여 특정 가상 머신이나 애플리케이션이 과도한 자원을 점유하지 못하게 할 수 있습니다.</li> </ul> <h3 data-ke-size="size23">Cgroup 종류</h3> <h4 data-ke-size="size20">Cgroups V1</h4> <p data-ke-size="size16">cgroups의 초기 버전인 V1은 각 자원 컨트롤러가 독립적으로 작동하는 구조입니다. 이는 다양한 컨트롤러가 각각 별도의 트리 구조를 가지며, 이를 통해 프로세스 그룹의 자원 사용을 관리합니다 control 대상이 되는 리소스들을 기준으로 control 구룹들을 나눔</p> <h4 data-ke-size="size20">Cgroups V2</h4> <p data-ke-size="size16">V2는 단일 계층 구조를 도입하여 자원 관리의 명확성과 효율성을 높였습니다. V2에서는 프로세스가 계층의 리프 노드에만 할당될 수 있으며, 모든 프로세스의 스레드는 동일한 cgroup에 있어야 합니다. 이는 자원 공유를 명확히 하고, 관리의 복잡성을 줄여줍니다 control 대상이 되는 워크 로드들을 기준으로 control 구룹들을 나눔</p> <h3 data-ke-size="size23">시스템에서 Cgroups 사용하기</h3> <h4 data-ke-size="size20">1. 컨트롤러 마운트</h4> <p data-ke-size="size16">/etc/cgconfig.conf 파일을 생성하고, 파일 시스템의 마운트 포인트를 설정합니다. 예를 들어, cpu 컨트롤러를 /dev/cgroups/cpu에 마운트할 수 있습니다</p> <h4 data-ke-size="size20">2. 그룹 생성</h4> <p data-ke-size="size16">자원 사용 매개변수를 정의하는 그룹을 생성합니다. 예를 들어, virtual이라는 그룹을 생성하여 블록 장치 I/O에 대한 접근을 제한할 수 있습니다</p> <h3 data-ke-size="size23">Cgroups와 같이 쓰면 좋은 도구</h3> <h4 data-ke-size="size20">1. Systemd와 Cgroup</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>서비스별 자원 제한 설정</li> <li>서비스의 자원 사용 모니터링</li> <li>부하 분산 및 성능 최적화</li> <li>시스템 부팅 및 서비스 시작/중지 관리</li> </ul> <h4 data-ke-size="size20">2. Kubernetes와 Cgroup</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>컨테이너의 CPU, 메모리</li> <li>디스크 I/O 제한 리소스 쿼터 설정 및 모니터링</li> <li>자동화된 확장 및 자원 할당</li> </ul> <h4 data-ke-size="size20">3. Docker와 Cgroups</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>컨테이너의 자원 제한 설정</li> <li>컨테이너 간 자원 격리</li> <li>성능 모니터링 및 튜닝</li> </ul> <h4 data-ke-size="size20">4. 그외</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>자원 할당 및 격리 목적으로 가상화 환경에서 사용됨</li> <li>보안 강화 목적으로 특정 프로세스의 자원 접근 제어에 사용됨</li> <li>성능 모니터링 및 튜닝 목적으로 실시간 자원 사용 모니터링에서 사용됨(ex, Prometheus, Grafana)</li> <li>HPC 클러스터에서 작업 분배 및 자원 관리 목적으로 사용됨</li> <li>데스크톱 환경에서 사용자 프로세스 자원 제한을 목적으로 사용됨</li> </ul></description>
<category>Linux</category>
<category>cgoup</category>
<category>docker</category>
<category>HPC</category>
<category>kubernetes</category>
<category>Linux</category>
<category>user</category>
<category>권한</category>
<category>자원</category>
<category>정책</category>
<category>제한</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/210</guid>
<comments>https://estar987.com/entry/Cgroup#entry210comment</comments>
<pubDate>Mon, 7 Oct 2024 12:00:59 +0900</pubDate>
</item>
<item>
<title>[Rocky linux 8] IPXE</title>
<link>https://estar987.com/entry/Rocky-linux-8-IPXE</link>
<description><h3 data-ke-size="size23">0. 참고&nbsp;</h3> <p data-ke-size="size16"><a href="https://estar987.tistory.com/61" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/61</a></p> <figure id="og_1727674064875" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="KickStart / PXE 기본 설치(NFS)" data-og-description="DHCP 서버 # yum -y install dhcp-server 혹은 # dnf install dhcp-server DHCP 서버 설정 파일 Legacy(BIOS) 모드 에서는 pxelinux.0 파일 사용 UEFI 모드에서는 grubx64.efi 사용 아이피 대역대에 따라서 ip 수 # vi /etc/dhcp/dhcp.c" data-og-host="estar987.com" data-og-source-url="https://estar987.tistory.com/61" data-og-url="https://estar987.com/61" data-og-image=""><a href="https://estar987.tistory.com/61" target="_blank" rel="noopener" data-source-url="https://estar987.tistory.com/61"> <div class="og-image" style="background-image: url();">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">KickStart / PXE 기본 설치(NFS)</p> <p class="og-desc" data-ke-size="size16">DHCP 서버 # yum -y install dhcp-server 혹은 # dnf install dhcp-server DHCP 서버 설정 파일 Legacy(BIOS) 모드 에서는 pxelinux.0 파일 사용 UEFI 모드에서는 grubx64.efi 사용 아이피 대역대에 따라서 ip 수 # vi /etc/dhcp/dhcp.c</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <h3 data-ke-size="size23">1. requirement</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>HTTP</li> <li>TFTP</li> <li>DHCP</li> </ul> <h3 data-ke-size="size23">2. Installation</h3> <h4 data-ke-size="size20">2-1 httpd : web서비스 설치 후 동작 Test</h4> <pre id="code_1727673312011" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>yum install httpd echo "Works" &gt; /var/www/html/index.html systemctl enable httpd systemctl start httpd</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="445" data-origin-height="92"><span data-url="https://blog.kakaocdn.net/dn/Az7n8/btsJQnR6i9K/FeO3ZeNvmyQVFMYSmRE7T0/img.png" data-phocus="https://blog.kakaocdn.net/dn/Az7n8/btsJQnR6i9K/FeO3ZeNvmyQVFMYSmRE7T0/img.png"><img src="https://blog.kakaocdn.net/dn/Az7n8/btsJQnR6i9K/FeO3ZeNvmyQVFMYSmRE7T0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAz7n8%2FbtsJQnR6i9K%2FFeO3ZeNvmyQVFMYSmRE7T0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="445" data-origin-height="92"/></span></figure> </p> <h4 data-ke-size="size20">2-2 tftp-server</h4> <pre id="code_1727673362972" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>yum install tftp tftp-server -y mkdir /var/www/html/linux-install/ vi /usr/lib/systemd/system/tftp.service [Unit] Description=Tftp Server Requires=tftp.socket Documentation=man:in.tftpd [Service] ExecStart=/usr/sbin/in.tftpd -s /var/lib/tftpboot StandardInput=socket [Install] Also=tftp.socket systemctl enable tftp.socket systemctl start tftp.socket</code></pre> <h4 data-ke-size="size20">2-3 dhcp server</h4> <pre id="code_1727673447066" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>yum install dhcp-common dhcp-server -y vi /etc/dhcp/dhcpd.conf # # DHCP Server Configuration file. # see /usr/share/doc/dhcp*/dhcpd.conf.sample # see 'man 5 dhcpd.conf' # ddns-update-style interim; ignore client-updates; default-lease-time 600; max-lease-time 7200; option subnet-mask 255.255.255.0; option broadcast-address 192.168.207.10; option routers 192.168.207.254; option space ipxe; option ipxe-encap-opts code 175 = encapsulate ipxe; option ipxe.priority code 1 = signed integer 8; option ipxe.keep-san code 8 = unsigned integer 8; option ipxe.skip-san-boot code 9 = unsigned integer 8; option ipxe.syslogs code 85 = string; option ipxe.cert code 91 = string; option ipxe.privkey code 92 = string; option ipxe.crosscert code 93 = string; option ipxe.no-pxedhcp code 176 = unsigned integer 8; option ipxe.bus-id code 177 = string; option ipxe.bios-drive code 189 = unsigned integer 8; option ipxe.username code 190 = string; option ipxe.password code 191 = string; option ipxe.reverse-username code 192 = string; option ipxe.reverse-password code 193 = string; option ipxe.version code 235 = string; option iscsi-initiator-iqn code 203 = string; option ipxe.pxeext code 16 = unsigned integer 8; option ipxe.iscsi code 17 = unsigned integer 8; option ipxe.aoe code 18 = unsigned integer 8; option ipxe.http code 19 = unsigned integer 8; option ipxe.https code 20 = unsigned integer 8; option ipxe.tftp code 21 = unsigned integer 8; option ipxe.ftp code 22 = unsigned integer 8; option ipxe.dns code 23 = unsigned integer 8; option ipxe.bzimage code 24 = unsigned integer 8; option ipxe.multiboot code 25 = unsigned integer 8; option ipxe.slam code 26 = unsigned integer 8; option ipxe.srp code 27 = unsigned integer 8; option ipxe.nbi code 32 = unsigned integer 8; option ipxe.pxe code 33 = unsigned integer 8; option ipxe.elf code 34 = unsigned integer 8; option ipxe.comboot code 35 = unsigned integer 8; option ipxe.efi code 36 = unsigned integer 8; option ipxe.fcoe code 37 = unsigned integer 8; option ipxe.vlan code 38 = unsigned integer 8; option ipxe.menu code 39 = unsigned integer 8; option ipxe.sdi code 40 = unsigned integer 8; option ipxe.nfs code 41 = unsigned integer 8; option ipxe.no-pxedhcp 1; option arch code 93 = unsigned integer 16; authoritative; allow booting; allow bootp; subnet 192.168.207.0 netmask 255.255.255.0 { # interface eth0; option subnet-mask 255.255.255.0; option broadcast-address 192.168.207.255; option routers 192.168.207.254; range dynamic-bootp 192.168.207.10 192.168.207.190; class "pxeclients" { match if substring(option vendor-class-identifier, 0, 9) = "PXEClient"; next-server 192.168.207.10; if option arch = 00:07 { filename "ipxe.efi"; # UEFI 모드 클라이언트를 위한 파일 } elsif option arch = 00:00 { filename "undionly.kpxe"; # BIOS 모드 클라이언트를 위한 파일 } else { filename "ipxe.efi"; # 기본적으로 UEFI 파일 제공 } } } systemctl start dhcpd</code></pre> <h3 data-ke-size="size23">3. IPXE</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>설치파일 소스 : <a href="https://github.com/ipxe/ipxe">https://github.com/ipxe/ipxe</a></li> <li>dhcp를 통해서 IP를 받은 뒤에 BIOS, UEFI 타입에 맞게 부트로더를 선택하게 되고, tftp서버에서 해당 파일을 다운로드 받아 Client가 부팅되게 한다. ipxe 부트로더는 http서비스를 통해서 ipxe 설정파일들을 읽어서 pxe환경을 Client 화면에 출력한다.</li> </ul> <h4 data-ke-size="size20">3-1 iPXE 컴파일</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>iPXE를 UEFI, BIOS 두 용도로 나눠서 컴파일을 한다. 컴파일 할 때 boot.ipxe 파일을 포함시킨다. 그래야 httpd를 통해서 iPXE용 메뉴인 menu.ipxe 파일을 바로 호출할 수 있다.</li> <li>UEFI 용으로 컴파일 한다.</li> </ul> <pre id="code_1727673514858" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># source download cd ~ git clone https://github.com/ipxe/ipxe.git mv ipxe ipxe_uefi cd ipxe_uefi/src # enbed할 파일 생성 : boot.ipxe cat &gt; boot.ipxe &lt;&lt; EOL #!ipxe dhcp chain http://\${next-server}/ipxe/menu.ipxe EOL # 일부 코드 수정 : 그래픽 이미지를 사용하려면 아래 설정을 해주고 컴파일을 해야함 sed -i -e 's/\/\/#define\s*CONSOLE_CMD/#define CONSOLE_CMD/g' config/general.h sed -i -e 's/\/\/#define\s*TIME_CMD/#define TIME_CMD/g' config/general.h sed -i -e 's/\/\/#define\s*CONSOLE_FRAMEBUFFER/#define CONSOLE_FRAMEBUFFER/g' config/console.h # compile make clean make bin-x86_64-efi/ipxe.efi EMBED=boot.ipxe chmod +x bin-x86_64-efi/ipxe.efi /bin/cp -f bin-x86_64-efi/ipxe.efi /var/www/html/linux-install/</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>BIOS(legacy) 용으로 컴파일</li> </ul> <pre id="code_1727673550004" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># source download cd ~ git clone https://github.com/ipxe/ipxe.git mv ipxe ipxe_legacy cd ipxe_legacy/src # enbed할 파일 생성 : boot.ipxe cat &gt; boot.ipxe &lt;&lt; EOL #!ipxe dhcp chain http://\${next-server}/ipxe/menu.ipxe EOL # 일부 코드 수정 : 그래픽 이미지를 사용하려면 아래 설정을 해주고 컴파일을 해야함 sed -i -e 's/\/\/#define\s*CONSOLE_CMD/#define CONSOLE_CMD/g' config/general.h sed -i -e 's/\/\/#define\s*TIME_CMD/#define TIME_CMD/g' config/general.h sed -i -e 's/\/\/#define\s*CONSOLE_FRAMEBUFFER/#define CONSOLE_FRAMEBUFFER/g' config/console.h # The ESXi Legacy BIOS bootloader mboot.c32 needs COMBOOT enabled in iPXE sed -i -e 's/\/\/#define\s*IMAGE_COMBOOT/#define IMAGE_COMBOOT/g' config/general.h # compile make clean make bin/undionly.kpxe EMBED=boot.ipxe /bin/cp -f bin/undionly.kpxe /var/www/html/linux-install/</code></pre> <h4 data-ke-size="size20">3-2 ipxe 메뉴 구성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>기본 메뉴를 위한 http 경로 생성 <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>OS : iso 이미지를 통해서 OS 이미지 파일을 복사하는 경로</li> <li>img : ipxe 메뉴의 배경이미지 파일 경로</li> <li>ks : kickstart 파일 경로.</li> <li>submenu : ipxe 메뉴용 파일 경로</li> </ul> </li> </ul> <pre id="code_1727673587038" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>mkdir&nbsp;-p /var/www/html/ipxe/{OS,img,ks,submenu}</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>ipxe 배경 파일 다운로드</li> </ul> <pre id="code_1727673602822" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>cd /var/www/html/ipxe/img wget http://boot.ipxe.org/ipxe.png &nbsp; # 배경이미지</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>기본 메뉴 파일</li> </ul> <pre id="code_1727673625288" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vi /var/www/html/ipxe/menu.ipxe #!ipxe # Some menu defaults set menu-timeout 50000 set submenu-timeout 30000 set esc:hex 1b set bold ${esc:string}[1m set orange ${esc:string}[33;0m set yellow ${esc:string}[33;1m set cyan ${esc:string}[36;1m set resetfg ${esc:string}[39m set resetbg ${esc:string}[49m set resetbold ${esc:string}[22m set reset ${esc:string}[0m console --picture http://${next-server}/ipxe/img/ipxe.png --left 64 --right 0 --top 64 --bottom 96 colour --basic 3 --rgb 0xffaa44 3 cpair --foreground 0 --background 3 2 cpair --foreground 3 3 set chotkey ${bold} set cname ${orange} goto start :start chain --replace --autofree http://${next-server}/ipxe/submenu/start.ipxe\</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>메인 메뉴</li> </ul> <pre id="code_1727673652469" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vi /var/www/html/ipxe/submenu/start.ipxe #!ipxe menu ESTAR - iPXE menu item --gap -- ---------------- Boot from Local Hard Disk ------------------------------------------------ item --key l exit ${chotkey}l${resetbold}ocal Disk item --gap -- ---------------- CentOS ------------------------------------------------------------------- item --key c centos7-setup ${chotkey}c${resetbold}entOS 7 item --key C centos8-setup ${chotkey}C${resetbold}entOS 8 item --key r rocky8-setup ${chotkey}r${resetbold}ockyLinux 8 item --gap -- ---------------- ETC ---------------------------------------------------------------------- item --key R reboot ${chotkey}R${resetbold}eboot item --key s shell iPXE${chotkey}s${resetbold}hell #choose --timeout ${menu-timeout} --default windows10 os &amp;&amp; goto ${os} choose --timeout ${menu-timeout} os &amp;&amp; goto ${os} ###################### Local Disk ############################# :exit exit ###################### submenu ############################# :centos7-setup chain http://${next-server}/ipxe/submenu/centos7.ipxe :centos8-setup chain http://${next-server}/ipxe/submenu/centos8.ipxe :rocky8-setup chain http://${next-server}/ipxe/submenu/rockylinux8.ipxe ###################### ETC ############################# :reboot reboot :shell shell chain --replace --autofree http://${next-server}/ipxe/submenu/start.ipxe</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Rockylinux 8 버전 메뉴</li> </ul> <pre id="code_1727673671751" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi /var/www/html/ipxe/submenu/rockylinux8.ipxe #!ipxe menu ${chotkey}RockyLinux 8${resetbold} item --gap -- ---------------- BIOS --------------------------------------------------------------------- item --key 1 rockylinux86-bios ${chotkey}1.${resetbold} RockyLinux 8.6 - bios item --key 2 rockylinux87-bios ${chotkey}2.${resetbold} RockyLinux 8.7 - bios item --key 3 rockylinux89-bios ${chotkey}3.${resetbold} RockyLinux 8.9 - bios item --gap -- ---------------- UEFI --------------------------------------------------------------------- item --key 4 rockylinux86-uefi ${chotkey}4.${resetbold} RockyLinux 8.6 - uefi item --key 5 rockylinux87-uefi ${chotkey}5.${resetbold} RockyLinux 8.7 - uefi item --key 6 rockylinux89-uefi ${chotkey}6.${resetbold} RockyLinux 8.9 - uefi item --gap -- ---------------- Interactive -------------------------------------------------------------- item --key 7 rockylinux86-uefi-interactive ${chotkey}7.${resetbold} RockyLinux 8.6 - uefi - interactive item --key 8 rockylinux86-uefi-by-num-from-list ${chotkey}8.${resetbold} RockyLinux 8.6 - uefi - by_number item --gap -- ---------------- BACK --------------------------------------------------------------------- item --key b start go ${chotkey}b${resetbold}ack to start choose --timeout ${menu-timeout} os &amp;&amp; goto ${os} :start chain --replace --autofree http://${next-server}/ipxe/submenu/start.ipxe :rockylinux86-bios set base http://${next-server}/ipxe/OS/rocky8.6/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.6_BIOS.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img boot :rockylinux86-uefi set base http://${next-server}/ipxe/OS/rocky8.6/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.6_UEFI.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img boot :rockylinux87-bios set base http://${next-server}/ipxe/OS/rocky8.7/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.7_BIOS.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img boot :rockylinux87-uefi set base http://${next-server}/ipxe/OS/rocky8.7/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.7_UEFI.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img boot :rockylinux89-bios set base http://${next-server}/ipxe/OS/rocky8.9/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.9_BIOS.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img boot :rockylinux89-uefi set base http://${next-server}/ipxe/OS/rocky8.9/ kernel ${base}/images/pxeboot/vmlinuz initrd=initrd.img inst.repo=${base} inst.ks=http://${next-server}/ipxe/ks/estar-Rocky8.9_UEFI.cfg inst.xdriver=vesa nomodeset ksdevice=eth0 biosdevname=0 net.ifnames=0 initrd ${base}/images/pxeboot/initrd.img</code></pre> <h3 data-ke-size="size23">4. OS 이미지 준비</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>iso 이미지를 마운트 하고, 속의 내용을 복사하여 파일을 만든다.</li> </ul> <pre id="code_1727673688457" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ll total 2504 drwxr-xr-x 8 root root 4096 Jun 30 14:56 centos7.4 drwxr-xr-x 8 root root 4096 Jun 30 14:52 centos7.6 drwxr-xr-x 8 root root 4096 Jun 30 14:43 centos7.8 drwxr-xr-x 8 root root 4096 Jun 30 14:45 centos7.9 -rwxr-xr-x 1 root root 3411 Jun 30 15:07 grub.cfg -rwxr-xr-x 1 root root 2292672 Jun 30 14:46 grubx64.efi drwxr-xr-x 2 root root 4096 Sep 25 13:56 kickstart -rwxr-xr-x 1 root root 116128 Jun 30 14:52 ldlinux.c32 -rwxr-xr-x 1 root root 22804 Jun 30 14:43 libutil.c32 -rwxr-xr-x 1 root root 26272 Jun 30 14:56 menu.c32 -rwxr-xr-x 1 root root 42397 Jun 30 14:43 pxelinux.0 drwxr-xr-x 2 root root 4096 Sep 25 13:39 pxelinux.cfg drwxr-xr-x 7 root root 4096 Jun 30 14:55 RHEL8.6 drwxr-xr-x 7 root root 4096 Jun 30 14:46 rocky8.4 drwxr-xr-x 7 root root 4096 Jun 30 14:50 rocky8.6 drwxr-xr-x 7 root root 4096 Jun 30 14:48 rocky8.7 drwxr-xr-x 7 root root 4096 Sep 30 13:09 rocky8.9 drwxr-xr-x 7 root root 4096 Jun 30 14:53 rocky9.2</code></pre> <h3 data-ke-size="size23">5. Kickstart</h3> <pre id="code_1727673733412" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ls -al | grep Rocky -rwxr-xr-x 1 root root 8311 Sep 30 10:38 estar-Rocky8.4_BIOS.cfg -rwxr-xr-x 1 root root 8322 Sep 30 10:38 estar-Rocky8.4_UEFI.cfg -rwxr-xr-x 1 root root 8353 Sep 30 10:38 estar-Rocky8.6_BIOS.cfg -rwxr-xr-x 1 root root 8132 Sep 30 11:39 estar-Rocky8.6_UEFI.cfg -rwxr-xr-x 1 root root 8104 Sep 30 10:38 estar-Rocky8.7_BIOS.cfg -rwxr-xr-x 1 root root 8368 Sep 30 11:56 estar-Rocky8.7_UEFI.cfg -rwxr-xr-x 1 root root 8104 Sep 30 13:01 estar-Rocky8.9_BIOS.cfg -rwxr-xr-x 1 root root 8369 Sep 30 13:01 estar-Rocky8.9_UEFI.cfg -rwxr-xr-x 1 root root 8315 Sep 30 10:38 estar-Rocky9.2_BIOS.cfg -rwxr-xr-x 1 root root 8319 Sep 30 10:38 estar-Rocky9.2_UEFI.cfg</code></pre> <h3 data-ke-size="size23">6. 실행</h3> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="804" data-origin-height="598"><span data-url="https://blog.kakaocdn.net/dn/mM5Th/btsJSs42q4T/MEoXgC0yDz6DHMVF335jSk/img.png" data-phocus="https://blog.kakaocdn.net/dn/mM5Th/btsJSs42q4T/MEoXgC0yDz6DHMVF335jSk/img.png"><img src="https://blog.kakaocdn.net/dn/mM5Th/btsJSs42q4T/MEoXgC0yDz6DHMVF335jSk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmM5Th%2FbtsJSs42q4T%2FMEoXgC0yDz6DHMVF335jSk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="804" data-origin-height="598"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="801" data-origin-height="604"><span data-url="https://blog.kakaocdn.net/dn/eofap2/btsJQEsx8Jg/8buJnuU0TseEEmfsgyxcC1/img.png" data-phocus="https://blog.kakaocdn.net/dn/eofap2/btsJQEsx8Jg/8buJnuU0TseEEmfsgyxcC1/img.png"><img src="https://blog.kakaocdn.net/dn/eofap2/btsJQEsx8Jg/8buJnuU0TseEEmfsgyxcC1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Feofap2%2FbtsJQEsx8Jg%2F8buJnuU0TseEEmfsgyxcC1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="801" data-origin-height="604"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1023" data-origin-height="769"><span data-url="https://blog.kakaocdn.net/dn/dlf6h4/btsJRRdpIac/o1m27KPuaCc2tMFV7JWyu0/img.png" data-phocus="https://blog.kakaocdn.net/dn/dlf6h4/btsJRRdpIac/o1m27KPuaCc2tMFV7JWyu0/img.png"><img src="https://blog.kakaocdn.net/dn/dlf6h4/btsJRRdpIac/o1m27KPuaCc2tMFV7JWyu0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdlf6h4%2FbtsJRRdpIac%2Fo1m27KPuaCc2tMFV7JWyu0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1023" data-origin-height="769"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p></description>
<category>OS</category>
<category>install</category>
<category>ipxe</category>
<category>kickstart</category>
<category>OS</category>
<category>pxe</category>
<category>rockylinux</category>
<category>web</category>
<category>리눅스</category>
<category>엔지니어</category>
<category>자동설치</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/205</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-IPXE#entry205comment</comments>
<pubDate>Wed, 2 Oct 2024 12:00:48 +0900</pubDate>
</item>
<item>
<title>[Docker] 서로 다른 서버의 컨테이너 간 통신</title>
<link>https://estar987.com/entry/Docker-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%ED%86%B5%EC%8B%A0</link>
<description><p data-ke-size="size16">아래 방법 중 <span data-token-index="1">Docker Overlay Network</span>가 가장 간단하고 유지보수하기 쉬운 방법이므로 이를 먼저 시도해 보시길 권장합니다.</p> <h3 data-ke-size="size23">1. Docker Overlay Network 사용</h3> <p data-ke-size="size16">Overlay 네트워크는 Docker Swarm이나 Docker 네트워크 플러그인을 사용하여 여러 호스트 간의 컨테이너 통신을 가능하게 해줍니다. 이 방법을 사용하면 두 호스트 간의 네트워크가 쉽게 연결됩니다.</p> <h4 data-ke-size="size20">1.1 클러스터 정보가 담긴 옵션 지우기(서비스 파일 수정)</h4> <p data-ke-size="size16">--cluster-store , --cluster-advertise 옵션 지우기</p> <pre id="code_1727773261546" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi /lib/systemd/system/docker.service ``` #ExecStart=/usr/bin/dockerd --cluster-store=etcd://192.168.207.90:3001 --cluster-advertise=192.168.207.90:3000 --config-file /APP/docker/daemon.json ExecStart=/usr/bin/dockerd --config-file /APP/docker/daemon.json ``` systemctl daemon-reload systemctl restart docker</code></pre> <h4 data-ke-size="size20">1.2 Overlay 네트워크 설정 방법</h4> <p data-ke-size="size16">master90에서 docker swarm 초기화 후 docker95에서 클러스터 가입</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1912" data-origin-height="200"><span data-url="https://blog.kakaocdn.net/dn/8wWYs/btsJQ6wkF5C/ZtqDWxNCOGGgr9D8TsP76k/img.png" data-phocus="https://blog.kakaocdn.net/dn/8wWYs/btsJQ6wkF5C/ZtqDWxNCOGGgr9D8TsP76k/img.png"><img src="https://blog.kakaocdn.net/dn/8wWYs/btsJQ6wkF5C/ZtqDWxNCOGGgr9D8TsP76k/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8wWYs%2FbtsJQ6wkF5C%2FZtqDWxNCOGGgr9D8TsP76k%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1912" data-origin-height="200"/></span></figure> </p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>master90</li> </ul> <pre id="code_1727773353068" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker swarm init --advertise-addr 192.168.207.90 Swarm initialized: current node (njmfa4judyqjnxtuxyw98ok3g) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-20ic7jjt2s69zxqehww6mq7bqrqnpq6ugobis268nyz378vbfb-e6tadnbci9cx0f2wvgquurn4i 192.168.207.90:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>docker95</li> </ul> <p data-ke-size="size16">마스터 노드에서 나온 키값을 그대로 복사 붙여넣기 해준다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Overlay 네트워크 생성master 서버에서 Overlay 네트워크 생성)</li> </ul> <pre id="code_1727773450669" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>docker network create --driver overlay --attachable my-overlay</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>각 컨테이너에 네트워크 연결</li> </ul> <pre id="code_1727773557825" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>(master90)# docker network connect my-overlay Devops02 (docker95)# docker network connect my-overlay BACK02</code></pre> <h4 data-ke-size="size20">1.3&nbsp; 상태 비교</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Docker swarm에 가입되지 않은 컨테이너</li> </ul> <pre id="code_1727773602871" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker exec -it 1141ae498949 /bin/bash root@1141ae498949:/# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:ac:16:00:03 inet addr:172.22.0.3 Bcast:172.22.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:19 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3573 (3.5 KB) TX bytes:0 (0.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Docker swarm 가입된 컨테이너</li> </ul> <pre id="code_1727773615550" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker exec -it 59c106f45ef1 /bin/bash root@59c106f45ef1:/# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:ac:16:00:02 inet addr:172.22.0.2 Bcast:172.22.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:24 errors:0 dropped:0 overruns:0 frame:0 TX packets:48 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3983 (3.9 KB) TX bytes:4592 (4.5 KB) eth1 Link encap:Ethernet HWaddr 02:42:0a:00:01:04 inet addr:10.0.1.4 Bcast:10.0.1.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:7 errors:0 dropped:0 overruns:0 frame:0 TX packets:10 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:462 (462.0 B) TX bytes:588 (588.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:4 errors:0 dropped:0 overruns:0 frame:0 TX packets:4 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:392 (392.0 B) TX bytes:392 (392.0 B)</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1900" data-origin-height="852"><span data-url="https://blog.kakaocdn.net/dn/DjOrh/btsJQ2m5T3h/ieC5k0mt4xXneyIPaLuJnk/img.png" data-phocus="https://blog.kakaocdn.net/dn/DjOrh/btsJQ2m5T3h/ieC5k0mt4xXneyIPaLuJnk/img.png"><img src="https://blog.kakaocdn.net/dn/DjOrh/btsJQ2m5T3h/ieC5k0mt4xXneyIPaLuJnk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDjOrh%2FbtsJQ2m5T3h%2FieC5k0mt4xXneyIPaLuJnk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1900" data-origin-height="852"/></span></figure> </p> <h3 data-ke-size="size23">2. Docker Compose와 Overlay Network 사용</h3> <p data-ke-size="size16">Docker Compose를 사용하여 Overlay 네트워크를 설정할 수도 있습니다. Docker Compose 파일을 생성하여 여러 컨테이너가 같은 네트워크를 공유하도록 설정할 수 있습니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>yaml 코드 작성</li> </ul> <pre id="code_1727773738410" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vi docker-compose.yml version: '3.7' services: devops02: image: ubuntu:14.04 networks: - my-overlay back02: image: ubuntu:14.04 networks: - my-overlay networks: my-overlay: external: true</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Docker compose 네트워크 배포</li> </ul> <pre id="code_1727773764919" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>[root@docker95 ~]# docker-compose up -d WARNING: The Docker Engine you're using is running in swarm mode. Compose does not use swarm mode to deploy services to multiple nodes in a swarm. All containers will be scheduled on the current node. To deploy your application across the swarm, use `docker stack deploy`. Creating root_devops02_1 ... done Creating root_back02_1 ... done</code></pre> <h3 data-ke-size="size23">3. OpenVPN 또는 GRE 터널링 사용</h3> <p data-ke-size="size16">만약 Overlay 네트워크 사용이 불가능하다면, 두 서버 간의 네트워크 통신을 위해 OpenVPN 또는 GRE(Generic Routing Encapsulation) 터널을 설정하여 호스트 간의 가상 네트워크를 구성할 수 있습니다.</p> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>OpenVPN 설치 및 구성</b> 각 호스트에 OpenVPN을 설치하고, 네트워크 터널을 설정하여 두 호스트 간의 네트워크가 연결되도록 설정합니다.</li> <li><b>GRE 터널 설정</b> GRE 터널을 사용하여 두 호스트 간의 네트워크 인터페이스를 가상화하고, 두 호스트 간의 패킷이 GRE 터널을 통해 전달되도록 설정합니다.</li> </ul> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>master 90 세팅(docker95에서는 반대로 세팅하면 된다.)</li> </ul> <pre id="code_1727773809068" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ip tunnel add gre1 mode gre remote &lt;docker95 IP&gt; local &lt;master90 IP&gt; ttl 255 ip link set gre1 up ip addr add 192.168.10.1/24 dev gre1</code></pre> <h3 data-ke-size="size23">4. 기본 브리지 네트워크와 iptables 설정</h3> <p data-ke-size="size16">기본 브리지 네트워크를 사용하여 각 호스트 간에 통신이 가능하게 하려면 iptables를 사용하여 NAT와 포트 포워딩을 설정해 줄 수 있습니다. 예를 들어, 두 호스트 간의 네트워크 인터페이스가 통신하도록 라우팅 규칙을 설정합니다.</p> <pre id="code_1727773823892" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>iptables -A FORWARD -i br-Front -o br-DB -j ACCEPT iptables -A FORWARD -i br-DB -o br-Front -j ACCEPT</code></pre></description>
<category>Docker</category>
<category>bridge</category>
<category>ceth</category>
<category>docker</category>
<category>Linux</category>
<category>namespace</category>
<category>Network</category>
<category>veth</category>
<category>도커</category>
<category>외부 통신</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/208</guid>
<comments>https://estar987.com/entry/Docker-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%ED%86%B5%EC%8B%A0#entry208comment</comments>
<pubDate>Tue, 1 Oct 2024 18:19:57 +0900</pubDate>
</item>
<item>
<title>[Docker] 도커 네트워크 bridge 설정</title>
<link>https://estar987.com/entry/Docker-%EB%8F%84%EC%BB%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-bridge-%EC%84%A4%EC%A0%95</link>
<description><h3 data-ke-size="size23">1. 네트워크 bridge 생성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>master90</li> </ul> <pre id="code_1727772899778" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>docker network create --driver bridge devops docker network create --driver bridge db</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>docker 95</li> </ul> <pre id="code_1727772906708" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>docker network create --driver bridge front docker network create --driver bridge backend</code></pre> <h4 data-ke-size="size20">1-2 Bridge 별 대역대</h4> <pre id="code_1727772920622" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>master90 # docker inspect devops | grep -i subnet "Subnet": "172.22.0.0/16", # docker inspect db | grep -i subnet "Subnet": "172.23.0.0/16", docker95 # docker inspect backend | grep -i subnet "Subnet": "172.21.0.0/16", # docker inspect front | grep -i subnet "Subnet": "172.20.0.0/16",</code></pre> <h3 data-ke-size="size23">2. 생성한 Bridge에 연결하는 컨테이너 생성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>master90</li> </ul> <pre id="code_1727772955033" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run -dit --name DB01 --network db ubuntu:14.04 /bin/bash # docker run -dit --name DB02 --network db ubuntu:14.04 /bin/bash # docker run -dit --name Devops01 --network devops ubuntu:14.04 /bin/bash # docker run -dit --name Devops02 --network devops ubuntu:14.04 /bin/bash</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>docker 95</li> </ul> <pre id="code_1727772965736" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run -dit --name Front01 --network front ubuntu:14.04 /bin/bash # docker run -dit --name Front02 --network front ubuntu:14.04 /bin/bash # docker run -dit --name BACK01 --network backend ubuntu:14.04 /bin/bash # docker run -dit --name BACK02 --network backend ubuntu:14.04 /bin/bash</code></pre> <h3 data-ke-size="size23">3. veth 페어 생성 및 호스트 네임스페이스 연결</h3> <pre id="code_1727772977970" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># 네임스페이스 생성 ip netns add ns # veth 페어 생성 ip link add ceth0 type veth peer name veth0 ip link add ceth1 type veth peer name veth1 # veth의 한쪽 끝을 네임스페이스에 연결 ip link set ceth0 netns ns ip link set ceth1 netns ns # master90 brctl addif br-$(docker network inspect -f '{{.Id}}' db) veth0 brctl addif br-$(docker network inspect -f '{{.Id}}' devops) veth1 # docker95 brctl addif br-$(docker network inspect -f '{{.Id}}' front) veth0 brctl addif br-$(docker network inspect -f '{{.Id}}' backend) veth1 # veth 인터페이스 활성화 ip link set veth0 up ip link set veth1 up</code></pre> <h3 data-ke-size="size23">4. 네임스페이스 내에서 인터페이스 활성화 및 IP 설정</h3> <p data-ke-size="size16">네임스페이스(ns) 내부에서 ceth0 과 ceth1에 ip 주소를 설정하고 활성화 합니다.</p> <pre id="code_1727773024293" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>ip netns exec ns ip addr add 192.168.1.10/24 dev ceth0 ip netns exec ns ip addr add 192.168.2.10/24 dev ceth1 ip netns exec ns ip link set ceth0 up ip netns exec ns ip link set ceth1 up !! 접속 후 ping Test # ip netns exec ns ip addr show ceth0 84: ceth0@if83: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 96:2c:e4:36:ed:75 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.1.10/24 scope global ceth0 valid_lft forever preferred_lft forever inet6 fe80::942c:e4ff:fe36:ed75/64 scope link valid_lft forever preferred_lft forever # ip netns exec ns ip addr show ceth1 86: ceth1@if85: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 46:4b:5b:f3:bd:fc brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.2.10/24 scope global ceth1 valid_lft forever preferred_lft forever inet6 fe80::444b:5bff:fef3:bdfc/64 scope link valid_lft forever preferred_lft forever</code></pre></description>
<category>Docker</category>
<category>bridge</category>
<category>ceth</category>
<category>DevOps</category>
<category>docker</category>
<category>Network</category>
<category>veth</category>
<category>네트워크</category>
<category>도커</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/207</guid>
<comments>https://estar987.com/entry/Docker-%EB%8F%84%EC%BB%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-bridge-%EC%84%A4%EC%A0%95#entry207comment</comments>
<pubDate>Tue, 1 Oct 2024 18:19:37 +0900</pubDate>
</item>
<item>
<title>[Docker] ceth, veth 각각 연결 vs 페어 연결</title>
<link>https://estar987.com/entry/Docker-ceth-veth-%EA%B0%81%EA%B0%81-%EC%97%B0%EA%B2%B0-vs-%ED%8E%98%EC%96%B4-%EC%97%B0%EA%B2%B0</link>
<description><h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">네트워크 인터페이스를 구성할 때 "각각 연결하는 것"과 "veth 페어 설정" 간에는 개념적 및 동작 방식에서 큰 차이점이 있습니다. 각각의 방법은 특정 상황에 따라 적합한 용도가 있으며, 네트워크 격리 및 연결을 어떻게 관리할지에 따라 선택이 달라질 수 있습니다.</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="584" data-origin-height="326"><span data-url="https://blog.kakaocdn.net/dn/DlKMQ/btsJSRjSvNC/BxwlXOiK0dxBJ7wsKDkn4K/img.png" data-phocus="https://blog.kakaocdn.net/dn/DlKMQ/btsJSRjSvNC/BxwlXOiK0dxBJ7wsKDkn4K/img.png"><img src="https://blog.kakaocdn.net/dn/DlKMQ/btsJSRjSvNC/BxwlXOiK0dxBJ7wsKDkn4K/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDlKMQ%2FbtsJSRjSvNC%2FBxwlXOiK0dxBJ7wsKDkn4K%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="584" data-origin-height="326"/></span></figure> </p> <p data-ke-size="size16">이미지와 같은 설정에서는 <span style="color: #eb5757;" data-token-index="1">veth</span> 인터페이스가 네임스페이스(<span style="color: #eb5757;" data-token-index="3">ns</span>) 내부의 <span style="color: #eb5757;" data-token-index="5">ceth</span> 인터페이스와 Docker 네트워크 브리지(<span style="color: #eb5757;" data-token-index="7">DevOps</span>와 <span style="color: #eb5757;" data-token-index="9">DB</span>) 간의 통신을 연결하는 중계 역할을 합니다. 이를 통해 네임스페이스와 Docker 브리지 네트워크 및 그 안에 있는 컨테이너들 간의 통신을 가능하게 해줍니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">1. 네트워크 구성 설명</h3> <h4 data-ke-size="size20">1.1 네임스페이스 내부 인터페이스(ceth0, ceth1)</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>ceth0과 ceth1은 네임스페이스(ns) 내부에 생성된 가상 네트워크 인터페이스입니다.</li> <li>각각의 ceth 인터페이스는 veth 페어를 통해 외부 네트워크(즉, 호스트 네임스페이스 및 Docker 브리지)와 연결됩니다.</li> <li>네임스페이스 내부에서 독립적인 IP 주소와 라우팅 테이블을 가집니다.</li> </ul> <h4 data-ke-size="size20">1.2 veth 페어</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>veth 페어는 한쪽 인터페이스가 네임스페이스 내부(ceth0, ceth1)와 연결되고, 다른 쪽은 호스트 네트워크 브리지(DevOps 브리지, DB 브리지)와 연결됩니다.</li> <li>veth의 한쪽 끝은 네임스페이스 내부 인터페이스(ceth0, ceth1)로 연결되고, 다른 쪽은 Docker 브리지와 연결되므로, 네임스페이스와 Docker 네트워크 간의 <b>연결 통로</b> 역할을 합니다.</li> </ul> <h4 data-ke-size="size20">1.3 Docker network bridge(devops, db)</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>각 Docker 네트워크 브리지는 독립적인 네트워크 세그먼트로 구성됩니다. 예를 들어: <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>DevOps 브리지: 192.168.1.0/24</li> <li>DB 브리지: 192.168.2.0/24</li> </ul> </li> <li>DevOps 브리지에 속한 Docker 컨테이너(DevOps01, DevOps02)와 DB 브리지에 속한 컨테이너(DB01, DB02)는 같은 브리지 네트워크 내에서 서로 통신이 가능합니다.</li> </ul> <h4 data-ke-size="size20">1.4 veth 역할</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>각 veth 인터페이스는 <b>두 네트워크 인터페이스 간의 연결</b>을 위한 <b>가상 네트워크 케이블</b>과 같은 역할을 합니다.</li> <li>예를 들어: <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>veth0은 네임스페이스의 ceth0과 DevOps 브리지에 연결되어, 네임스페이스가 DevOps 브리지 및 그 안에 있는 컨테이너들과 통신할 수 있도록 합니다.</li> <li>veth1은 네임스페이스의 ceth1과 DB 브리지에 연결되어, 네임스페이스가 DB 브리지 및 그 안에 있는 컨테이너들과 통신할 수 있도록 합니다.</li> </ul> </li> </ul> <h4 data-ke-size="size20">1.5 네트워크 흐름 예시</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>네임스페이스(ns) 내 ceth0에서 DevOps01 컨테이너로 통신</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>네임스페이스 내부에서 ceth0 인터페이스를 통해 패킷이 전달되면, 이 패킷은 veth0을 통해 DevOps 브리지로 전달됩니다.</li> <li>DevOps 브리지에 속한 DevOps01 또는 DevOps02 컨테이너가 해당 패킷을 수신하고 응답할 수 있습니다.</li> </ul> </li> <li><b>DB01 컨테이너에서 ceth1로 통신</b> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>DB01 컨테이너에서 네임스페이스로 패킷을 보내려면, 패킷이 DB 브리지로 전송되고, veth1을 통해 ceth1 인터페이스로 전달됩니다.</li> <li>ceth1 인터페이스가 네임스페이스의 라우팅 설정에 따라 패킷을 처리하게 됩니다.</li> </ul> </li> </ul> <h3 data-ke-size="size23">2. 각각 연결하는 것</h3> <p data-ke-size="size16">각각의 네트워크 인터페이스를 별도의 네트워크에 연결하는 경우는 네트워크 인터페이스를 독립적으로 관리하고, 각각의 네트워크 환경에서 통신을 별도로 구성할 때 사용하는 방식입니다.</p> <h4 data-ke-size="size20">2.1 특징</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>독립적인 네트워크 인터페이스 관리</b>: 각 인터페이스는 자체 네트워크 환경을 가지며, 다른 인터페이스와 직접적인 연결이 없을 수 있습니다.</li> <li><b>각기 다른 네트워크 세그먼트에 연결 가능</b>: 하나의 인터페이스가 192.168.1.0/24 네트워크에, 다른 인터페이스가 192.168.2.0/24에 연결되어 있을 수 있습니다.</li> <li><b>컨테이너, 호스트 네트워크 등과의 연결</b>: 독립적으로 다른 Docker 네트워크나 호스트 네트워크에 연결될 수 있습니다.</li> <li><b>네트워크 간 직접 통신이 불가능</b>: 기본적으로는 네트워크 인터페이스 간에 직접적인 통신이 불가능하므로, 다른 네트워크 인터페이스로부터 패킷을 받거나 전달하려면 라우팅 설정이나 브리지 연결이 필요합니다.</li> </ul> <h4 data-ke-size="size20">2.2 실습</h4> <pre id="code_1727772371395" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>docker network create --driver bridge net1 docker network create --driver bridge net2 docker run -d --name container1 --network net1 ubuntu docker run -d --name container2 --network net2 ubuntu</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">이 방법은 <span data-token-index="1">격리된 네트워크 환경</span>이 필요할 때 유용합니다. 예를 들어, 네트워크 테스트, 독립적인 서브넷 관리, 또는 보안적으로 구분된 네트워크를 설정할 때 사용됩니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">3. veth 페어 설정</h3> <p data-ke-size="size16">veth (virtual Ethernet) 페어는 네트워크 네임스페이스 또는 컨테이너 간의 통신을 위해 사용하는 <span data-token-index="1">가상 네트워크 인터페이스</span>의 한 쌍입니다. veth 는 한쪽 인터페이스에서 입력된 데이터가 다른 쪽 인터페이스로 직접 전달되는 구조를 가지고 있어, <span data-token-index="3">네트워크 네임스페이스 간의 연결</span>이나 <span data-token-index="5">컨테이너 간의 직접적인 통신</span>을 설정할 때 유용합니다.</p> <h4 data-ke-size="size20">3.1 특징</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>가상 네트워크 인터페이스의 한 쌍</b>: veth는 두 개의 인터페이스가 쌍으로 연결되며, 하나의 veth 인터페이스에서 들어온 패킷이 자동으로 다른 쪽 veth 인터페이스로 전달됩니다.</li> <li><b>네트워크 네임스페이스 간 통신</b>: veth는 서로 다른 네임스페이스 간에 연결될 수 있습니다. 예를 들어, ns1에 있는 veth0과 ns2에 있는 veth1이 연결되어 있다면, 두 네임스페이스가 서로 통신할 수 있게 됩니다.</li> <li><b>브리지 네트워크 구성에 사용</b>: veth를 호스트의 브리지 네트워크와 연결하여 다수의 네트워크 네임스페이스 또는 컨테이너를 브리지 네트워크와 통합할 수 있습니다.</li> <li><b>직접적인 패킷 전달</b>: 두 인터페이스는 한 쌍으로 연결되어 있어, 라우팅이나 추가적인 네트워크 설정이 없어도 서로 패킷을 주고받을 수 있습니다.</li> </ul> <h4 data-ke-size="size20">3.2 실습</h4> <pre id="code_1727772413485" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># 네트워크 네임스페이스 간 veth 페어 생성 및 연결 ip netns add ns1 ip netns add ns2 ip link add veth0 type veth peer name veth1 # 각 네임스페이스에 veth 페어 연결 ip link set veth0 netns ns1 ip link set veth1 netns ns2 # 네임스페이스 내에서 인터페이스 활성화 및 IP 할당 ip netns exec ns1 ip addr add 192.168.1.1/24 dev veth0 ip netns exec ns2 ip addr add 192.168.1.2/24 dev veth1 ip netns exec ns1 ip link set veth0 up ip netns exec ns2 ip link set veth1 up # 네임스페이스 간 ping 테스트 ip netns exec ns1 ping 192.168.1.2</code></pre> <h3 data-ke-size="size23">4. 주요 차이점</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>통신 구조</b>: 각각의 네트워크 연결 방식은 브리지나 호스트 네트워크와 독립적으로 구성되어 라우팅이 필요하지만, veth 페어는 두 인터페이스가 직접적으로 연결되어 있어 별도의 라우팅이나 브리지 설정이 없어도 바로 통신이 가능합니다.</li> <li><b>사용 목적</b>: 각각의 네트워크 인터페이스 연결은 보통 다양한 네트워크 세그먼트를 구성하거나, 서로 다른 보안 환경을 구축할 때 사용됩니다. 반면, veth 페어는 네트워크 네임스페이스 간의 <b>연결 및 테스트</b> 용도로 많이 사용됩니다.</li> <li><b>유연성</b>: veth 페어는 다양한 네트워크 구성에서 다른 인터페이스와 쉽게 결합할 수 있어 네트워크 테스트 및 다중 네트워크 환경을 구축할 때 유용합니다.</li> </ul></description>
<category>Docker</category>
<category>ceth</category>
<category>docker</category>
<category>IP</category>
<category>Linux</category>
<category>namespace</category>
<category>Network</category>
<category>veth</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/206</guid>
<comments>https://estar987.com/entry/Docker-ceth-veth-%EA%B0%81%EA%B0%81-%EC%97%B0%EA%B2%B0-vs-%ED%8E%98%EC%96%B4-%EC%97%B0%EA%B2%B0#entry206comment</comments>
<pubDate>Tue, 1 Oct 2024 18:19:29 +0900</pubDate>
</item>
<item>
<title>[Docker] Docker network 외부 통신하기(toy project)</title>
<link>https://estar987.com/entry/Docker-Docker-network-%EC%99%B8%EB%B6%80-%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0toy-project</link>
<description><p data-ke-size="size16"><a href="https://estar987.com/208" target="_blank" rel="noopener">2024.10.01 - [Docker] - [Docker] 서로 다른 서버의 컨테이너 간 통신</a></p> <figure id="og_1727774770611" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="[Docker] 서로 다른 서버의 컨테이너 간 통신" data-og-description="아래 방법 중 Docker Overlay Network가 가장 간단하고 유지보수하기 쉬운 방법이므로 이를 먼저 시도해 보시길 권장합니다.1. Docker Overlay Network 사용Overlay 네트워크는 Docker Swarm이나 Docker 네트워크 플" data-og-host="estar987.com" data-og-source-url="https://estar987.com/208" data-og-url="https://estar987.com/208" data-og-image="https://scrap.kakaocdn.net/dn/ct4hVy/hyXaJmlnoB/KWkriHQuFWoAsgdTAYGXL0/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/exwhS8/hyXaBoibc6/BLuDLylXCLnwvIvzwipcr0/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/esfana/hyXav2EWI4/y4N9iuIx7vK5dk0oKf5yWk/img.png?width=1900&amp;height=852&amp;face=0_0_1900_852"><a href="https://estar987.com/208" target="_blank" rel="noopener" data-source-url="https://estar987.com/208"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/ct4hVy/hyXaJmlnoB/KWkriHQuFWoAsgdTAYGXL0/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/exwhS8/hyXaBoibc6/BLuDLylXCLnwvIvzwipcr0/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/esfana/hyXav2EWI4/y4N9iuIx7vK5dk0oKf5yWk/img.png?width=1900&amp;height=852&amp;face=0_0_1900_852');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">[Docker] 서로 다른 서버의 컨테이너 간 통신</p> <p class="og-desc" data-ke-size="size16">아래 방법 중 Docker Overlay Network가 가장 간단하고 유지보수하기 쉬운 방법이므로 이를 먼저 시도해 보시길 권장합니다.1. Docker Overlay Network 사용Overlay 네트워크는 Docker Swarm이나 Docker 네트워크 플</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><a href="https://estar987.com/207" target="_blank" rel="noopener">2024.10.01 - [Docker] - [Docker] 도커 네트워크 bridge 설정</a></p> <figure id="og_1727774753455" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="[Docker] 도커 네트워크 bridge 설정" data-og-description="1. 네트워크 bridge 생성master90docker network create --driver bridge devopsdocker network create --driver bridge dbdocker 95docker network create --driver bridge frontdocker network create --driver bridge backend1-2 Bridge 별 대역대master90# dock" data-og-host="estar987.com" data-og-source-url="https://estar987.com/207" data-og-url="https://estar987.com/207" data-og-image="https://scrap.kakaocdn.net/dn/c0aP4c/hyXaxTJqnO/n5WMHjKRPPCok6SKUfwms1/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/oT3Te/hyXauCIOqx/7gt17Yl7paEy0QuD6nLWVK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800"><a href="https://estar987.com/207" target="_blank" rel="noopener" data-source-url="https://estar987.com/207"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/c0aP4c/hyXaxTJqnO/n5WMHjKRPPCok6SKUfwms1/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/oT3Te/hyXauCIOqx/7gt17Yl7paEy0QuD6nLWVK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">[Docker] 도커 네트워크 bridge 설정</p> <p class="og-desc" data-ke-size="size16">1. 네트워크 bridge 생성master90docker network create --driver bridge devopsdocker network create --driver bridge dbdocker 95docker network create --driver bridge frontdocker network create --driver bridge backend1-2 Bridge 별 대역대master90# dock</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">개요</h3> <p data-ke-size="size16">도커 컨테이너를 처음 생성하면 호스트 ip 외에 통신이 되지 않는다. 따라서 추가적인 네트워크 설정을 해줘야하는데 다양한 상황의 시나리오를 만들어서 설정하는 법을 실습하였다.&nbsp;</p> <p data-ke-size="size16">토폴로지는 아래와 같다. 간단하게 만든 실습 과정으로&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Devops01 &harr; DB01 (같은 서버내의 다른 네트워크 브리지)&nbsp; <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>네트워크 브릿지 설정으로 통신 가능</li> </ul> </li> <li>Devops01 <span style="color: #333333; text-align: left;">&harr;<span> Front01(다른서버의 컨테이너와 통신)</span></span> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>docker swarm을 활용하여 클러스터 구축</li> </ul> </li> </ul> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="873" data-origin-height="753"><span data-url="https://blog.kakaocdn.net/dn/b2UwBO/btsJSMC3uCQ/gJ81h0yyoLB9E6lE6CK8Y1/img.png" data-phocus="https://blog.kakaocdn.net/dn/b2UwBO/btsJSMC3uCQ/gJ81h0yyoLB9E6lE6CK8Y1/img.png"><img src="https://blog.kakaocdn.net/dn/b2UwBO/btsJSMC3uCQ/gJ81h0yyoLB9E6lE6CK8Y1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb2UwBO%2FbtsJSMC3uCQ%2FgJ81h0yyoLB9E6lE6CK8Y1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="873" data-origin-height="753"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>Docker</category>
<category>DevOps</category>
<category>docker</category>
<category>Linux</category>
<category>Network</category>
<category>네트워크</category>
<category>데브옵스</category>
<category>도커</category>
<category>리눅스</category>
<category>컨테이너</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/209</guid>
<comments>https://estar987.com/entry/Docker-Docker-network-%EC%99%B8%EB%B6%80-%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0toy-project#entry209comment</comments>
<pubDate>Tue, 1 Oct 2024 18:19:18 +0900</pubDate>
</item>
<item>
<title>USB Kickstart 만들기</title>
<link>https://estar987.com/entry/USB-Kickstart-%EB%A7%8C%EB%93%A4%EA%B8%B0</link>
<description><h3 data-ke-size="size23">Rufus로 OS USB 만들기</h3> <p data-ke-size="size16"><a href="https://estar987.tistory.com/21" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/21</a></p> <figure id="og_1727315101103" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="Rocky Linux 설치" data-og-description="ISO Rocky-8.6-x86_64-dvd1.iso 설치 과정 1. ISO 파일을 받는다. https://dl.rockylinux.org/vault/rocky/8.6/isos/x86_64/ 2. Rufus를 다운 받고 빈 USB 하나를 준비한다. https://github.com/pbatard/rufus/releases/download/v3.17/rufus-3.17.exe" data-og-host="estar987.com" data-og-source-url="https://estar987.tistory.com/21" data-og-url="https://estar987.com/21" data-og-image="https://scrap.kakaocdn.net/dn/ftdYL/hyW6C2orZr/Hb0hkEhyVXXHgYGb2tFO21/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/cFTTYk/hyXaGoxBEy/rGzH0eBFS8FG9oGioWkh3k/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/qDcaN/hyXayjJRQQ/0hZ51kjFkdcbtyFxn3w5Dk/img.png?width=1400&amp;height=1050&amp;face=0_0_1400_1050"><a href="https://estar987.tistory.com/21" target="_blank" rel="noopener" data-source-url="https://estar987.tistory.com/21"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/ftdYL/hyW6C2orZr/Hb0hkEhyVXXHgYGb2tFO21/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/cFTTYk/hyXaGoxBEy/rGzH0eBFS8FG9oGioWkh3k/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/qDcaN/hyXayjJRQQ/0hZ51kjFkdcbtyFxn3w5Dk/img.png?width=1400&amp;height=1050&amp;face=0_0_1400_1050');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">Rocky Linux 설치</p> <p class="og-desc" data-ke-size="size16">ISO Rocky-8.6-x86_64-dvd1.iso 설치 과정 1. ISO 파일을 받는다. https://dl.rockylinux.org/vault/rocky/8.6/isos/x86_64/ 2. Rufus를 다운 받고 빈 USB 하나를 준비한다. https://github.com/pbatard/rufus/releases/download/v3.17/rufus-3.17.exe</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <h3 data-ke-size="size23">kickstart 파일 생성</h3> <p data-ke-size="size16">/images/pxeboot/ks.cfg 경로에 파일을 생성함(전에 포스팅한 글 참고)</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16"><a href="https://estar987.tistory.com/42" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/42</a></p> <figure id="og_1727315163213" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="PXE 설치 _ Kickstart" data-og-description="개요 https://estar987.tistory.com/38 PXE 설치(FTP 방식) 1. DHCP 서버 설치 yum -y install dhcp-server 혹은 dnf install dhcp-server # vi /etc/dhcp/dhcp.conf # # DHCP Server Configuration file. # see /usr/share/doc/dhcp-server/dhcpd.conf.example #" data-og-host="estar987.com" data-og-source-url="https://estar987.tistory.com/42" data-og-url="https://estar987.com/42" data-og-image="https://scrap.kakaocdn.net/dn/LsZ7f/hyW6CafsPt/bJirrieXng6JTnVkOa1V4k/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/Nk190/hyW6CVENQa/uV9pMkBUymsB8j6njeYSJk/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800"><a href="https://estar987.tistory.com/42" target="_blank" rel="noopener" data-source-url="https://estar987.tistory.com/42"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/LsZ7f/hyW6CafsPt/bJirrieXng6JTnVkOa1V4k/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/Nk190/hyW6CVENQa/uV9pMkBUymsB8j6njeYSJk/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">PXE 설치 _ Kickstart</p> <p class="og-desc" data-ke-size="size16">개요 https://estar987.tistory.com/38 PXE 설치(FTP 방식) 1. DHCP 서버 설치 yum -y install dhcp-server 혹은 dnf install dhcp-server # vi /etc/dhcp/dhcp.conf # # DHCP Server Configuration file. # see /usr/share/doc/dhcp-server/dhcpd.conf.example #</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <h3 data-ke-size="size23">BIOS</h3> <pre id="code_1727315180705" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vim isolinux/isolinux.cfg label Redhat(Kickstart) menu label ^Redhat(Kickstart) kernel vmlinuz menu default append initrd=initrd.img inst.repo=hd:LABEL=RHEL-8-6-0- inst.ks=hd:LABEL=RHEL-8-6-0-:/images/pxeboot/ks.cfg quiet</code></pre> <h3 data-ke-size="size23">UEFI</h3> <pre id="code_1727315194587" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vim EFI/BOOT/grub.cfg menuentry 'PXE' --class fedora --class gnu-linux --class gnu --class os { linuxefi /images/pxeboot/vmlinuz inst.repo=hd:LABEL=RHEL-8-6-0- inst.ks=hd:LABEL=RHEL-8-6-0-:/images/pxeboot/ks.cfg quiet initrdefi /images/pxeboot/initrd.img }</code></pre></description>
<category>OS</category>
<category>bios</category>
<category>kickstart</category>
<category>Linux</category>
<category>OS</category>
<category>pxe</category>
<category>redhat</category>
<category>rockylinux</category>
<category>UEFI</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/204</guid>
<comments>https://estar987.com/entry/USB-Kickstart-%EB%A7%8C%EB%93%A4%EA%B8%B0#entry204comment</comments>
<pubDate>Thu, 26 Sep 2024 12:00:11 +0900</pubDate>
</item>
<item>
<title>[Rockylinux] 이더넷 명 바꾸기(네트워크 인터페이스 이름 바꾸기)</title>
<link>https://estar987.com/entry/Rockylinux-%EC%9D%B4%EB%8D%94%EB%84%B7-%EB%AA%85-%EB%B0%94%EA%BE%B8%EA%B8%B0%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%9D%B4%EB%A6%84-%EB%B0%94%EA%BE%B8%EA%B8%B0</link>
<description><pre id="code_1725971134394" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>vi /etc/default/grub GRUB_CMDLINE_LINUX="crashkernel=auto resume=UUID=46b45669-fb70-4765-ad7e-61947f495668 rhgb quiet" --&gt; 여기 아래 설정 추가 biosdevname=0 net.ifnames=0 추가</code></pre> <h4 data-ke-size="size20">example</h4> <pre id="code_1725971166530" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>GRUB_CMDLINE_LINUX="crashkernel=auto resume=UUID=46b45669-fb70-4765-ad7e-61947f495668 biosdevname=0 net.ifnames=0 rhgb quiet"</code></pre> <h3 data-ke-size="size23"><br />커널 적용</h3> <pre id="code_1725971174582" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>grub2-mkconfig -o /boot/efi/EFI/rocky/grub.cfg</code></pre> <h4 data-ke-size="size20">존재하는 네트워크 설정 파일을 활용하여서 ifcfg-eth0 파일로 복사해서 생성 후 수정</h4> <pre id="code_1725971245051" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>cd /etc/sysconfig/network-scripts cp ifcfg-br0 ifcfg-eth0 vi ifcfg-eth0</code></pre> <pre id="code_1725971288949" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>STP=yes BRIDGING_OPTS=priority=32768 TYPE=Bridge HWADDR= PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=default NAME=br0 UUID=5e799350-ab3f-42f9-be5a-ccf83fb74f1a DEVICE=eth0 // 수정 ONBOOT=yes IPADDR=192.168.207.10 PREFIX=24 GATEWAY=192.168.207.254</code></pre> <h3 data-ke-size="size23">재부팅</h3> <pre id="code_1725971301185" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>reboot</code></pre></description>
<category>Linux</category>
<category>Kernel</category>
<category>Linux</category>
<category>rockylinux</category>
<category>네트워크</category>
<category>리눅스</category>
<category>리눅스 엔지니어</category>
<category>서버 엔지니어</category>
<category>인터페이스</category>
<category>커널</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/203</guid>
<comments>https://estar987.com/entry/Rockylinux-%EC%9D%B4%EB%8D%94%EB%84%B7-%EB%AA%85-%EB%B0%94%EA%BE%B8%EA%B8%B0%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%9D%B4%EB%A6%84-%EB%B0%94%EA%BE%B8%EA%B8%B0#entry203comment</comments>
<pubDate>Wed, 11 Sep 2024 12:00:07 +0900</pubDate>
</item>
<item>
<title>[Kubernetes] 클러스터에 노드 추가</title>
<link>https://estar987.com/entry/Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%97%90-%EB%85%B8%EB%93%9C-%EC%B6%94%EA%B0%80</link>
<description><p data-ke-size="size16">클러스터 구축 후 토큰 값을 까먹거나 여러 요인들로 추가로 작업해줘야할 경우에 아래 과정으로 실시하면 된다.</p> <h3 data-ke-size="size23">Master 노드</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>토큰 값 조회</li> </ul> <pre id="code_1725783895320" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubeadm token list TOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS 19iege.6onflcvyh6yr7bqq 21h 2024-09-09T06:10:33Z authentication,signing The default bootstrap token generated by 'kubeadm init'. system:bootstrappers:kubeadm:default-node-token</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>token 값에는 만료 기간이 있기 때문에 위에서 token 값을 확인할 수 없다면 새로운 token을 생성해줘야함</li> </ul> <pre id="code_1725783918153" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ kubeadm token create $ kubeadm token list</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>HASH 값 확인</li> </ul> <pre id="code_1725783938284" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' 7bbb39683373cc97842fdbadfbdd9a3d918aa070e5a3ddf154dac0965d03bc20</code></pre> <h3 data-ke-size="size23">추가할 작업 노드</h3> <pre id="code_1725783960375" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ kubeadm join &lt;192.168.0.10:6443&gt; --token &lt;Token 값&gt; --discovery-token-ca-cert-hash sha256:&lt;Hash 값&gt;</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>예시</li> </ul> <pre id="code_1725783993313" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubeadm join 192.168.207.40:6443 --token 19iege.6onflcvyh6yr7bqq --discovery-token-ca-cert-hash sha256:7bbb39683373cc97842fdbadfbdd9a3d918aa070e5a3ddf154dac0965d03bc20 [preflight] Running pre-flight checks [WARNING Service-Kubelet]: kubelet service is not enabled, please run 'systemctl enable kubelet.service' [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml' [kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml" [kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env" [kubelet-start] Starting the kubelet [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>cluster</category>
<category>DevOps</category>
<category>kubernetes</category>
<category>Linux</category>
<category>데브옵스</category>
<category>리눅스</category>
<category>증설</category>
<category>추가</category>
<category>쿠버네티스</category>
<category>클러스터</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/202</guid>
<comments>https://estar987.com/entry/Kubernetes-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%97%90-%EB%85%B8%EB%93%9C-%EC%B6%94%EA%B0%80#entry202comment</comments>
<pubDate>Tue, 10 Sep 2024 12:00:30 +0900</pubDate>
</item>
<item>
<title>[SLURM] SBATCH(2)</title>
<link>https://estar987.com/entry/SLURM-SBATCH2</link>
<description><h3 data-ke-size="size23">기타 SBATCH 옵션</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Dependency Job 수행 방법</li> </ul> <pre id="code_1725590088255" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>#SBATCH --error=파일이름 #SBATCH --mail-type=ALL #SBATCH --mail-user=이메일 주소 #SBATCH --cpu-per-task=쓰레드 수 #SBATCH --mem=메모리 크기 // --mem, --mem-per-cpu는 중복 불가, 노드 설정에 RealMemory=8080(M) 부분 반영 필요 #SBATCH --mem-per-cpu=메모리 크기 #SBATCH --gres=gpu:개수 #SBATCH --time=HH:MM:SS #SBATCH --begin=시작시간 #SBATCH --partition=파티션이름 #SBATCH --qos=QOS 이름 #SBATCH --nodelist=노드 리스트 #SBATCH --exclude=노드 리스트 #SBATCH --get-user-env #SBATCH --export=ALL #SBATCH --test-only #SBATCH --array=0-9 #SBATCH --priority=우선순위 #SBATCH --requeue #SBATCH --exclusive ##독점 모드 #SBATCH --account #SBATCH --dependency=[after|afterany|afterok|afternotok:&lt;jobid&gt;] 이전작업에 종속성을 설정</code></pre> <h3 data-ke-size="size23">예시 작업(1)</h3> <pre id="code_1725590265237" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ cat dep_job_01.sbatch #!/bin/bash #SBATCH --job-name=dep_job_01 #SBATCH --ntasks=1 #SBATCH --output=dep_job_01.out #SBATCH --partition=cpu.q #SBATCH --get-user-env # Run your command sleep 60 $ sbatch dep_job_01.sbatch $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 12 cpu.q dep_job_ estar987 R 0:04 1 slurm91</code></pre> <h3 data-ke-size="size23">예시 작업(2)</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>파티션 두 개 동시 설정</li> </ul> <pre id="code_1725590296737" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ cat dep_job_011.sbatch #!/bin/bash #SBATCH --job-name=dep_job_01 #SBATCH --ntasks=1 #SBATCH --output=dep_job_01.out #SBATCH --partition=cpu.q,docker.q #SBATCH --get-user-env # Run your command sleep 60 $ sbatch dep_job_01.sbatch $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 13 cpu.q dep_job_ estar987 R 0:03 1 slurm91</code></pre> <h3 data-ke-size="size23">예시 작업(3)</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>이전 작업에 종속성을 설정</li> </ul> <pre id="code_1725590321927" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ sbatch --dependency=afterok:2016 dep_job_011.sbatch Submitted batch job 14 $ sbatch --dependency=afterok:2017 dep_job_011.sbatch Submitted batch job 15 $ sbatch --dependency=afterok:2018 dep_job_011.sbatch Submitted batch job 16 $ sbatch --dependency=afterok:2019 dep_job_011.sbatch Submitted batch job 17 $ sbatch --dependency=afterok:2020 dep_job_011.sbatch Submitted batch job 18 $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 14 cpu.q dep_job_ estar987 R 0:18 1 slurm91 15 cpu.q dep_job_ estar987 R 0:12 1 slurm92 16 cpu.q dep_job_ estar987 R 0:09 1 slurm91 17 cpu.q dep_job_ estar987 R 0:06 1 slurm92 18 cpu.q dep_job_ estar987 R 0:03 1 slurm91</code></pre> <h3 data-ke-size="size23">예시 작업(4)</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Array Job 수행 방법</li> </ul> <pre id="code_1725590346553" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ cat array_job.01.sbatch #!/bin/bash #SBATCH --job-name=array_job_01 #SBATCH --ntasks=1 #SBATCH --output=array_job_01_%A_%a.out #SBATCH --partition=docker.q #SBATCH --get-user-env #SBATCH --array=1-10 #SBATCH --account=prj_estar987 # Run your command sleep 5 echo "Array Task ID: $SLURM_ARRAY_TASK_ID" $ sbatch array_job.01.sbatch $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 29_1 docker.q array_jo estar987 R 0:12 1 docker95 29_2 docker.q array_jo estar987 R 0:12 1 docker96 29_3 docker.q array_jo estar987 R 0:12 1 docker95 29_4 docker.q array_jo estar987 R 0:12 1 docker96 29_5 docker.q array_jo estar987 R 0:12 1 docker95 29_6 docker.q array_jo estar987 R 0:12 1 docker96 29_7 docker.q array_jo estar987 R 0:12 1 docker95 29_8 docker.q array_jo estar987 R 0:12 1 docker96 29_9 docker.q array_jo estar987 R 0:12 1 docker95 $ ls -1 array_job_01*.out array_job_01_29_10.out array_job_01_29_1.out array_job_01_29_2.out array_job_01_29_3.out array_job_01_29_4.out array_job_01_29_5.out array_job_01_29_6.out array_job_01_29_7.out array_job_01_29_8.out array_job_01_29_9.out array_job_01_40_10.out array_job_01_40_1.out array_job_01_40_2.out array_job_01_40_3.out array_job_01_40_4.out array_job_01_40_5.out array_job_01_40_6.out array_job_01_40_7.out array_job_01_40_8.out array_job_01_40_9.out $ cat array_job_01_40_4.out Array Task ID: 4</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>array 구문 활용 예시</li> </ul> <pre id="code_1725590374261" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>#!/bin/bash #SBATCH --job-name=array_job_01 #SBATCH --ntasks=1 #SBATCH --output=array_job_01_%A_%a.out #SBATCH --partition=docker.q #SBATCH --get-user-env #SBATCH --array=1,3,5,7,9 // 수정 #SBATCH --account=prj_estar987 # Run your command sleep 5 echo "Array Task ID: $SLURM_ARRAY_TASK_ID" $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 50_1 docker.q array_jo estar987 R 0:03 1 docker95 50_3 docker.q array_jo estar987 R 0:03 1 docker96 50_5 docker.q array_jo estar987 R 0:03 1 docker95 50_7 docker.q array_jo estar987 R 0:03 1 docker96 50_9 docker.q array_jo estar987 R 0:03 1 docker95</code></pre> <pre id="code_1725590381371" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>#!/bin/bash #SBATCH --job-name=array_job_01 #SBATCH --ntasks=1 #SBATCH --output=array_job_01_%A_%a.out #SBATCH --partition=docker.q #SBATCH --get-user-env #SBATCH --array=1-20:2 #SBATCH --account=prj_estar987 # Run your command sleep 5 echo "Array Task ID: $SLURM_ARRAY_TASK_ID" $ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 65_1 docker.q array_jo estar987 R 0:02 1 docker95 65_3 docker.q array_jo estar987 R 0:02 1 docker96 65_5 docker.q array_jo estar987 R 0:02 1 docker95 65_7 docker.q array_jo estar987 R 0:02 1 docker96 65_9 docker.q array_jo estar987 R 0:02 1 docker95 65_11 docker.q array_jo estar987 R 0:02 1 docker96 65_13 docker.q array_jo estar987 R 0:02 1 docker95 65_15 docker.q array_jo estar987 R 0:02 1 docker96 65_17 docker.q array_jo estar987 R 0:02 1 docker95 65_19 docker.q array_jo estar987 R 0:02 1 docker96</code></pre></description>
<category>HPC</category>
<category>HPC</category>
<category>Linux</category>
<category>sbatch</category>
<category>slurm</category>
<category>SuperComputing</category>
<category>리눅스</category>
<category>서버</category>
<category>슈퍼컴퓨팅</category>
<category>스케줄러</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/201</guid>
<comments>https://estar987.com/entry/SLURM-SBATCH2#entry201comment</comments>
<pubDate>Mon, 9 Sep 2024 12:00:27 +0900</pubDate>
</item>
<item>
<title>[SLURM] SBATCH(1)</title>
<link>https://estar987.com/entry/Slurm-SBATCH</link>
<description><p data-ke-size="size16">SBATCH는 사용자가 작성한 스크립트를 스케줄러를 통해 배치 방식으로 작업을 제출하고 출력 결과는 별도의 로그 파일을 통해 확인하는 방식</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">작업 제출 스크립트 작성</h3> <pre id="code_1725493513173" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ vi job_submit.sh $ cat job_submit.sh #!/bin/sh #SBATCH --job-name=job_test1 ### 작업명 #SBATCH --chdir=/home/admin/temp ### 작업디렉토리 #SBATCH --output=/home/admin/temp/job_test1.log ### 결과로그파일 #SBATCH --get-user-env ### 현재 터미널에 로드된 환경설정을 그대로 유지 #SBATCH --nodes=1 ### 작업할당 노드 수 #SBATCH --tasks-per-node=8 ### 작업할당 노드별 코어수 #SBATCH --ntasks=8 ### 작업에 할당된 전체 코어수 #SBATCH --partition=all.q ### 작업을 실행할 파티션(자원그룹) 지정 srun hostname env | grep -i -e slurm</code></pre> <h3 data-ke-size="size23">작업 제출</h3> <pre id="code_1725493529113" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ sbatch job_submit.sh Submitted batch job 52</code></pre> <h3 data-ke-size="size23">작업 로그 확인</h3> <pre id="code_1725493546393" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ cat job_test1.log /var/spool/slurmd/job00053/slurm_script: line 11: .gc/job_test1_pe_hostfile: No such file or directory /var/spool/slurmd/job00053/slurm_script: line 12: .gc/job_test1_machines: No such file or directory /var/spool/slurmd/job00053/slurm_script: line 14: .gc/job_test1_gpu_hostfile_53: No such file or directory master90 master90 master90 master90 master90 master90 master90 master90 SLURM_NODEID=0 SLURM_TASK_PID=886427 SLURM_PRIO_PROCESS=0 SLURM_SUBMIT_DIR=/home/admin SLURM_PROCID=0 SLURM_JOB_GID=1999 SLURMD_NODENAME=master90 SLURM_TASKS_PER_NODE=8 SLURM_NNODES=1 SLURM_GET_USER_ENV=1 SLURM_NTASKS_PER_NODE=8 SLURM_JOB_NODELIST=master90 SLURM_CLUSTER_NAME=gridcenter SLURM_NODELIST=master90 SLURM_NTASKS=8 SLURM_JOB_CPUS_PER_NODE=8 SLURM_TOPOLOGY_ADDR=master90 SLURM_WORKING_CLUSTER=gridcenter:192.168.207.90:6817:9728:109 SLURM_JOB_NAME=job_test1 SLURM_JOBID=53 SLURM_CONF=/engrid/enslurm/slurm/slurm.conf SLURM_NODE_ALIASES=(null) SLURM_JOB_QOS=prj_admin_qos SLURM_TOPOLOGY_ADDR_PATTERN=node SLURM_CPUS_ON_NODE=8 SLURM_JOB_NUM_NODES=1 SLURM_JOB_UID=2001 SLURM_JOB_PARTITION=all.q SCHED_TYPE=slurm SLURM_JOB_USER=admin SLURM_NPROCS=8 SLURM_SUBMIT_HOST=master90 SLURM_JOB_ACCOUNT=prj_admin SLURM_GTIDS=0 SLURM_JOB_ID=53 SLURM_LOCALID=0</code></pre> <h3 data-ke-size="size23">작업 종료</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>scancel &lt;Job id&gt;</li> </ul> <pre id="code_1725493576520" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ scancel 52</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>HPC</category>
<category>HPC</category>
<category>Linux</category>
<category>scalcel</category>
<category>slurm</category>
<category>병렬연산</category>
<category>슈퍼컴퓨팅</category>
<category>슬럼</category>
<category>작업 취소</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/200</guid>
<comments>https://estar987.com/entry/Slurm-SBATCH#entry200comment</comments>
<pubDate>Fri, 6 Sep 2024 12:00:46 +0900</pubDate>
</item>
<item>
<title>[SLURM] SRUN 명령어</title>
<link>https://estar987.com/entry/SLURM-SRUN-%EB%AA%85%EB%A0%B9%EC%96%B4</link>
<description><h3 data-ke-size="size23">SRUN</h3> <pre id="code_1725441651754" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun hostname master90</code></pre> <h3 data-ke-size="size23">ntasks 옵션(작업 개수)</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>1cpu 당 1개의 작업 돌릴 수 있음(현 구성에서는 36코어가 최대)</li> </ul> <pre id="code_1725441679709" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --ntasks=36 hostname /home/admin/.gc/hostname_gc_interactive: line 8: 159222 Segmentation fault /engrid/ensh/usrbin/jobUpdater START node92 master90 master90 master90 ...</code></pre> <h3 data-ke-size="size23">nodes 옵션(노드 수 할당)</h3> <pre id="code_1725441755489" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --nodes=3 hostname node91 node92 master90</code></pre> <h3 data-ke-size="size23">ntasks + nodes</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>12개의 작업 * 2 node</li> </ul> <pre id="code_1725441778191" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --tasks=12 --nodes=2 hostname master90 master90 master90 master90 master90 master90 master90 master90 master90 master90 master90 master90 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91</code></pre> <h3 data-ke-size="size23">nodelist</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>노드 명으로 작업 할당</li> </ul> <pre id="code_1725441792648" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --nodelist=master90,node91 --nodes=2 hostname master90 node91</code></pre> <h3 data-ke-size="size23">nodelist + ntasks</h3> <pre id="code_1725441816542" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --ntasks=14 --nodelist=node91,node92 --nodes=2 hostname node92 node92 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91</code></pre> <h3 data-ke-size="size23">task-per-node</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>노드당 CPU 할당</li> </ul> <pre id="code_1725441839966" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun --nodes=3 --tasks-per-node=3 hostname node91 node91 node91 master90 master90 master90 node92 node92 node92 $ srun --tasks-per-node=11 --nodelist=node91 hostname node91 node91 node91 node91 node91 node91 node91 node91 node91 node91 node91</code></pre> <h3 data-ke-size="size23">다수의 코어 할당 시 코어 할당 순 확인</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>&lsquo;-l&rsquo; 옵션으로 순서 보이게</li> </ul> <pre id="code_1725441866212" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun -p all.q -n 8 hostname | sort -n master90 master90 master90 master90 master90 master90 master90 master90 $ srun -l -p all.q -n 8 hostname | sort -n 0: master90 1: master90 2: master90 3: master90 4: master90 5: master90 6: master90 7: master90 $ srun -l -p all.q -n 24 hostname | sort -n 0: master90 1: master90 2: master90 3: master90 4: master90 5: master90 6: master90 7: master90 8: master90 9: master90 10: master90 11: master90 12: node91 13: node91 14: node91 15: node91 16: node91 17: node91 18: node91 19: node91 20: node91 21: node91 22: node91 23: node91</code></pre> <h3 data-ke-size="size23">1대 서버 최대 코어수 이상의 코어 요청 시</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>다음 노드로 작업이 넘어간다.</li> </ul> <pre id="code_1725441894189" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun -l -p all.q -n 14 hostname | sort -n 0: master90 1: master90 2: master90 3: master90 4: master90 5: master90 6: master90 7: master90 8: master90 9: master90 10: master90 11: master90 12: node91 13: node91</code></pre> <h3 data-ke-size="size23">distrubution=plane</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>특정 노드에 부하가 걸리지 않도록 노드에 할당된 TASK의 수에 따라 구분</li> </ul> <pre id="code_1725441924643" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun -l -n 36 --distribution=plane=4 hostname | sort -n 0: master90 1: master90 2: master90 3: master90 4: node91 5: node91 6: node91 7: node91 8: node92 9: node92 10: node92 11: node92 12: master90 13: master90 14: master90 15: master90 16: node91 17: node91 18: node91 19: node91 20: node92 21: node92 22: node92 23: node92 24: master90 25: master90 26: master90 27: master90 28: node91 29: node91 30: node91 31: node91 32: node92 33: node92 34: node92 35: node92 $ srun -l -n 12 --distribution=plane=4 hostname | sort -n 0: slurm-node01 1: slurm-node01 2: slurm-node01 3: slurm-node01 4: slurm-node02 5: slurm-node02 6: slurm-node02 7: slurm-node02 8: slurm-node01 9: slurm-node01 10: slurm-node01 11: slurm-node01</code></pre> <h3 data-ke-size="size23">spread-job</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>균등하게 작업 분배</li> </ul> <pre id="code_1725441945637" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ srun -l -n 18 --spread-job hostname | sort -n 0: master90 1: master90 2: master90 3: master90 4: master90 5: master90 6: master90 7: master90 8: master90 9: master90 10: master90 11: node91 12: node91 13: node91 14: node91 15: node91 16: node91 17: node92</code></pre></description>
<category>HPC</category>
<category>HPC</category>
<category>Linux</category>
<category>slurm</category>
<category>srun</category>
<category>병렬 연산</category>
<category>슈퍼컴퓨터</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/199</guid>
<comments>https://estar987.com/entry/SLURM-SRUN-%EB%AA%85%EB%A0%B9%EC%96%B4#entry199comment</comments>
<pubDate>Thu, 5 Sep 2024 12:00:16 +0900</pubDate>
</item>
<item>
<title>[Ubuntu] SGE 설치</title>
<link>https://estar987.com/entry/Ubuntu-SGE-%EC%84%A4%EC%B9%98</link>
<description><h3 data-ke-size="size23">패키지 설치</h3> <pre id="code_1725267690552" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt install -y vim ssh git build-essential libhwloc-dev libssl-dev libtirpc-dev \ libmotif-dev libxext-dev libncurses-dev libdb5.3-dev libpam0g-dev pkgconf \ libsystemd-dev cmake gcc default-jdk qtchooser make gcc default-jdk qtchooser \ make gcc default-jdk qtchooser csh # gcc --version # make --version</code></pre> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">사전 준비</h3> <pre id="code_1725267703636" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># groupadd -g 490 sgeadmin # useradd -u 495 -g 490 -r -m -d /home/sgeadmin -s /bin/bash -c "SGE Admin" sgeadmin # visudo # Members of the admin group may gain root privileges %admin ALL=(ALL) ALL %sgeadmin ALL=(ALL) NOPASSWD:ALL //추가 ctrl + x 로 나가기 # vim /etc/hosts 192.168.207.30 master-ubuntu-sge 192.168.207.31 node01-ubuntu-sge ...</code></pre> <h3 data-ke-size="size23">빌드</h3> <pre id="code_1725267727745" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># wget https://github.com/daimh/sge/archive/refs/tags/8.1.9.tar.gz # tar zvxf 8.1.9.tar.gz # export SGE_ROOT=/opt/sge # export SGE_CELL=default # mkdir -p $SGE_ROOT # cd /APP/enhpc/sge-8.1.9/source !! 주석 처리 # vim 3rdparty/qtcsh/sh.proc.c 51 //# define BSDWAIT # sh scripts/bootstrap.sh -no-java -no-jni # ./aimk -no-java -no-jni -no-secure # echo Y | ./scripts/distinst -local -allall -libs -noexit # ln -s /usr/bin/qmake /opt/sge/bin/lx-amd64/qmake # chown -R sgeadmin: $SGE_ROOT</code></pre> <h3 data-ke-size="size23">설치</h3> <pre id="code_1725267757906" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># cd $SGE_ROOT # chmod -t /tmp # ./install_qmaster</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Cluster Name 설징 외에는 전부 default 값으로 설정(Enter)</li> </ul> <pre id="code_1725267790329" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>Unique cluster name ------------------- The cluster name uniquely identifies a specific Sun Grid Engine cluster. The cluster name must be unique throughout your organization. The name is not related to the SGE cell. The cluster name must start with a letter ([A-Za-z]), followed by letters, digits ([0-9]), dashes (-) or underscores (_). Enter new cluster name or hit &lt;RETURN&gt; to use default [p6444] &gt;&gt; estar987</code></pre> <pre id="code_1725267811085" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>./install_execd chmod +t /tmp cd ~ source /opt/sge/default/common/settings.sh # qconf -mconf 수정 ... min_uid 0 min_gid 0 # qconf -as $HOSTNAME master-ubuntu-sge added to submit host list # echo &ldquo;sleep 20&rdquo; | qsub # qstat -f queuename qtype resv/used/tot. load_avg arch states --------------------------------------------------------------------------------- all.q@master-ubuntu-sge BIP 0/0/12 2.33 lx-amd64</code></pre> <h3 data-ke-size="size23">SGE 를 기본 스케줄러로 사용하기(.bashrc 등록)</h3> <pre id="code_1725267856500" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi .bashrc source /opt/sge/default/common/settings.sh //추가 # source .bashrc</code></pre> <pre id="code_1725267889328" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi /etc/exports /opt/sge *(rw,no_root_squash) // 추가 systemctl restart nfs-server.service systemctl restart sgemaster.service systemctl restart sgemaster.service # qconf -ah node01-ubuntu-sge node01-ubuntu-sge added to administrative host list</code></pre> <h3 data-ke-size="size23">증설 노드에서 작업</h3> <pre id="code_1725267906136" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt install -y libhwloc-dev nfs-client qtchooser # vim /etc/hosts 192.168.207.30 master-ubuntu-sge 192.168.207.31 node01-ubuntu-sge # groupadd -g 490 sgeadmin # useradd -u 495 -g 490 -r -m -d /home/sgeadmin -s /bin/bash -c "SGE Admin" sgeadmin # systemctl restart nfs-utils.service # mkdir -p /opt/sge # export SGE_ROOT=/opt/sge # export SGE_CELL=default # mkdir $SGE_ROOT # mount -t nfs master-ubuntu-sge:/opt/sge /opt/sge # df (확인) # vim /etc/fstab master-ubuntu-sge:/opt/sge /opt/sge nfs rw,soft,bg,vers=3 0 0 // 추가 # cd $SGE_ROOT # ./install_execd 모두 default</code></pre> <h3 data-ke-size="size23">마스터에서 확인</h3> <pre id="code_1725267922077" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># qstat -f queuename qtype resv/used/tot. load_avg arch states --------------------------------------------------------------------------------- all.q@master-ubuntu-sge BIP 0/0/12 1.17 lx-amd64 --------------------------------------------------------------------------------- all.q@node01-ubuntu-sge BIP 0/0/12 3.12 lx-amd64</code></pre></description>
<category>HPC</category>
<category>HPC</category>
<category>Linux</category>
<category>SGE</category>
<category>병렬 연산</category>
<category>슈퍼 컴퓨팅</category>
<category>스케줄러</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/198</guid>
<comments>https://estar987.com/entry/Ubuntu-SGE-%EC%84%A4%EC%B9%98#entry198comment</comments>
<pubDate>Tue, 3 Sep 2024 12:00:56 +0900</pubDate>
</item>
<item>
<title>[Ubuntu] PostgreSQL 수동 설치</title>
<link>https://estar987.com/entry/Ubuntu-PostgreSQL-%EC%88%98%EB%8F%99-%EC%84%A4%EC%B9%98</link>
<description><p data-ke-size="size16">컴파일 등에 필요한 기본 패키지들은 구성이 되있다고 가정하고 진행하겠다.</p> <h3 data-ke-size="size23">PostgreSQL 파일 설치</h3> <pre id="code_1724805876882" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>wget http://ftp.postgresql.org/pub/source/v12.1/postgresql-12.1.tar.gz tar zxvf postgresql-12.1.tar.gz cd postgresql-12.1 mkdir -p /APP/postgresql/data</code></pre> <h3 data-ke-size="size23">소스 컴파일 및 설치</h3> <pre id="code_1724805887806" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>./configure --prefix=/APP/postgresql --with-python --without-python --without-readline make &amp;&amp; make install</code></pre> <h3 data-ke-size="size23">Database Cluster 생성</h3> <pre id="code_1724805902116" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>cd /APP/postgresql/bin ./initdb -E utf-8 /APP/postgresql/data/ --&gt; 루트로 실행되지 않음 sudo chown -R estar /APP/postgresql/data $ ./initdb -E utf-8 /APP/postgresql/data/</code></pre> <h3 data-ke-size="size23">log 파일 생성</h3> <pre id="code_1724805916044" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ sudo mkdir /APP/postgresql/logs $ sudo chown estar /APP/postgresql/logs $ ./pg_ctl -D /APP/postgresql/data_new/ -l /APP/postgresql/logs/logfile start</code></pre> <h3 data-ke-size="size23">확인</h3> <pre id="code_1724805931963" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ netstat -tupln | grep 5432 (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) tcp 0 0 127.0.0.1:5432 0.0.0.0:* LISTEN 274993/postgres tcp6 0 0 ::1:5432 :::* LISTEN 274993/postgres</code></pre></description>
<category>Linux</category>
<category>Compile</category>
<category>Database</category>
<category>db</category>
<category>Linux</category>
<category>Postgre</category>
<category>PostgreSQL</category>
<category>rocky</category>
<category>ubuntu</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/197</guid>
<comments>https://estar987.com/entry/Ubuntu-PostgreSQL-%EC%88%98%EB%8F%99-%EC%84%A4%EC%B9%98#entry197comment</comments>
<pubDate>Wed, 28 Aug 2024 12:00:05 +0900</pubDate>
</item>
<item>
<title>[Kubernetes]CrashLoopBackOff 장애</title>
<link>https://estar987.com/entry/KubernetesCrashLoopBackOff-%EC%9E%A5%EC%95%A0</link>
<description><p data-ke-size="size16">컨테이너가 생성되자마자 바로 종료되어 CrashLoopBackOff 상태가 발생합니다. 따라서 yaml 코드에 slepp 구문을 추가합니다.</p> <pre id="code_1723507667247" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>kubectl run temp-pod1 --image=debian:10 --dry-run=client -o yaml &gt; temp-pod1.yaml vi temp-pod1.yaml apiVersion: v1 kind: Pod metadata: name: temp-pod1 spec: volumes: - name: temp-vol emptyDir: {} containers: - image: ubuntu:14.04 name: temp-container1 volumeMounts: - name: temp-vol mountPath: /mount1 - image: ubuntu:14.04 name: temp-container2 volumeMounts: - name: temp-vol mountPath: /mount2 # k apply -f temp-pod1.yaml pod/temp-pod1 created # k get po -o wide | grep temp temp-pod1 0/2 CrashLoopBackOff 2 (12s ago) 14s 10.97.125.28 k8s-node01 &lt;none&gt; &lt;none&gt;</code></pre> <p data-ke-size="size16">&nbsp;</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>위와 같이 CrashBackOff 오류 발생</li> <li>파드 살제 후 sleep 문구 추가 하여 재생</li> </ul> <pre id="code_1723507769026" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># k delete po temp-pod1 pod "temp-pod1" deleted # cat temp-pod1.yaml apiVersion: v1 kind: Pod metadata: name: temp-pod1 spec: volumes: - name: temp-vol emptyDir: {} containers: - image: ubuntu:14.04 name: temp-container1 volumeMounts: - name: temp-vol mountPath: /mount1 command: ["sleep", "3600"] - image: ubuntu:14.04 name: temp-container2 volumeMounts: - name: temp-vol mountPath: /mount2 command: ["sleep", "3600"] # k apply -f temp-pod1.yaml pod/temp-pod1 created # k get po -o wide | grep temp temp-pod1 2/2 Running 0 13s 10.97.125.29 k8s-node01 &lt;none&gt; &lt;none&gt;</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>docker</category>
<category>fastcampus</category>
<category>kubernetes</category>
<category>Linux</category>
<category>Troubleshooting</category>
<category>엔지니어</category>
<category>컨테이너</category>
<category>쿠버네티스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/196</guid>
<comments>https://estar987.com/entry/KubernetesCrashLoopBackOff-%EC%9E%A5%EC%95%A0#entry196comment</comments>
<pubDate>Tue, 13 Aug 2024 12:00:02 +0900</pubDate>
</item>
<item>
<title>[Ubuntu]Kubernetes cluster Node 확장 (add node)</title>
<link>https://estar987.com/entry/UbuntuKubernetes-cluster-Node-%ED%99%95%EC%9E%A5-add-node</link>
<description><pre id="code_1723085988722" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubectl get nodes # kubectl describe nodes k8s-master</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">사전에 준비한 k8s-node3을 부팅하고 아래 내용을 점검한다.</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>IP 주소 (192.168.207.203)</li> <li>Hostname 변경</li> <li>/etc/hosts의 127.0.1.1의 hostname 변경</li> <li>containerd 및 kubelet 서비스 restart</li> <li>free (swapoff 확인)</li> <li>root@k8s-node3:~# cat /proc/sys/net/ipv4/ip_forward 1 확인</li> <li>ssh 접속 테스트</li> </ol> <p data-ke-size="size16">이전에 포스팅한 글들을 참고하여 작업하면 된다.</p> <p data-ke-size="size16"><a href="https://estar987.tistory.com/192" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/192</a></p> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">node join을 위한 token 확인 및 재생성(Master)</h4> <p data-ke-size="size16">node join을 위한 token 확인 및 재생성</p> <p data-ke-size="size16">출력되는 값을 참고하여 아래 증설 노드에서 입력후 클러스터 가입</p> <pre id="code_1723086112787" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>master # kubeadm token list master # kubeadm token create --ttl 0 --print-join-command // 영구적 master # kubeadm token create --print-join-command</code></pre> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">증설 노드에서 토큰값을 활용하여 클러스터에 가입(Node03)</h4> <pre id="code_1723086150362" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>node03 # kubeadm join 192.168.56.100:6443 --token y2ocme.k38xr8vq4qtow66t -- discovery-token-ca-cert-hash \ sha256:e0c59604e0a5f9c212a8f9da1bea8306f472904330aceaa44b42d225e8f53fa2</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">확인(master)</p> <pre id="code_1723086178711" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>master # kubectl get no master # kubectl get po -A</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>DevOps</category>
<category>docker</category>
<category>kubernetes</category>
<category>Linux</category>
<category>데브옵스</category>
<category>도커</category>
<category>리눅스</category>
<category>증설</category>
<category>쿠버네티스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/195</guid>
<comments>https://estar987.com/entry/UbuntuKubernetes-cluster-Node-%ED%99%95%EC%9E%A5-add-node#entry195comment</comments>
<pubDate>Mon, 12 Aug 2024 12:00:28 +0900</pubDate>
</item>
<item>
<title>[ubuntu] CNI(Container Network Interface) Plugin 구성</title>
<link>https://estar987.com/entry/ubuntu-CNIContainer-Network-Interface-Plugin-%EA%B5%AC%EC%84%B1</link>
<description><p data-ke-size="size16"><a href="https://estar987.tistory.com/193" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/193</a></p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">이전의 포스팅한 내용과 이어지는 내용입니다.</p> <p data-ke-size="size16">&nbsp;</p> <h2 data-ke-size="size26">CNI(Container&nbsp;Network&nbsp;Interface)</h2> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>CNI는 컨테이너 간의 네트워킹을 제어할 수 있는 Plugin을 만들기 위한 표준</li> <li>다양한 형태의 컨테이너 런타임과 오케스트레이터 사이의 네트워크 계층을 구현하는 방식이 다양하게 분리되어 각자만의 방식으로 발전하게 되는 것을 방지하고 공통된 인터페이스를 제공. K8S는 Pod간의 통신을 위해서 CNI를 사용</li> <li>k8s는 기본적으로 kubenet이라는 자체적인 CNI plugin을 제공하지만 네트워크 기능이 매우 제한적임</li> <li>그 단점을 보완하기 위해서 3rd-party Plugin 제공(Flannel, Calico, Weavenet...)</li> </ul> <h3 data-ke-size="size23">CNI 필요성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>각 노드에서 존재하는 container network의 IP 대역이 동일하여 Pod들이 같은 IP를 할당 받을 가능성이 높음</li> <li>Pod의 IP가 드르게 할당되었다 하더라도 해당 Pod가 어느 노드에 존재하는지 확인 불가</li> <li>중복되니 않는 IP를 부여해줄 역할을 CNI Plugin 수행</li> </ul> <h3 data-ke-size="size23">Kubernetes Cluster init</h3> <pre id="code_1723085434054" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>curl -O https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml kubectl apply -f calico.yaml</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">calico가 올라오면 pending 상태였던 DNS가 작동한다.</p> <pre id="code_1723085589258" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># k get po -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system calico-kube-controllers-658d97c59c-jk6ww 1/1 Running 0 3m1s kube-system calico-node-db9hq 0/1 Running 0 3m1s kube-system calico-node-fh2dw 0/1 Running 0 3m1s kube-system calico-node-nqlq4 0/1 Running 0 3m1s kube-system calico-node-spgfh 0/1 Running 0 3m1s kube-system coredns-5dd5756b68-jxs6r 1/1 Running 0 50m kube-system coredns-5dd5756b68-k9hhp 1/1 Running 0 50m kube-system etcd-k8s-master 1/1 Running 0 51m kube-system kube-apiserver-k8s-master 1/1 Running 0 51m kube-system kube-controller-manager-k8s-master 1/1 Running 0 51m kube-system kube-proxy-4s2fc 1/1 Running 0 50m kube-system kube-proxy-5xjg2 1/1 Running 0 26m kube-system kube-proxy-bcdpd 1/1 Running 0 26m kube-system kube-proxy-bgrwl 1/1 Running 0 26m kube-system kube-scheduler-k8s-master 1/1 Running 0 51m</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">Ready 상태로 변경됨</p> <pre id="code_1723085619655" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubectl get no NAME STATUS ROLES AGE VERSION k8s-master Ready control-plane 51m v1.28.12 k8s-node01 Ready &lt;none&gt; 27m v1.28.12 k8s-node02 Ready &lt;none&gt; 27m v1.28.12 k8s-node03 Ready &lt;none&gt; 27m v1.28.12</code></pre> <p data-ke-size="size16">&nbsp;</p></description>
<category>DevOps</category>
<category>CNI</category>
<category>Container</category>
<category>DevOps</category>
<category>docker</category>
<category>kubernetes</category>
<category>Linux</category>
<category>데브옵스</category>
<category>도커</category>
<category>컨테이너</category>
<category>쿠버네티스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/194</guid>
<comments>https://estar987.com/entry/ubuntu-CNIContainer-Network-Interface-Plugin-%EA%B5%AC%EC%84%B1#entry194comment</comments>
<pubDate>Fri, 9 Aug 2024 12:03:21 +0900</pubDate>
</item>
<item>
<title>[Ubuntu]Kubernetes 구성</title>
<link>https://estar987.com/entry/Kubernetes-%EA%B5%AC%EC%84%B1</link>
<description><h3 data-ke-size="size23">kubernetes Tools 설치</h3> <p data-ke-size="size16">kubernetes 도구 설치 (1.28)</p> <pre id="code_1723083613662" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg # echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list # apt update # apt-cache policy kubeadm kubeadm: Installed: (none) Candidate: 1.28.0-1.1 Version table: 1.28.0-1.1 500 500 https://pkgs.k8s.io/core:/stable:/v1.28/deb Packages # apt -y install kubelet kubeadm kubectl</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">kubernetes 도구 버전 확인</p> <pre id="code_1723083706204" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubeadm version kubeadm version: &amp;version.Info{Major:"1", Minor:"28", GitVersion:"v1.28.5", GitCommit:"bae2c62678db2b5053817bc97181fcc2e8388103", GitTreeState:"clean", BuildDate:"2023-11-15T16:56:18Z", GoVersion:"go1.20.11", Compiler:"gc", Platform:"linux/amd64"}</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">설치된 Kubernetes tool이 자동으로 업데이트 되는 것을 방지해야 하므로 hold 시킨다</p> <pre id="code_1723083726059" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt-mark hold kubelet kubeadm kubectl kubelet set on hold. kubeadm set on hold. kubectl set on hold.</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">모든 노드에 설치되는 kubelet은 항상 start 상태를 유지해야 하므로 데몬은 enable 시켜준다.</p> <pre id="code_1723083753656" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># systemctl daemon-reload # systemctl restart kubelet.service # systemctl enable --now kubelet.service</code></pre> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">클러스터 구축(마스터 노드)</h3> <pre id="code_1723083784144" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># kubeadm init --pod-network-cidr=10.96.0.0/12 --apiserver-advertise-address=192.168.207.201</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">설치 로그가 쭉 나오고 설치가 완료되면 아래와 같은 문구를 확인 할 수 있다. 쓰여있는데로 복사 붙여넣기하면 된다.</p> <pre id="code_1723083845298" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.207.200:6443 --token k4bbtb.aar38u8oafx7m4u0 \ --discovery-token-ca-cert-hash sha256:45bb08d1c86f8e5ebec7ef8c30d0ebaa647b145568f77e4dc77d0e76dc9521d3</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">위에 로그에 메뉴얼 나옴(마스터노드)</p> <pre id="code_1723083877102" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># mkdir -p $HOME/.kube # sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config # sudo chown $(id -u):$(id -g) $HOME/.kube/config # export KUBECONFIG=/etc/kubernetes/admin.conf // 루트 계정에서 적용</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">명령어를 편하게 쓰기 위해 추가 설정(마스터 노드) 해준다.&nbsp;</p> <pre id="code_1723083931957" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>apt install bash-completion -y source &lt;(kubectl completion bash) echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc complete -F __start_kubectl k vi .bashrc ''' # for examples alias k=kubectl alias kg='kubectl get' alias kc='kubectl create' alias ka='kubectl apply' alias kr='kubectl run' alias kd='kubectl delete' complete -F __start_kubectl k ''' source .bashrc</code></pre> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">클러스터 가입(자식 노드)</h3> <pre id="code_1723083982616" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>kubeadm join 192.168.207.200:6443 --token k4bbtb.aar38u8oafx7m4u0 \ --discovery-token-ca-cert-hash sha256:45bb08d1c86f8e5ebec7ef8c30d0ebaa647b145568f77e4dc77d0e76dc9521d3</code></pre> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20">마스터 노드에서 확인</h4> <pre id="code_1723084299774" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>root@k8s-master:~# k get no NAME STATUS ROLES AGE VERSION k8s-master NotReady control-plane 29m v1.28.12 k8s-node01 NotReady &lt;none&gt; 5m9s v1.28.12 k8s-node02 NotReady &lt;none&gt; 5m10s v1.28.12 k8s-node03 NotReady &lt;none&gt; 5m9s v1.28.12</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">클러스터 구성을 끝냈고 현재 k get nodes 를 하면 STATUS에서 NotReady 상태이다. 다음 포스팅에서는 Kubernetes DNS 설정을 포스팅 하도록 하겠다.</p> <p data-ke-size="size16"><a href="https://estar987.tistory.com/194" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/194</a></p></description>
<category>DevOps</category>
<category>DevOps</category>
<category>docker</category>
<category>kubernetes</category>
<category>Linux</category>
<category>데브옵스</category>
<category>도커</category>
<category>리눅스</category>
<category>쿠버네티스</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/193</guid>
<comments>https://estar987.com/entry/Kubernetes-%EA%B5%AC%EC%84%B1#entry193comment</comments>
<pubDate>Fri, 9 Aug 2024 12:01:43 +0900</pubDate>
</item>
<item>
<title>[Ubuntu]K8s를 위한 VM 환경 구성(Docker Install)</title>
<link>https://estar987.com/entry/UbuntuK8s%EB%A5%BC-%EC%9C%84%ED%95%9C-VM-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1Docker-Install</link>
<description><h3 data-ke-size="size23">1. OS 설치 후 기본 설정</h3> <p data-ke-size="size16">아래 설정은 모든 노드들에서 작업한다.</p> <h4 data-ke-size="size20">패키지 설치</h4> <pre id="code_1723082655005" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>$ sudo apt -y update $ sudo passwd root $ su - # apt -y install openssh-server vim net-tools</code></pre> <h4 data-ke-size="size20">ssh 설정</h4> <pre id="code_1723082671205" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi /etc/ssh/sshd_config 34 PermitRootLogin yes // yes로 변경 58 PasswordAuthentication yes // 주석해제 # systemctl restart sshd</code></pre> <p data-ke-size="size16"><a href="https://estar987.tistory.com/135" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/135</a></p> <figure id="og_1723082582817" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="[Ubuntu] HPC 설정" data-og-description="Ubuntu에서 HPC 세팅하기서버 구성&nbsp;masterubuntu : 192.168.207.80 node01ubuntu : 192.168.207.81 node02ubuntu : 192.168.207.82&nbsp;OSOS : ubuntu-20.04.4호스트 설정호스트 네임 설정# hostnamectl set-hostname --static masterubuntu노드 간 " data-og-host="estar987.com" data-og-source-url="https://estar987.tistory.com/135" data-og-url="https://estar987.com/135" data-og-image="https://scrap.kakaocdn.net/dn/btxl7d/hyWKB3BR4D/jG9H7ZAVrW0onFbHKJfmKK/img.jpg?width=800&amp;height=800&amp;face=218_380_426_607,https://scrap.kakaocdn.net/dn/OPLdQ/hyWKAcxmkF/ZS7QXBc3F8ARy2ctCiHOsK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800"><a href="https://estar987.tistory.com/135" target="_blank" rel="noopener" data-source-url="https://estar987.tistory.com/135"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/btxl7d/hyWKB3BR4D/jG9H7ZAVrW0onFbHKJfmKK/img.jpg?width=800&amp;height=800&amp;face=218_380_426_607,https://scrap.kakaocdn.net/dn/OPLdQ/hyWKAcxmkF/ZS7QXBc3F8ARy2ctCiHOsK/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">[Ubuntu] HPC 설정</p> <p class="og-desc" data-ke-size="size16">Ubuntu에서 HPC 세팅하기서버 구성&nbsp;masterubuntu : 192.168.207.80 node01ubuntu : 192.168.207.81 node02ubuntu : 192.168.207.82&nbsp;OSOS : ubuntu-20.04.4호스트 설정호스트 네임 설정# hostnamectl set-hostname --static masterubuntu노드 간</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <p data-ke-size="size16">이전에 포스팅 한 글을 토대로 Hostname을 이용해 별도의 인증 없이 노드간 ssh 접근이 가능하도록 setting 한다.</p> <h3 data-ke-size="size23">2. k8s 구성을 위한 사전 설정</h3> <h4 data-ke-size="size20">방화벽 해제</h4> <pre id="code_1723082793448" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ufw disable</code></pre> <h4 data-ke-size="size20">swap 해제</h4> <pre id="code_1723082816139" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># swapoff -a # free total used free shared buff/cache available Mem: 4017752 1124056 137528 8236 2756168 2647400 Swap: 0 0 0 # sed -i '/ swap / s/^/#/' /etc/fstab 혹은 # vi /etc/fstab #/swapfile (swap 설정 주석 처리)</code></pre> <h4 data-ke-size="size20">NTP 시간 동기화</h4> <pre id="code_1723082855390" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt -y install ntp # systemctl restart ntp # systemctl status ntp # ntpq -p # date</code></pre> <h4 data-ke-size="size20">IP 포워딩 활성화</h4> <p data-ke-size="size16">네트워크 패킷을 올바르게 포워딩하기 위해 커널에서 IP 포워딩을 활성화 시켜야 함</p> <pre id="code_1723082907579" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># echo '1' &gt; /proc/sys/net/ipv4/ip_forward # cat /proc/sys/net/ipv4/ip_forward 1</code></pre> <h4 data-ke-size="size20">contianerd 를 이용한 container runtime 구성</h4> <pre id="code_1723082922913" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf overlay br_netfilter EOF</code></pre> <h4 data-ke-size="size20">커널에 모듈 적용</h4> <p data-ke-size="size16">modprobe 프로그램은 요청된 모듈이 동작할 수 있도록 부수적인 모듈을 depmod 프로그램을 이용하여 검색해 필요한 모듈을 커널에 차례로 등록한다.</p> <pre id="code_1723082945076" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># modprobe overlay # modprobe br_netfilter</code></pre> <h4 data-ke-size="size20">bridge 설정 추가</h4> <p data-ke-size="size16">노드간 통신을 위한 iptables 에 브릿지 관련 설정 추가</p> <pre id="code_1723082964504" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-ip6tables = 1 EOF # cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF # cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF # sysctl --system</code></pre> <h4 data-ke-size="size20">Docker 설치</h4> <p data-ke-size="size16">k8s runtime 준비 &rarr; contianerd, docker, CRI-O 중에 선택이고, 여기서는 contianerd 사용</p> <p data-ke-size="size16">apt가 HTTPS로 리포지터리를 사용하는 것을 허용하기 위한 패키지 및 docker에 필요한 패키지 설치</p> <pre id="code_1723083051838" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt-get update &amp;&amp; apt-get install -y apt-transport-https ca-certificates curl \ software-properties-common gnupg2</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">도커 공식 GPG 키 추가 (<a href="https://docs.docker.com/engine/install/ubuntu/)">https://docs.docker.com/engine/install/ubuntu/)</a></p> <pre id="code_1723083087027" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># install -m 0755 -d /etc/apt/keyrings # curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg \ --dearmor -o /etc/apt/keyrings/docker.gpg # chmod a+r /etc/apt/keyrings/docker.gpg # echo \ "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \ https://download.docker.com/linux/ubuntu \ $(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | \ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null # apt-get update</code></pre> <p data-ke-size="size16">&nbsp;</p> <h4 data-ke-size="size20"><b>Docker Runtime 주의!</b></h4> <p data-ke-size="size16">Docker와 containerd가 모두 감지되면 Docker가 우선합니다. 이는 Docker 18.09부터 containerd와 함께 제공되고 Docker만 설치한 경우에도 둘 다 감지할 수 있기 때문에 필요합니다. 다른 두 개 이상의 런타임이 감지되면 kubeadm은 오류와 함께 종료됩니다.</p> <p data-ke-size="size16">아래는 docker는 image 개발 및 테스트 용도이고, 주 container runtime은 "containerd"를 사용 한다</p> <h4 data-ke-size="size20">데몬 설정</h4> <p data-ke-size="size16">docker-ce version 확인</p> <pre id="code_1723083164856" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt-cache policy docker-ce</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">docker-ce와 관련 도구 및 containerd 설치</p> <pre id="code_1723083183159" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># apt-get -y install docker-ce docker-ce-cli containerd.io \ docker-buildx-plugin docker-compose-plugin # docker version</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">containerd 설정</p> <pre id="code_1723083210610" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># sh -c "containerd config default &gt; /etc/containerd/config.toml" # vi /etc/containerd/config.toml disabled_plugins = [] --&gt; [] CRI 제거 확인 # sed -i 's/ SystemdCgroup = false/ SystemdCgroup = true/' /etc/containerd/config.toml # systemctl restart containerd.service</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">docker daemon 설정</p> <pre id="code_1723083240128" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi /etc/docker/daemon.json { "exec-opts": ["native.cgroupdriver=systemd"], "log-driver": "json-file", "log-opts": { "max-size": "100m" }, "storage-driver": "overlay2" }</code></pre> <pre id="code_1723083248937" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>mkdir -p /etc/systemd/system/docker.service.d usermod -aG docker estar systemctl daemon-reload systemctl enable docker systemctl restart docker systemctl status docker</code></pre> <pre id="code_1723083266566" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>systemctl restart containerd.service systemctl status containerd.service reboot # docker version # docker info Cgroup Driver: systemd --&gt; 확인</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">쿠버네티스 구성을 위한 도커 설치까지의 과정입니다.&nbsp;</p> <p data-ke-size="size16">이후 쿠버네티스 구성 과정을 포스팅하겠습니다.</p> <p data-ke-size="size16"><a href="https://estar987.tistory.com/193" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/193</a></p></description>
<category>DevOps</category>
<category>DevOps</category>
<category>docker</category>
<category>kubernetes</category>
<category>Linux</category>
<category>rockylinux</category>
<category>ubuntu</category>
<category>데브옵스</category>
<category>도커</category>
<category>쿠버</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/192</guid>
<comments>https://estar987.com/entry/UbuntuK8s%EB%A5%BC-%EC%9C%84%ED%95%9C-VM-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1Docker-Install#entry192comment</comments>
<pubDate>Fri, 9 Aug 2024 12:00:35 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] MIG(Multi-Instance-GPU) Docker 컨테이너에 할당</title>
<link>https://estar987.com/entry/NVIDIA-MIGMulti-Instance-GPU-Docker-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90-%ED%95%A0%EB%8B%B9</link>
<description><h3 data-ke-size="size23">1. MIG 활성화</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인(비활성화 되어 있음)</li> </ul> <pre id="code_1722408665865" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Wed Jul 31 10:57:26 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.90.07 Driver Version: 550.90.07 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 80GB HBM3 Off | 00000000:19:00.0 Off | 0 | | N/A 37C P0 115W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 1 NVIDIA H100 80GB HBM3 Off | 00000000:2D:00.0 Off | 0 | | N/A 39C P0 115W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 2 NVIDIA H100 80GB HBM3 Off | 00000000:3F:00.0 Off | 0 | | N/A 39C P0 116W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 3 NVIDIA H100 80GB HBM3 Off | 00000000:66:00.0 Off | 0 | | N/A 37C P0 118W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 4 NVIDIA H100 80GB HBM3 Off | 00000000:9B:00.0 Off | 0 | | N/A 36C P0 116W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 5 NVIDIA H100 80GB HBM3 Off | 00000000:AE:00.0 Off | 0 | | N/A 41C P0 128W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 6 NVIDIA H100 80GB HBM3 Off | 00000000:BF:00.0 Off | 0 | | N/A 40C P0 123W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 7 NVIDIA H100 80GB HBM3 Off | 00000000:E4:00.0 Off | 0 | | N/A 37C P0 116W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>2번GPU MIG 활성화 후 활성화 확인</li> </ul> <pre id="code_1722408718179" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -i 2 -mig 1 # nvidia-smi Wed Jul 31 10:58:40 2024 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 550.90.07 Driver Version: 550.90.07 CUDA Version: 12.4 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+========================+======================| | 0 NVIDIA H100 80GB HBM3 Off | 00000000:19:00.0 Off | 0 | | N/A 37C P0 115W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 1 NVIDIA H100 80GB HBM3 Off | 00000000:2D:00.0 Off | On | | N/A 38C P0 115W / 700W | 1MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ | 2 NVIDIA H100 80GB HBM3 Off | 00000000:3F:00.0 Off | On | | N/A 39C P0 116W / 700W | 1MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ | 3 NVIDIA H100 80GB HBM3 Off | 00000000:66:00.0 Off | On | | N/A 37C P0 118W / 700W | 1MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ | 4 NVIDIA H100 80GB HBM3 Off | 00000000:9B:00.0 Off | On | | N/A 36C P0 115W / 700W | 1MiB / 81559MiB | N/A Default | | | | Enabled | +-----------------------------------------+------------------------+----------------------+ | 5 NVIDIA H100 80GB HBM3 Off | 00000000:AE:00.0 Off | 0 | | N/A 40C P0 127W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 6 NVIDIA H100 80GB HBM3 Off | 00000000:BF:00.0 Off | 0 | | N/A 40C P0 123W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ | 7 NVIDIA H100 80GB HBM3 Off | 00000000:E4:00.0 Off | 0 | | N/A 37C P0 115W / 700W | 1MiB / 81559MiB | 0% Default | | | | Disabled | +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | No MIG devices found | +-----------------------------------------------------------------------------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | No running processes found | +-----------------------------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">2. MIG GI, CI 생성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>2.1 GI 생성</li> </ul> <pre id="code_1722408755337" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 2 -cgi 5,9 Successfully created GPU instance ID 1 on GPU 2 using profile MIG 4g.40gb (ID 5) Successfully created GPU instance ID 2 on GPU 2 using profile MIG 3g.40gb (ID 9) # nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 2 MIG 3g.40gb 9 2 4:4 | +-------------------------------------------------------+ | 2 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>2.2 CI 생성</li> </ul> <pre id="code_1722408776475" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 2 -cci -gi 2,1 Successfully created compute instance ID 0 on GPU 2 GPU instance ID 2 using profile MIG 3g.40gb (ID 2) Successfully created compute instance ID 0 on GPU 2 GPU instance ID 1 using profile MIG 4g.40gb (ID 3) # nvidia-smi mig -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 2 2 MIG 3g.40gb 2 0 0:4 | +--------------------------------------------------------------------+ | 2 1 MIG 4g.40gb 3 0 0:4 | +--------------------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>2.3 MIG 생성 확인</li> </ul> <pre id="code_1722408820530" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi ... +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 2 1 0 0 | 51MiB / 40320MiB | 64 0 | 4 0 4 0 4 | | | 0MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ | 2 2 0 1 | 38MiB / 40320MiB | 60 0 | 3 0 3 0 3 | | | 0MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ ...</code></pre> <h3 data-ke-size="size23">3. DOCKER</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>Docker, nvidia-docker 리파지토리 추가 후 docker 와 nvidia docker 설치</li> </ul> <pre id="code_1722408851941" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo # dnf -y install containerd.io # dnf -y install docker-ce # curl https://nvidia.github.io/nvidia-docker/rhel8.0/nvidia-docker.repo &gt; /etc/yum.repos.d/nvidia-docker.repo # dnf -y install nvidia-docker2 # systemctl restart docker # systemctl status docker</code></pre> <h3 data-ke-size="size23">4. 작업제출</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>4.1 pytorch 작업 제출</li> </ul> <pre id="code_1722408899269" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run --gpus '"device=2:0"' nvcr.io/nvidia/pytorch:21.12-py3 /bin/bash -c "cd /opt/pytorch/examples/upstream/mnist &amp;&amp; python main.py" # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 463d966bb1f1 nvcr.io/nvidia/pytorch:21.12-py3 "/opt/nvidia/nvidia_&hellip;" 12 minutes ago Up 12 minutes 6006/tcp, 8888/tcp cranky_benz # nvidia-smi ..... +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 2 1 0 0 | 724MiB / 40320MiB | 64 0 | 4 0 4 0 4 | | | 3MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ | 2 2 0 1 | 38MiB / 40320MiB | 60 0 | 3 0 3 0 3 | | | 0MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | 2 1 0 743978 C python 664MiB | +-----------------------------------------------------------------------------------------+ .....</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>3.2 작업 추가 후 확인</li> </ul> <pre id="code_1722408928418" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># docker run --gpus '"device=2:1"' nvcr.io/nvidia/pytorch:21.12-py3 /bin/bash -c "cd /opt/pytorch/examples/upstream/mnist &amp;&amp; python main.py" # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae6d21ebdd37 nvcr.io/nvidia/pytorch:21.12-py3 "/opt/nvidia/nvidia_&hellip;" 6 minutes ago Up 6 minutes 6006/tcp, 8888/tcp upbeat_ganguly 463d966bb1f1 nvcr.io/nvidia/pytorch:21.12-py3 "/opt/nvidia/nvidia_&hellip;" 24 minutes ago Up 24 minutes 6006/tcp, 8888/tcp cranky_benz # nvidia-smi ... +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 2 1 0 0 | 890MiB / 40320MiB | 64 0 | 4 0 4 0 4 | | | 3MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ | 2 2 0 1 | 295MiB / 40320MiB | 60 0 | 3 0 3 0 3 | | | 3MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=========================================================================================| | 2 1 0 743978 C python 830MiB | | 2 2 0 755998 C python 248MiB | +-----------------------------------------------------------------------------------------+</code></pre></description>
<category>NVIDIA</category>
<category>DevOps</category>
<category>docker</category>
<category>HPC</category>
<category>MIG</category>
<category>nvidia</category>
<category>병렬</category>
<category>슈퍼컴퓨터</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/191</guid>
<comments>https://estar987.com/entry/NVIDIA-MIGMulti-Instance-GPU-Docker-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90-%ED%95%A0%EB%8B%B9#entry191comment</comments>
<pubDate>Sat, 3 Aug 2024 12:00:45 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] MIG(Multi-Instance-GPU) 설정 및 생성 삭제</title>
<link>https://estar987.com/entry/NVIDIA-MIGMulti-Instance-GPU-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%83%9D%EC%84%B1-%EC%82%AD%EC%A0%9C</link>
<description><h3 data-ke-size="size23">MIG 설정 순서</h3> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>MIG 활성화</li> <li>GPU Instance(GI) 생성</li> <li>Compute Instance(CI) 생성</li> </ol> <h3 data-ke-size="size23">MIG 활성화 전 확인</h3> <pre id="code_1722256230257" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1920" data-origin-height="1420"><span data-url="https://blog.kakaocdn.net/dn/qqyYQ/btsIRxfMrFC/K5RLYBCxlm7KRw0f9j59Xk/img.png" data-phocus="https://blog.kakaocdn.net/dn/qqyYQ/btsIRxfMrFC/K5RLYBCxlm7KRw0f9j59Xk/img.png"><img src="https://blog.kakaocdn.net/dn/qqyYQ/btsIRxfMrFC/K5RLYBCxlm7KRw0f9j59Xk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqqyYQ%2FbtsIRxfMrFC%2FK5RLYBCxlm7KRw0f9j59Xk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1920" data-origin-height="1420"/></span></figure> </p> <h3 data-ke-size="size23">MIG 활성화 /비활성화</h3> <blockquote data-ke-style="style2">nvidia-smi -i [활성화할 GPU 번호] -mig [0/1 비활성화 / 활성화]</blockquote> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>5번 GPU 활성화</li> </ul> <pre id="code_1722256472952" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -i 5 -mig 1</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>0번 GPU 비활성화</li> </ul> <pre id="code_1722256518969" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -i 0 -mig 0</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>활성화 / 비활성화 후 GPU 리셋</li> </ul> <pre id="code_1722256564694" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi --gpu-reset</code></pre> <pre id="code_1722256642364" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1920" data-origin-height="2348"><span data-url="https://blog.kakaocdn.net/dn/GBtzP/btsIP7icRWy/BCmQz3L9kfzK6Dk2s5m02k/img.png" data-phocus="https://blog.kakaocdn.net/dn/GBtzP/btsIP7icRWy/BCmQz3L9kfzK6Dk2s5m02k/img.png"><img src="https://blog.kakaocdn.net/dn/GBtzP/btsIP7icRWy/BCmQz3L9kfzK6Dk2s5m02k/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGBtzP%2FbtsIP7icRWy%2FBCmQz3L9kfzK6Dk2s5m02k%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1920" data-origin-height="2348"/></span></figure> </p> <h3 data-ke-size="size23">MIG 프로필 확인</h3> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>GPU : 각 GPU 당 7개씩 MIG 나누어진 것 확인</li> <li>Instance Free / Total : GI 생성 가능 개수 확인</li> <li>Memory GIB 유의해서 원하는 만큼 활성화 시키기</li> </ol> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1920" data-origin-height="697"><span data-url="https://blog.kakaocdn.net/dn/6l4Op/btsIP8OUq3p/VjwdE1CFPNILjRPdMQEN31/img.png" data-phocus="https://blog.kakaocdn.net/dn/6l4Op/btsIP8OUq3p/VjwdE1CFPNILjRPdMQEN31/img.png" data-alt="이미지를 참고하면 아래 CLI 환경에서 프로필 확인 창을 이해하기 쉽다."><img src="https://blog.kakaocdn.net/dn/6l4Op/btsIP8OUq3p/VjwdE1CFPNILjRPdMQEN31/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6l4Op%2FbtsIP8OUq3p%2FVjwdE1CFPNILjRPdMQEN31%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1920" data-origin-height="697"/></span><figcaption>이미지를 참고하면 아래 CLI 환경에서 프로필 확인 창을 이해하기 쉽다.</figcaption> </figure> </p> <pre id="code_1722257271135" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgip</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1920" data-origin-height="2180"><span data-url="https://blog.kakaocdn.net/dn/Edqbs/btsIQ2UMy5U/YBGXZncaIG6cfF3cpfYkM0/img.png" data-phocus="https://blog.kakaocdn.net/dn/Edqbs/btsIQ2UMy5U/YBGXZncaIG6cfF3cpfYkM0/img.png"><img src="https://blog.kakaocdn.net/dn/Edqbs/btsIQ2UMy5U/YBGXZncaIG6cfF3cpfYkM0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEdqbs%2FbtsIQ2UMy5U%2FYBGXZncaIG6cfF3cpfYkM0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="762" height="865" data-origin-width="1920" data-origin-height="2180"/></span></figure> </p> <pre id="code_1722257281329" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgipp</code></pre> <pre id="code_1722258295817" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgipp GPU 0 Profile ID 19 Placements: {0,1,2,3,4,5,6}:1 GPU 0 Profile ID 20 Placements: {0,1,2,3,4,5,6}:1 GPU 0 Profile ID 15 Placements: {0,2,4,6}:2 GPU 0 Profile ID 14 Placements: {0,2,4}:2 GPU 0 Profile ID 9 Placements: {0,4}:4 GPU 0 Profile ID 5 Placement : {0}:4 GPU 0 Profile ID 0 Placement : {0}:8 GPU 1 Profile ID 19 Placements: {0,1,2,3,4,5,6}:1 GPU 1 Profile ID 20 Placements: {0,1,2,3,4,5,6}:1 GPU 1 Profile ID 15 Placements: {0,2,4,6}:2 GPU 1 Profile ID 14 Placements: {0,2,4}:2 GPU 1 Profile ID 9 Placements: {0,4}:4 GPU 1 Profile ID 5 Placement : {0}:4 GPU 1 Profile ID 0 Placement : {0}:8</code></pre> <h3 data-ke-size="size23">MIG GI(GPU Instance) 생성</h3> <h4 data-ke-size="size20">MIG 프로필 ID로 생성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>GPU를 선택하지 않으면 0번 GPU로 자동 할당된다.</li> </ul> <pre id="code_1722257814050" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -cgi 15</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>GPU를 선택하면 선택한 GPU로 할당된다.</li> </ul> <pre id="code_1722258021605" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 6 -cgi 19 Successfully created GPU instance ID 13 on GPU 6 using profile MIG 1g.10gb (ID 19)</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>조회 (GI생성 확인)</li> </ul> <pre id="code_1722258164921" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 6 MIG 1g.10gb 19 13 6:1 | +-------------------------------------------------------+ | 7 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+ | 7 MIG 1g.20gb 15 6 6:2 | +-------------------------------------------------------+</code></pre> <h4 style="color: #000000; text-align: start;" data-ke-size="size20">MIG 이름로 생성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li># nvidia-smi mig -lgip 에서 나온 이름으로 생성한다.</li> </ul> <p data-ke-size="size18">EX</p> <pre id="code_1722258513884" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgip +-----------------------------------------------------------------------------+ | GPU instance profiles: | | GPU Name ID Instances Memory P2P SM DEC ENC | | Free/Total GiB CE JPEG OFA | |=============================================================================| +-----------------------------------------------------------------------------+ | 6 MIG 1g.10gb 19 6/7 9.75 No 16 1 0 | | 1 1 0 | +-----------------------------------------------------------------------------+ | 6 MIG 1g.10gb+me 20 1/1 9.75 No 16 1 0 | | 1 1 1 | +-----------------------------------------------------------------------------+ | 6 MIG 1g.20gb 15 3/4 19.62 No 26 1 0 | | 1 1 0 | +-----------------------------------------------------------------------------+ | 6 MIG 2g.20gb 14 3/3 19.62 No 32 2 0 | | 2 2 0 | +-----------------------------------------------------------------------------+ | 6 MIG 3g.40gb 9 1/2 39.38 No 60 3 0 | | 3 3 0 | +-----------------------------------------------------------------------------+ | 6 MIG 4g.40gb 5 1/1 39.38 No 64 4 0 | | 4 4 0 | +-----------------------------------------------------------------------------+ | 6 MIG 7g.80gb 0 0/1 79.12 No 132 7 0 | | 8 7 1 | +-----------------------------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>nvidia-smi mig -i [GPU 번호] -cgi [2. instance Name]</li> </ul> <p data-ke-size="size16">[실습 1] 단일 생성</p> <pre id="code_1722258743477" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 6 -cgi 1g.10gb Successfully created GPU instance ID 11 on GPU 6 using profile MIG 1g.10gb (ID 19)</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 2] 다중 생성</p> <pre id="code_1722258940153" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -cgi 1g.10gb,&rdquo;MIG 1g.10gb&rdquo; Successfully created GPU instance ID 9 on GPU 5 using profile MIG 1g.10gb (ID 19) Successfully created GPU instance ID 7 on GPU 5 using profile MIG 1g.10gb (ID 19)</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>MIG GI 추가 확인 <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>6번 GPU에 Instance ID 11번 추가됨</li> </ul> </li> </ul> <pre id="code_1722259093891" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 6 MIG 1g.10gb 19 11 4:1 | +-------------------------------------------------------+ | 7 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+ | 7 MIG 1g.20gb 15 6 6:2 | +-------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">CI(Compute Instance) 생성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>CI를 생성할 GI 조회 <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>1. GPU 번호(6,7)&nbsp; Instance ID(11, 13, 1, 6)</li> </ul> </li> </ul> <pre id="code_1722260633055" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 6 MIG 1g.10gb 19 11 4:1 | +-------------------------------------------------------+ | 7 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+ | 7 MIG 1g.20gb 15 6 6:2 | +-------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>nvidia-smi mig -i [1. GPU 번호] -cci -gi [2. Instance ID]</li> </ul> <p data-ke-size="size16">[실습 1] 단일 생성</p> <pre id="code_1722259455861" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 6 -cci -gi 11 Successfully created compute instance ID 0 on GPU 6 GPU instance ID 11 using profile MIG 1g. 10gb (ID 0)</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 2] 다중 생성</p> <pre id="code_1722259821152" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 7 -cci -gi 1,6 Successfully created compute instance ID 0 on GPU 7 GPU instance ID 1 using profile MIG 1g.10gb (ID 0) Successfully created compute instance ID 0 on GPU 7 GPU instance ID 6 using profile MIG 1g.10gb (ID 0)</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인(전체)</li> </ul> <pre id="code_1722259916514" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 6 11 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+ | 7 1 MIG 4g.40gb 3 0 0:4 | +--------------------------------------------------------------------+ | 7 6 MIG 1g.20gb 7 0 0:2 | +--------------------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인(원하는 GPU만)</li> </ul> <pre id="code_1722259950590" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 7 -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 7 1 MIG 4g.40gb 3 0 0:4 | +--------------------------------------------------------------------+ | 7 6 MIG 1g.20gb 7 0 0:2 | +--------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">MIG GI &amp; MIG CI 동시 생성</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>사전 작업으로 2번 GPU 활성화 시켜준다.</li> </ul> <pre id="code_1722260127628" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi -i 2 -mig 1 Enabled MIG Mode for GPU 00000000:3F:00.0 Warning: persistence mode is disabled on device 00000000:3F:00.0. See the Known Issues section of the nvidia-smi(1) man page for more information. Run with [--help | -h] switch to get more information on how to enable persistence mode. All done.</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>nvidia-smi mig -i [1. GPU 번호] -cci -gi [2. Profile ID] -C</li> </ul> <pre id="code_1722260273247" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -i 2 -cgi 19 -C Successfully created GPU instance ID 13 on GPU 2 using profile MIG 1g.10gb (ID 19) Successfully created compute instance ID 0 on GPU 2 GPU instance ID 13 using profile MIG 1g. 10gb (ID 0)</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인(2번 GPU 생성 확인) - GI</li> </ul> <pre id="code_1722260301653" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 2 MIG 1g.10gb 19 13 6:1 | +-------------------------------------------------------+ | 6 MIG 1g.10gb 19 11 4:1 | +-------------------------------------------------------+ | 7 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+ | 7 MIG 1g.20gb 15 6 6:2 | +-------------------------------------------------------+</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인(2번 GPU 생성 확인) - CI</li> </ul> <pre id="code_1722260404406" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 2 13 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+ | 6 11 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+ | 7 1 MIG 4g.40gb 3 0 0:4 | +--------------------------------------------------------------------+ | 7 6 MIG 1g.20gb 7 0 0:2 | +--------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">MIG 활성화, MIG GI &amp; CI 순서대로 생성 후 MIG 생성됐는지 확인</h3> <pre id="code_1722342553451" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi .... +-----------------------------------------------------------------------------------------+ | MIG devices: | +------------------+----------------------------------+-----------+-----------------------+ | GPU GI CI MIG | Memory-Usage | Vol| Shared | | ID ID Dev | BAR1-Usage | SM Unc| CE ENC DEC OFA JPG | | | | ECC| | |==================+==================================+===========+=======================| | 2 1 0 0 | 51MiB / 40320MiB | 32 0 | 4 0 4 0 4 | | | 0MiB / 65535MiB | | | +------------------+----------------------------------+-----------+-----------------------+ ....</code></pre> <h3 data-ke-size="size23">MIG CI 삭제</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>nvidia-smi mig -dci -i [1.Compute GPU] -gi [2. GPU Instance ID]</li> </ul> <p data-ke-size="size16">[실습 1] 단일 삭제&nbsp;</p> <pre id="code_1722260883803" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -dci -i 7 -gi 6 Successfully destroyed compute instance ID 0 from GPU 7 GPU instance ID 6</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>확인</li> </ul> <pre id="code_1722260920186" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lci +--------------------------------------------------------------------+ | Compute instances: | | GPU GPU Name Profile Instance Placement | | Instance ID ID Start:Size | | ID | |====================================================================| | 2 13 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+ | 6 11 MIG 1g.10gb 0 0 0:1 | +--------------------------------------------------------------------+ | 7 1 MIG 4g.40gb 3 0 0:4 | +--------------------------------------------------------------------+</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 2] 다중 삭제</p> <pre id="code_1722260991237" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -dci -i 5 -gi 7,9 Successfully destroyed compute instance ID 0 from GPU 5 GPU instance ID 7 Successfully destroyed compute instance ID 0 from GPU 5 GPU instance ID 9</code></pre> <h3 style="color: #000000; text-align: start;" data-ke-size="size23">MIG GI 삭제</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>nvidia-smi mig -dgi -i [1.Compute GPU] -gi [2.Instance ID]</li> </ul> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>조회</li> </ul> <pre id="code_1722261054751" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lgi +-------------------------------------------------------+ | GPU instances: | | GPU Name Profile Instance Placement | | ID ID Start:Size | |=======================================================| | 2 MIG 1g.10gb 19 13 6:1 | +-------------------------------------------------------+ | 6 MIG 1g.10gb 19 11 4:1 | +-------------------------------------------------------+ | 7 MIG 4g.40gb 5 1 0:4 | +-------------------------------------------------------+ | 7 MIG 1g.20gb 15 6 6:2 | +-------------------------------------------------------+</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 1] 단일 삭제</p> <pre id="code_1722261108188" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig 2 -dgi -gi 13</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 2] 다중 삭제</p> <pre id="code_1722261866187" class="routeros" style="background-color: #f8f8f8; color: #383a42; text-align: start;" data-ke-type="codeblock" data-ke-language="bash"><code># nvidia-smi mig -dci -i 5 -gi 7,9 Successfully destroyed compute instance ID 0 from GPU 5 GPU instance ID 7 Successfully destroyed compute instance ID 0 from GPU 5 GPU instance ID 9</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">[실습 3] 전체 삭제</p> <pre id="code_1722261724821" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -dci Successfully destroyed compute instance ID 0 from GPU 2 GPU instance ID 13 Successfully destroyed compute instance ID 0 from GPU 6 GPU instance ID 11 Successfully destroyed compute instance ID 0 from GPU 7 GPU instance ID 1</code></pre> <pre id="code_1722261734709" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -dgi Successfully destroyed GPU instance ID 13 from GPU 2 Successfully destroyed GPU instance ID 11 from GPU 6 Successfully destroyed GPU instance ID 1 from GPU 7 Successfully destroyed GPU instance ID 6 from GPU 7</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>조회</li> </ul> <pre id="code_1722262009720" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi mig -lci No GPU instances found: Not Found # nvidia-smi mig -lgi No GPU instances found: Not Found</code></pre> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">Trouble shooting</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>GI 먼저 삭제하면 삭제가 안된다.&nbsp;</li> <li>지우는 순서는 생성 역순으로 CI 지우고 GI 지우고 비활성화</li> </ul></description>
<category>NVIDIA</category>
<category>a100</category>
<category>GPU</category>
<category>H100</category>
<category>Linux</category>
<category>MIG</category>
<category>nvidia</category>
<category>엔비디아</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/190</guid>
<comments>https://estar987.com/entry/NVIDIA-MIGMulti-Instance-GPU-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%83%9D%EC%84%B1-%EC%82%AD%EC%A0%9C#entry190comment</comments>
<pubDate>Fri, 2 Aug 2024 12:00:37 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] MIG 활용시 배포 및 시스템 고려 사항</title>
<link>https://estar987.com/entry/NVIDIA-MIG-%ED%99%9C%EC%9A%A9%EC%8B%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B3%A0%EB%A0%A4-%EC%82%AC%ED%95%AD</link>
<description><h3 data-ke-size="size23">배포 고려 사항</h3> <p data-ke-size="size16">MIG 기능은 NVIDIA GPU 드라이버의 일부로 제공된다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>H100 GPU는 CUDA 12/R525 드라이버부터 지원</li> <li>A100 및 A30 GPU는 CUDA 11/R450 드라이버부터 지원</li> </ul> <h3 data-ke-size="size23">시스템 고려사항</h3> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>지원되는 운영체제 : CUDA 에서 지원하는 Linux 운영체제 배포판에서만 지원됨</li> <li>장치 노드 접근 : ./proc시스템 수준 인터페이스 대신, /dev cgroup을 통해 MIG 장치의 액세스 메커니즘을 제어하는 것이 권장됩니다. 이 기능은 450.80.02+ 드라이버부터 사용할 수 있습니다.</li> <li>지원되는 구성 <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li>컨테이너를 포함한 베어메탈 환경</li> <li>지원되는 하이퍼바이저 위의 Linux 게스트에 대한 GPU 패스스루 가상화</li> <li>지원되는 하이퍼바이저 위의 vGPU</li> </ol> </li> </ol> <h3 data-ke-size="size23">지원되는 MIG 프로필</h3> <h4 data-ke-size="size20">A30 MIG 프로필</h4> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="335"><span data-url="https://blog.kakaocdn.net/dn/3bWio/btsIPJaKswz/ghpnasuqTRx4DtunqOawf1/img.png" data-phocus="https://blog.kakaocdn.net/dn/3bWio/btsIPJaKswz/ghpnasuqTRx4DtunqOawf1/img.png"><img src="https://blog.kakaocdn.net/dn/3bWio/btsIPJaKswz/ghpnasuqTRx4DtunqOawf1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3bWio%2FbtsIPJaKswz%2FghpnasuqTRx4DtunqOawf1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="335"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="571"><span data-url="https://blog.kakaocdn.net/dn/bov1K2/btsIRMjsa8G/Pz5N3S8q16D6KixRlK07WK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bov1K2/btsIRMjsa8G/Pz5N3S8q16D6KixRlK07WK/img.png" data-alt="A30 24GIB"><img src="https://blog.kakaocdn.net/dn/bov1K2/btsIRMjsa8G/Pz5N3S8q16D6KixRlK07WK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbov1K2%2FbtsIRMjsa8G%2FPz5N3S8q16D6KixRlK07WK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="571"/></span><figcaption>A30 24GIB</figcaption> </figure> </p> <h4 data-ke-size="size20">A100 MIG 프로필</h4> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="737"><span data-url="https://blog.kakaocdn.net/dn/bF7dCk/btsIPVPFHZt/Kc6m9zNY4UiRglxLZHXmM0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bF7dCk/btsIPVPFHZt/Kc6m9zNY4UiRglxLZHXmM0/img.png"><img src="https://blog.kakaocdn.net/dn/bF7dCk/btsIPVPFHZt/Kc6m9zNY4UiRglxLZHXmM0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbF7dCk%2FbtsIPVPFHZt%2FKc6m9zNY4UiRglxLZHXmM0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="737"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="563"><span data-url="https://blog.kakaocdn.net/dn/uhdoT/btsIRNo7DYR/15dUcaTK73ptjiN2cobg71/img.png" data-phocus="https://blog.kakaocdn.net/dn/uhdoT/btsIRNo7DYR/15dUcaTK73ptjiN2cobg71/img.png" data-alt="A100 40GIB"><img src="https://blog.kakaocdn.net/dn/uhdoT/btsIRNo7DYR/15dUcaTK73ptjiN2cobg71/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuhdoT%2FbtsIRNo7DYR%2F15dUcaTK73ptjiN2cobg71%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="563"/></span><figcaption>A100 40GIB</figcaption> </figure> </p> <h4 data-ke-size="size20">H100 MIG 프로필</h4> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="726"><span data-url="https://blog.kakaocdn.net/dn/bDUS4d/btsIQhSnRED/48AZ2DrbBX4euuMwoHzX01/img.png" data-phocus="https://blog.kakaocdn.net/dn/bDUS4d/btsIQhSnRED/48AZ2DrbBX4euuMwoHzX01/img.png"><img src="https://blog.kakaocdn.net/dn/bDUS4d/btsIQhSnRED/48AZ2DrbBX4euuMwoHzX01/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDUS4d%2FbtsIQhSnRED%2F48AZ2DrbBX4euuMwoHzX01%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="726"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="665"><span data-url="https://blog.kakaocdn.net/dn/bynEsJ/btsIRm6n2gf/gOzZzCRKnnyw1ea5BcIqFK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bynEsJ/btsIRm6n2gf/gOzZzCRKnnyw1ea5BcIqFK/img.png" data-alt="H100 80GB"><img src="https://blog.kakaocdn.net/dn/bynEsJ/btsIRm6n2gf/gOzZzCRKnnyw1ea5BcIqFK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbynEsJ%2FbtsIRm6n2gf%2FgOzZzCRKnnyw1ea5BcIqFK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="665"/></span><figcaption>H100 80GB</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="805"><span data-url="https://blog.kakaocdn.net/dn/bosI5x/btsIQeOPPKL/dOX5cZ8cpqJsvG4BVLogIK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bosI5x/btsIQeOPPKL/dOX5cZ8cpqJsvG4BVLogIK/img.png" data-alt="H100 94GIB"><img src="https://blog.kakaocdn.net/dn/bosI5x/btsIQeOPPKL/dOX5cZ8cpqJsvG4BVLogIK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbosI5x%2FbtsIQeOPPKL%2FdOX5cZ8cpqJsvG4BVLogIK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="805"/></span><figcaption>H100 94GIB</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="816"><span data-url="https://blog.kakaocdn.net/dn/sKMbx/btsIQx8rBfK/zZqOwWnkFKhFURYUEwW8C1/img.png" data-phocus="https://blog.kakaocdn.net/dn/sKMbx/btsIQx8rBfK/zZqOwWnkFKhFURYUEwW8C1/img.png" data-alt="H100 96GIB"><img src="https://blog.kakaocdn.net/dn/sKMbx/btsIQx8rBfK/zZqOwWnkFKhFURYUEwW8C1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsKMbx%2FbtsIQx8rBfK%2FzZqOwWnkFKhFURYUEwW8C1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="816"/></span><figcaption>H100 96GIB</figcaption> </figure> </p> <h4 data-ke-size="size20">H200 MIG 프로필</h4> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="726"><span data-url="https://blog.kakaocdn.net/dn/nUvgd/btsIRMKwsHD/Vz6MFjUVuSfhOQ7gdkdIPk/img.png" data-phocus="https://blog.kakaocdn.net/dn/nUvgd/btsIRMKwsHD/Vz6MFjUVuSfhOQ7gdkdIPk/img.png"><img src="https://blog.kakaocdn.net/dn/nUvgd/btsIRMKwsHD/Vz6MFjUVuSfhOQ7gdkdIPk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnUvgd%2FbtsIRMKwsHD%2FVz6MFjUVuSfhOQ7gdkdIPk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="726"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="601"><span data-url="https://blog.kakaocdn.net/dn/b4EWrG/btsIPuLHmJx/mNkb4CeJl3RdT3pUk2S8x0/img.png" data-phocus="https://blog.kakaocdn.net/dn/b4EWrG/btsIPuLHmJx/mNkb4CeJl3RdT3pUk2S8x0/img.png" data-alt="H200 141GIB"><img src="https://blog.kakaocdn.net/dn/b4EWrG/btsIPuLHmJx/mNkb4CeJl3RdT3pUk2S8x0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4EWrG%2FbtsIPuLHmJx%2FmNkb4CeJl3RdT3pUk2S8x0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="601"/></span><figcaption>H200 141GIB</figcaption> </figure> </p> <h3 data-ke-size="size23">납품 경험</h3> <p data-ke-size="size16">이번 고객사에 H100 그래픽 카드가 장착된 Dell 서버를 납품하는 중 CUDA_VISIBLE_DEVICES 관련 문제 발생</p> <p data-ke-size="size16">&gt;&gt; 해당 이슈 관련하여 H100이 CUDA 11.8 nvml 지원된다는 내용을 공유함</p> <p data-ke-size="size16">&gt;&gt; 상위 CUDA 버전으로 빌드하여 새로 전달 받아 해결함</p> <p data-ke-size="size16">&nbsp;</p></description>
<category>NVIDIA</category>
<category>!30</category>
<category>a100</category>
<category>GPU</category>
<category>H100</category>
<category>H200</category>
<category>HPC</category>
<category>MIG</category>
<category>nvidia</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/189</guid>
<comments>https://estar987.com/entry/NVIDIA-MIG-%ED%99%9C%EC%9A%A9%EC%8B%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B3%A0%EB%A0%A4-%EC%82%AC%ED%95%AD#entry189comment</comments>
<pubDate>Thu, 1 Aug 2024 12:00:34 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] MIG를 활용한 고성능 컴퓨팅 환경 구축</title>
<link>https://estar987.com/entry/Rocky-linux-8-MIG%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%BB%B4%ED%93%A8%ED%8C%85-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95</link>
<description><h3 data-ke-size="size23">1. Kubernetes &amp; MIG</h3> <p data-ke-size="size16"><b>Kubernetes</b>는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈 소스 플랫폼입니다. MIG와 Kubernetes를 통합하면 다음과 같은 이점을 얻을 수 있습니다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>리소스 최적화</b>: Kubernetes의 자원 할당 기능과 MIG의 인스턴스 분할 기능을 결합하여 GPU 자원을 최적화할 수 있습니다.</li> <li><b>유연한 스케줄링</b>: Kubernetes의 스케줄러를 사용하여 다양한 크기의 MIG 인스턴스를 필요에 따라 유연하게 할당할 수 있습니다.</li> <li><b>자동화된 관리</b>: Kubernetes의 오토스케일링과 자원 모니터링 기능을 통해 GPU 사용량을 자동으로 관리하고 최적화할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">1.1 Kubernetes 설정 예시</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>Kubernetes 노드 설정</b>: 각 노드에서 NVIDIA 드라이버와 CUDA를 설치하고, NVIDIA Kubernetes Device Plugin을 설정합니다.</li> <li><b>MIG 인스턴스 구성</b>: nvidia-smi 명령어를 사용하여 각 노드에서 필요한 MIG 인스턴스를 생성합니다.</li> <li><b>Kubernetes 리소스 요청</b>: 애플리케이션 배포 시, MIG 인스턴스를 요청하는 리소스 설정을 추가합니다.</li> </ul> <pre class="yaml"><code>apiVersion: v1 kind: Pod metadata: name: mig-pod spec: containers: - name: mig-container image: your_image resources: limits: nvidia.com/gpu: 1 # MIG 인스턴스를 요청하는 설정 </code></pre> <h3 data-ke-size="size23">2. Docker &amp; MIG</h3> <p data-ke-size="size16"><b>Docker</b>는 컨테이너를 생성하고 관리하는 플랫폼으로, 애플리케이션을 격리된 환경에서 실행할 수 있습니다. MIG와 Docker를 결합하여 다음과 같은 이점을 얻을 수 있습니다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>격리된 환경</b>: 각 MIG 인스턴스를 별도의 Docker 컨테이너에 할당하여 격리된 환경에서 애플리케이션을 실행할 수 있습니다.</li> <li><b>유연한 배포</b>: Docker의 이미지를 사용하여 다양한 환경에 애플리케이션을 배포할 수 있습니다.</li> <li><b>효율적인 리소스 사용</b>: Docker와 MIG를 결합하여 GPU 자원을 효율적으로 사용할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">2.1 Docker 설정 예시</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>Docker 환경 설정</b>: NVIDIA Container Toolkit을 설치하여 Docker가 GPU를 사용할 수 있도록 설정합니다.</li> <li><b>MIG 인스턴스 구성</b>: nvidia-smi 명령어를 사용하여 필요한 MIG 인스턴스를 생성합니다.</li> <li><b>Docker 컨테이너 실행</b>: -gpus 옵션을 사용하여 MIG 인스턴스를 할당한 Docker 컨테이너를 실행합니다.</li> </ul> <pre class="dockerfile"><code>docker run --gpus '"device=0"' your_image </code></pre> <h3 data-ke-size="size23">3. Slurm &amp; MIG</h3> <p data-ke-size="size16"><b>Slurm</b> (Simple Linux Utility for Resource Management)은 리소스 관리 및 작업 스케줄러로, 대규모 컴퓨팅 클러스터에서 작업을 관리하고 분산 시스템의 리소스를 효율적으로 할당할 수 있습니다. MIG와 Slurm을 통합하면 다음과 같은 이점을 얻을 수 있습니다:</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>정교한 작업 스케줄링</b>: Slurm의 작업 스케줄링 기능을 사용하여 다양한 크기의 MIG 인스턴스를 필요에 따라 할당할 수 있습니다.</li> <li><b>리소스 최적화</b>: Slurm의 자원 관리 기능을 통해 GPU 사용량을 최적화하고, 사용하지 않는 자원을 효율적으로 재할당할 수 있습니다.</li> <li><b>자동화된 관리</b>: Slurm의 자동화된 작업 관리 기능을 통해 대규모 컴퓨팅 작업을 효율적으로 관리할 수 있습니다.</li> </ul> <h4 data-ke-size="size20">3.1 Slurm 설정 예시</h4> <p data-ke-size="size16">Slurm 클러스터에서 MIG 인스턴스를 사용하는 설정은 다음과 같이 진행할 수 있습니다:</p> <ol style="list-style-type: decimal;" data-ke-list-type="decimal"> <li><b>Slurm 노드 설정</b>: 각 노드에서 NVIDIA 드라이버와 CUDA를 설치하고, Slurm을 설정합니다.</li> <li><b>MIG 인스턴스 구성</b>: nvidia-smi 명령어를 사용하여 각 노드에서 필요한 MIG 인스턴스를 생성합니다.</li> <li><b>Slurm 작업 제출</b>: 작업 제출 스크립트에서 GPU 리소스를 요청하는 설정을 추가합니다.</li> </ol> <pre class="bash"><code>#!/bin/bash #SBATCH --gres=gpu:1 # MIG 인스턴스를 요청하는 설정 srun your_application </code></pre> <h3 data-ke-size="size23">4. 추가로 활용할 수 있는 도구들</h3> <h4 data-ke-size="size20">4.1 NVIDIA GPU Cloud (NGC)</h4> <p data-ke-size="size16">NGC는 NVIDIA에서 제공하는 컨테이너 레지스트리로, 고성능 컴퓨팅 및 딥러닝 애플리케이션을 위한 최적화된 컨테이너를 제공합니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>최적화된 컨테이너</b>: 딥러닝 프레임워크와 HPC 애플리케이션에 최적화된 컨테이너 제공.</li> <li><b>신속한 배포</b>: 복잡한 환경 설정 없이 빠르게 GPU를 활용한 작업 시작 가능.</li> <li><b>안정성 및 성능</b>: NVIDIA가 제공하는 최신 드라이버와 라이브러리 포함.</li> </ul> <h4 data-ke-size="size20">4.2 Singularity</h4> <p data-ke-size="size16"><b>Singularity</b>는 고성능 컴퓨팅(HPC) 환경에서 널리 사용되는 컨테이너 플랫폼입니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>보안성</b>: 사용자 권한을 유지하면서 컨테이너 실행 가능.</li> <li><b>이동성</b>: 컨테이너 이미지를 쉽게 공유하고 이동 가능.</li> <li><b>HPC 통합</b>: HPC 환경에서의 사용을 위해 설계, Slurm과 같은 스케줄러와 잘 통합.</li> </ul> <h4 data-ke-size="size20">4.3 TensorFlow와 PyTorch</h4> <p data-ke-size="size16"><b>TensorFlow</b>와 <b>PyTorch</b>는 인기 있는 딥러닝 프레임워크로, MIG와 결합하여 고성능 딥러닝 작업을 수행할 수 있습니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>고성능 딥러닝</b>: MIG를 통해 여러 딥러닝 작업 병렬 수행.</li> <li><b>유연한 자원 할당</b>: 다양한 크기의 MIG 인스턴스를 생성하여 각 딥러닝 작업에 적합한 자원 할당.</li> <li><b>확장성</b>: 대규모 분산 학습 지원.</li> </ul> <h4 data-ke-size="size20">4.4 Prometheus 및 Grafana</h4> <p data-ke-size="size16"><b>Prometheus</b>와 <b>Grafana</b>는 시스템 모니터링 및 시각화 도구입니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>실시간 모니터링</b>: MIG 인스턴스의 자원 사용량을 실시간 모니터링.</li> <li><b>시각화</b>: GPU 사용량, 온도, 메모리 사용량 등을 시각화하여 자원 사용 현황 파악.</li> <li><b>알림 설정</b>: 자원 사용량이 임계치를 초과할 경우 알림 설정.</li> </ul> <h4 data-ke-size="size20">4.5 Ansible</h4> <p data-ke-size="size16"><b>Ansible</b>은 IT 자동화 도구로, MIG 설정 및 관리 작업을 자동화할 수 있습니다.</p> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>자동화된 설정</b>: MIG 인스턴스 생성, 설정 파일 수정, 드라이버 설치 등을 자동화.</li> <li><b>일관성 보장</b>: 모든 노드에서 일관된 환경 보장.</li> <li><b>확장성</b>: 클러스터 크기에 상관없이 동일한 플레이북 사용.</li> </ul></description>
<category>NVIDIA</category>
<category>cloud</category>
<category>docker</category>
<category>grafana</category>
<category>HPC</category>
<category>kubernetes</category>
<category>MIG</category>
<category>nvidia</category>
<category>prometheus</category>
<category>pytorch</category>
<category>tensorflow</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/188</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-MIG%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%BB%B4%ED%93%A8%ED%8C%85-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95#entry188comment</comments>
<pubDate>Wed, 31 Jul 2024 12:00:02 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] NVIDIA Multi-Instance GPU (MIG) 개요 및 가이드</title>
<link>https://estar987.com/entry/Rocky-linux-8-NVIDIA-Multi-Instance-GPU-MIG-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EA%B0%80%EC%9D%B4%EB%93%9C</link>
<description><p data-ke-size="size16"><span style="color: #000000; font-size: 1.44em; letter-spacing: -1px;">1. MIG 정의 및 개요</span></p> <p data-ke-size="size16">NVIDIA의 Multi-Instance GPU (MIG) 기술은 고성능 컴퓨팅 환경에서 GPU 리소스를 효율적으로 분할하여 사용할 수 있도록 하는 혁신적인 기술입니다. 이 블로그에서는 MIG의 개요, 지원되는 GPU, 주요 용어, 및 지원 장치 이름 등을 다루겠습니다.</p> <h4 data-ke-size="size20">1.1 MIG 사용의 주요 목적</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>고성능 분할 : 하나의 물리적 GPU를 여러 개의 독립적인 가상 GPU 인스턴스로 분할하여 다양한 워크로드를 병렬로 처리할 수 있습니다.&nbsp;</li> <li>리소스 최적화 : 필요에 따라 다양한 크기의 인스턴스를 생성하여 자원 사용의 유연성을 제공합니다.&nbsp;</li> <li>보안성 및 안정성 : 각 인스턴스가 하드웨어 수준에서 격리되어 있어, 하나의 인스턴스에서 발생한 문제가 다른 인스턴스에 영향을 미치지 않습니다.&nbsp;</li> <li>클라우드 및 데이터센터 활용 : 여러 사용자가 동시에 GPU 자원을 사용해야 하는 환경에서 효율적인 자원 할당과 관리가 가능합니다.</li> </ul> <h3 data-ke-size="size23">2. 지원되는 GPU</h3> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="743"><span data-url="https://blog.kakaocdn.net/dn/6gbh2/btsIRM4BiNO/imXLmYu6JocLwglCGgGqtk/img.png" data-phocus="https://blog.kakaocdn.net/dn/6gbh2/btsIRM4BiNO/imXLmYu6JocLwglCGgGqtk/img.png" data-alt="Nvidia 공식 문서에서 추출한 지원되는 GPU 확인"><img src="https://blog.kakaocdn.net/dn/6gbh2/btsIRM4BiNO/imXLmYu6JocLwglCGgGqtk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6gbh2%2FbtsIRM4BiNO%2FimXLmYu6JocLwglCGgGqtk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="743"/></span><figcaption>Nvidia 공식 문서에서 추출한 지원되는 GPU 확인</figcaption> </figure> </p> <h3 data-ke-size="size23">3. 주요 용어</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>MIG 인스턴스 : MIG 기술을 사용하여 단일 물리적 GPU를 분할한 독립적인 가상 GPU.&nbsp;</li> <li>Compute Capability : GPU의 연산 성능을 나타내는 지표. CUDA 어플리케이션의 호환성을 결정하는 중요한 요소.&nbsp;</li> <li>Hopper Architecture : NVIDIA의 최신 GPU 아키텍처로, 고성능 컴퓨팅 및 인공지능 작업에 최적화되어 있음.&nbsp;</li> <li>Ampere Architecture : NVIDIA의 이전 세대 GPU 아키텍처로, 다양한 고성능 컴퓨팅 작업에 널리 사용됨.</li> <li>SM (Streaming Multiprocessor) : GPU에서 컴퓨팅 명령을 실행하는 기본 단위.&nbsp;</li> <li>GPU Context : 주소 공간, 메모리 할당 등을 포함하여 GPU에서 작업을 실행하는 데 필요한 모든 리소스를 캡슐화한 것.&nbsp;</li> <li>GPU Engine : GPU에서 작업을 실행하는 요소 (DMA, NVDEC 등).</li> <li>GPU Memory Slice : 해당 메모리 컨트롤러와 캐시를 포함하여 GPU 메모리의 가장 작은 부분. 전체 GPU 메모리 리소스의 약 8분의 1.&nbsp;</li> <li>GPU SM Slice : GPU에서 가장 작은 연산 단위로, 단일 GPU 메모리 슬라이스와 단일 GPU SM 슬라이스를 결합한 것. 전체 SM 수의 약 1/7을 차지.&nbsp;</li> <li>GPU Slice : 단일 GPU 메모리 슬라이스와 단일 GPU SM 슬라이스를 결합한 GPU의 가장 작은 부분.&nbsp;</li> <li>GI (GPU Instance) : GPU Slice와 GPU Engine의 조합. GI 내의 모든 것은 항상 모든 GPU 메모리 슬라이스와 다른 GPU 엔진을 공유하지만, SM Slice는 CI (Compute Instance)로 세분화될 수 있음.&nbsp;</li> <li>CI (Compute Instance) : GI 내에서 더욱 세분화된 컴퓨팅 인스턴스. 여러 CI가 상위 GPU 인스턴스의 SM Slice 및 GPU 엔진의 하위 집합을 공유.</li> </ul> <h3 data-ke-size="size23">4. 장치 이름</h3> <p data-ke-size="size16">기본적으로 MIG 장치는 단일 GI와 CI로 구성</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="365"><span data-url="https://blog.kakaocdn.net/dn/J5yRP/btsIPy1rUYc/nKui4HJhebhWc9Suj6BEk0/img.png" data-phocus="https://blog.kakaocdn.net/dn/J5yRP/btsIPy1rUYc/nKui4HJhebhWc9Suj6BEk0/img.png"><img src="https://blog.kakaocdn.net/dn/J5yRP/btsIPy1rUYc/nKui4HJhebhWc9Suj6BEk0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJ5yRP%2FbtsIPy1rUYc%2FnKui4HJhebhWc9Suj6BEk0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="365"/></span></figure> </p></description>
<category>NVIDIA</category>
<category>GPU</category>
<category>HPC</category>
<category>MIG</category>
<category>multi-instance gpu</category>
<category>Rocky Linux</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/187</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-NVIDIA-Multi-Instance-GPU-MIG-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EA%B0%80%EC%9D%B4%EB%93%9C#entry187comment</comments>
<pubDate>Tue, 30 Jul 2024 12:00:34 +0900</pubDate>
</item>
<item>
<title>[NVIDIA] CUDA Driver 설치</title>
<link>https://estar987.com/entry/Rocky-linux-8-CUDA-Driver-%EC%84%A4%EC%B9%98</link>
<description><h3 data-ke-size="size23">Cuda Version Check</h3> <pre id="code_1722210481087" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># nvidia-smi Wed Jun 19 18:09:47 2024 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 470.239.06 Driver Version: 470.239.06 CUDA Version: 11.4 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Quadro K5200 Off | 00000000:04:00.0 Off | Off | | 0% 41C P0 23W / 150W | 0MiB / 8126MiB | 1% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+</code></pre> <h3 data-ke-size="size23">설치 파일 다운로드</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>설치 URL</li> </ul> <p data-ke-size="size16"><span></span><a href="https://developer.nvidia.com/cuda-11-4-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=RHEL&amp;target_version=8&amp;target_type=runfile_local">https://developer.nvidia.com/cuda-11-4-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=RHEL&amp;target_version=8&amp;target_type=runfile_local</a></p> <figure id="og_1722210517644" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="CUDA Toolkit 11.4 Downloads" data-og-description="Get CUDA Toolkit 11.4 for Linux and Windows." data-og-host="developer.nvidia.com" data-og-source-url="https://developer.nvidia.com/cuda-11-4-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=RHEL&amp;target_version=8&amp;target_type=runfile_local" data-og-url="https://developer.nvidia.com/cuda-11-4-0-download-archive" data-og-image="https://scrap.kakaocdn.net/dn/lR7iE/hyWGOH4w9U/keJgjk2b4VVFYHfqCrDthk/img.jpg?width=610&amp;height=345&amp;face=0_0_610_345,https://scrap.kakaocdn.net/dn/RqVVF/hyWGR5Qe0X/b5oae0FWBHcUIwKdjLksT1/img.jpg?width=610&amp;height=345&amp;face=0_0_610_345"><a href="https://developer.nvidia.com/cuda-11-4-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=RHEL&amp;target_version=8&amp;target_type=runfile_local" target="_blank" rel="noopener" data-source-url="https://developer.nvidia.com/cuda-11-4-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=RHEL&amp;target_version=8&amp;target_type=runfile_local"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/lR7iE/hyWGOH4w9U/keJgjk2b4VVFYHfqCrDthk/img.jpg?width=610&amp;height=345&amp;face=0_0_610_345,https://scrap.kakaocdn.net/dn/RqVVF/hyWGR5Qe0X/b5oae0FWBHcUIwKdjLksT1/img.jpg?width=610&amp;height=345&amp;face=0_0_610_345');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">CUDA Toolkit 11.4 Downloads</p> <p class="og-desc" data-ke-size="size16">Get CUDA Toolkit 11.4 for Linux and Windows.</p> <p class="og-host" data-ke-size="size16">developer.nvidia.com</p> </div> </a></figure> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>아래 과정에서는 runfile로 설치하였다.</li> </ul> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="750"><span data-url="https://blog.kakaocdn.net/dn/cDizr5/btsIRwt3H9U/BB5kZpkroqyczVmv1WtmAk/img.png" data-phocus="https://blog.kakaocdn.net/dn/cDizr5/btsIRwt3H9U/BB5kZpkroqyczVmv1WtmAk/img.png"><img src="https://blog.kakaocdn.net/dn/cDizr5/btsIRwt3H9U/BB5kZpkroqyczVmv1WtmAk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcDizr5%2FbtsIRwt3H9U%2FBB5kZpkroqyczVmv1WtmAk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="750"/></span></figure> </p> <pre id="code_1722210563357" class="angelscript" style="background-color: #f8f8f8; color: #383a42; text-align: start;" data-ke-type="codeblock" data-ke-language="bash"><code>wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.run sh cuda_11.4.0_470.42.01_linux.run --toolkit --samples --silent --toolkitpath=/APP/enhpc/cuda-11.4.0</code></pre> <h4 data-ke-size="size20">설치 확인</h4> <p data-ke-size="size16">마지막 줄에 추가</p> <pre id="code_1729054660789" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vi ~/.bashrc export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code></pre> <pre id="code_1729054711021" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># source ~/.bashrc # nvcc -V nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2024 NVIDIA Corporation Built on Thu_Sep_12_02:18:05_PDT_2024 Cuda compilation tools, release 12.6, V12.6.77 Build cuda_12.6.r12.6/compiler.34841621_0</code></pre></description>
<category>NVIDIA</category>
<category>CUDA</category>
<category>driver</category>
<category>HPC</category>
<category>nvidia</category>
<category>그래픽 드라이버</category>
<category>쿠다 드라이버</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/186</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-CUDA-Driver-%EC%84%A4%EC%B9%98#entry186comment</comments>
<pubDate>Mon, 29 Jul 2024 12:00:48 +0900</pubDate>
</item>
<item>
<title>[Rocky linux 8] KVM 복사</title>
<link>https://estar987.com/entry/Rocky-linux-8-KVM-%EB%B3%B5%EC%82%AC</link>
<description><h2 data-ke-size="size26">KVM Copy</h2> <h3 data-ke-size="size23">복제를 위한 가상머신 준비</h3> <h4 data-ke-size="size20">1. 가상 머신 설정</h4> <p data-ke-size="size16">복제 또는 템플릿에 사용할 가상 머신을 빌드합니다. 복제본에 필요한 소프트웨어를 설치합니다. 운영 체제에 대해 고유하지 않은 설정을 구성합니다. 고유하지 않은 애플리케이션 설정을 구성합니다.</p> <h4 data-ke-size="size20">2. 네트워크 구성 제거</h4> <p data-ke-size="size16">udev 규칙이 제거되지 않으면 첫 번째 NIC 이름이 eth0 대신 eth1일 수 있습니다.</p> <pre id="code_1721279254403" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code> rm -f /etc/udev/rules.d/69-vdo-start-by-dev.rules</code></pre> <h4 data-ke-size="size20">3. 가상머신 목록 확인</h4> <p data-ke-size="size16">가상머신은 종료되어 있는 상태에서만 복사가 가능하다.</p> <pre id="code_1721279280987" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># virsh list --all Id Name State -------------------------------------- 15 windows10-test3 running - windows-virtio-test shut off - windows10-test1 shut off - windows11-test1 shut off</code></pre> <h4 data-ke-size="size20">4. 가상 머신 복제</h4> <pre id="code_1721279294645" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># virt-clone --original windows10-test1 --auto-clone Allocating 'windows10-test1-clone.qco 1% [ ] 63 MB/s | 4.1 GB 01:07:52 ETA # virt-clone --connect qemu:///system --original windows11-test1 --name newdemo --file /var/lib/libvirt/images/newdemo.img Allocating 'newdemo.img' 0% [ ] 98 MB/s | 1.6 GB 00:44:19 ETA</code></pre> <h4 data-ke-size="size20">5. 확인</h4> <pre id="code_1721279363382" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># ls /var/lib/libvirt/images/ newdemo.img windows10-test1-clone.qcow2 windows10-test3.qcow2 windows10.qcow2 windows10-test1.qcow2 windows-virtio-test.qcow2</code></pre> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="2087"><span data-url="https://blog.kakaocdn.net/dn/MSjYd/btsICRf2ccV/lGQkk0NgWKkKwrZlwh0QSk/img.png" data-phocus="https://blog.kakaocdn.net/dn/MSjYd/btsICRf2ccV/lGQkk0NgWKkKwrZlwh0QSk/img.png"><img src="https://blog.kakaocdn.net/dn/MSjYd/btsICRf2ccV/lGQkk0NgWKkKwrZlwh0QSk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMSjYd%2FbtsICRf2ccV%2FlGQkk0NgWKkKwrZlwh0QSk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="450" height="470" data-origin-width="2000" data-origin-height="2087"/></span></figure> </p></description>
<category>Virtual</category>
<category>KVM</category>
<category>VM</category>
<category>가상머신</category>
<category>복사</category>
<category>복제</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/185</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-KVM-%EB%B3%B5%EC%82%AC#entry185comment</comments>
<pubDate>Mon, 22 Jul 2024 12:00:36 +0900</pubDate>
</item>
<item>
<title>[Rocky linux 8] KVM에서 window10 가상 머신 명령어로 생성</title>
<link>https://estar987.com/entry/Rocky-linux-8-KVM%EC%97%90%EC%84%9C-window10-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-%EC%83%9D</link>
<description><pre id="code_1721115234308" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>dnf install -y virt-viewer</code></pre> <h2 data-ke-size="size26">명령어로 KVM 생성</h2> <h3 data-ke-size="size23">사전 작업</h3> <h4 data-ke-size="size20">virt-viewer 설치(선택 사항)</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>가상 머신에 연결하기 위해 virt-viewer를 설치할 수 있습니다.</li> </ul> <h3 data-ke-size="size23">Linux에서 명령어로 KVM window 가상 머신 생성</h3> <pre id="code_1721115355255" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>virt-install \ --name windows-virtio-test \ --os-variant win10 \ --memory 4096 \ --vcpus 4 \ --cdrom '/1.ISO/4.win/Win10_22H2_Korean_x64_x86_v2(19045.2965).iso' \ --disk path=/1.ISO/5.virtio/virtio-win-0.1.240.iso,device=cdrom \ --disk path=/var/lib/libvirt/images/windows-virtio-test.qcow2,format=qcow2,size=256,bus=virtio \ --network bridge=br0,model=virtio \ --graphics spice \ --soundhw ich9 \ --virt-type kvm \ --boot cdrom,hd,menu=on \ --check all=off</code></pre> <p data-ke-size="size16">&nbsp;</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="969" data-origin-height="177"><span data-url="https://blog.kakaocdn.net/dn/cKXEtM/btsIChqACIU/7fA9JIOwlvKTb6Z4EQ7Prk/img.png" data-phocus="https://blog.kakaocdn.net/dn/cKXEtM/btsIChqACIU/7fA9JIOwlvKTb6Z4EQ7Prk/img.png"><img src="https://blog.kakaocdn.net/dn/cKXEtM/btsIChqACIU/7fA9JIOwlvKTb6Z4EQ7Prk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcKXEtM%2FbtsIChqACIU%2F7fA9JIOwlvKTb6Z4EQ7Prk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="969" data-origin-height="177"/></span></figure> </p> <p data-ke-size="size16">&nbsp;</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="621" data-origin-height="460"><span data-url="https://blog.kakaocdn.net/dn/I1Fsb/btsIAyUY9yr/b4LcFHesttKtjHlOCR8Ho0/img.png" data-phocus="https://blog.kakaocdn.net/dn/I1Fsb/btsIAyUY9yr/b4LcFHesttKtjHlOCR8Ho0/img.png" data-alt="해당 화면이 나타나면 아래 포스팅한 글을 통해 윈도우를 설치한다."><img src="https://blog.kakaocdn.net/dn/I1Fsb/btsIAyUY9yr/b4LcFHesttKtjHlOCR8Ho0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI1Fsb%2FbtsIAyUY9yr%2Fb4LcFHesttKtjHlOCR8Ho0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="621" data-origin-height="460"/></span><figcaption>해당 화면이 나타나면 아래 포스팅한 글을 통해 윈도우를 설치한다.</figcaption> </figure> </p> <p data-ke-size="size16"><a href="https://estar987.tistory.com/179" target="_blank" rel="noopener&nbsp;noreferrer">https://estar987.tistory.com/179</a></p> <figure id="og_1721204437868" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="[Rocky linux 8] KVM에서 window10 가상 머신 설정(1)" data-og-description="KVM에서&nbsp;window10&nbsp;가상&nbsp;머신&nbsp;설정&nbsp;https://estar987.tistory.com/171&nbsp;[Rocky Linux 8] KVM 설치1. KVM 세팅 사전 작업1. 시스템 BIOS에서 가상화 관련 설정 enable 설정2. Linux OS 설치3. KVM 모듈 적재 및 가상화 지원 CPU" data-og-host="estar987.com" data-og-source-url="https://estar987.tistory.com/179" data-og-url="https://estar987.com/179" data-og-image="https://scrap.kakaocdn.net/dn/b7fizG/hyWCErnKIm/iwDTGlk0kCusX6JWZWys80/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/b5hMAf/hyWzslO3Xq/7KDQed4G6PjKr5tx7HKEq1/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/byY1Gt/hyWCPzGmVW/Uxg7hu0ujDBItHw5Kq6Ghk/img.png?width=770&amp;height=551&amp;face=0_0_770_551"><a href="https://estar987.tistory.com/179" target="_blank" rel="noopener" data-source-url="https://estar987.tistory.com/179"> <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/b7fizG/hyWCErnKIm/iwDTGlk0kCusX6JWZWys80/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/b5hMAf/hyWzslO3Xq/7KDQed4G6PjKr5tx7HKEq1/img.jpg?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/byY1Gt/hyWCPzGmVW/Uxg7hu0ujDBItHw5Kq6Ghk/img.png?width=770&amp;height=551&amp;face=0_0_770_551');">&nbsp;</div> <div class="og-text"> <p class="og-title" data-ke-size="size16">[Rocky linux 8] KVM에서 window10 가상 머신 설정(1)</p> <p class="og-desc" data-ke-size="size16">KVM에서&nbsp;window10&nbsp;가상&nbsp;머신&nbsp;설정&nbsp;https://estar987.tistory.com/171&nbsp;[Rocky Linux 8] KVM 설치1. KVM 세팅 사전 작업1. 시스템 BIOS에서 가상화 관련 설정 enable 설정2. Linux OS 설치3. KVM 모듈 적재 및 가상화 지원 CPU</p> <p class="og-host" data-ke-size="size16">estar987.com</p> </div> </a></figure> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">그런데 설치를 하던 중 아래와 같은 오류가 발생한다.(디스크가 보이지 않는 오류)</p> <p data-ke-size="size16">드라이브를 찾을 수 없습니다. 저장소 드라이버를 얻으려면 [드라이버 로드]를 클릭하세요</p> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1489"><span data-url="https://blog.kakaocdn.net/dn/bXwkWC/btsIDq9d2zC/68uhDMYoKQxgtwxvzfdXh1/img.png" data-phocus="https://blog.kakaocdn.net/dn/bXwkWC/btsIDq9d2zC/68uhDMYoKQxgtwxvzfdXh1/img.png"><img src="https://blog.kakaocdn.net/dn/bXwkWC/btsIDq9d2zC/68uhDMYoKQxgtwxvzfdXh1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbXwkWC%2FbtsIDq9d2zC%2F68uhDMYoKQxgtwxvzfdXh1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1489"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="1023" data-origin-height="770"><span data-url="https://blog.kakaocdn.net/dn/bP5rSv/btsIEcPVmx0/eyMZo1FTg2lQ2zF8CxVkkK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bP5rSv/btsIEcPVmx0/eyMZo1FTg2lQ2zF8CxVkkK/img.png"><img src="https://blog.kakaocdn.net/dn/bP5rSv/btsIEcPVmx0/eyMZo1FTg2lQ2zF8CxVkkK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbP5rSv%2FbtsIEcPVmx0%2FeyMZo1FTg2lQ2zF8CxVkkK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1023" data-origin-height="770"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="643" data-origin-height="478"><span data-url="https://blog.kakaocdn.net/dn/B2wxK/btsIBY7n5Du/w3BckKE0gmddTesPjDymu1/img.png" data-phocus="https://blog.kakaocdn.net/dn/B2wxK/btsIBY7n5Du/w3BckKE0gmddTesPjDymu1/img.png"><img src="https://blog.kakaocdn.net/dn/B2wxK/btsIBY7n5Du/w3BckKE0gmddTesPjDymu1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FB2wxK%2FbtsIBY7n5Du%2Fw3BckKE0gmddTesPjDymu1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="643" data-origin-height="478"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="636" data-origin-height="478"><span data-url="https://blog.kakaocdn.net/dn/X2D5t/btsICwhZ0Sq/LKuP8izk4mx5NBqWJJxF50/img.png" data-phocus="https://blog.kakaocdn.net/dn/X2D5t/btsICwhZ0Sq/LKuP8izk4mx5NBqWJJxF50/img.png"><img src="https://blog.kakaocdn.net/dn/X2D5t/btsICwhZ0Sq/LKuP8izk4mx5NBqWJJxF50/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FX2D5t%2FbtsICwhZ0Sq%2FLKuP8izk4mx5NBqWJJxF50%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="636" data-origin-height="478"/></span></figure> </p> <h3 data-ke-size="size23">네트워크 세팅</h3> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>네트워크 인터페이스 확인 불가</li> </ul> <p><figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1584"><span data-url="https://blog.kakaocdn.net/dn/bOCvXk/btsIEeGYqQU/kAWHzeOQ9uO7kDiU96jJfK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bOCvXk/btsIEeGYqQU/kAWHzeOQ9uO7kDiU96jJfK/img.png" data-alt="네트워크 연결 안됨 확인"><img src="https://blog.kakaocdn.net/dn/bOCvXk/btsIEeGYqQU/kAWHzeOQ9uO7kDiU96jJfK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbOCvXk%2FbtsIEeGYqQU%2FkAWHzeOQ9uO7kDiU96jJfK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1584"/></span><figcaption>네트워크 연결 안됨 확인</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1691"><span data-url="https://blog.kakaocdn.net/dn/oU0iy/btsIDUWhi3g/Q6MdGxtvlb7og09ee5gcbk/img.png" data-phocus="https://blog.kakaocdn.net/dn/oU0iy/btsIDUWhi3g/Q6MdGxtvlb7og09ee5gcbk/img.png" data-alt="virtio iso 연결"><img src="https://blog.kakaocdn.net/dn/oU0iy/btsIDUWhi3g/Q6MdGxtvlb7og09ee5gcbk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoU0iy%2FbtsIDUWhi3g%2FQ6MdGxtvlb7og09ee5gcbk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1691"/></span><figcaption>virtio iso 연결</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1685"><span data-url="https://blog.kakaocdn.net/dn/caAapQ/btsIEb4yBZk/rBOBI8LVVM1DlX2uG0RjpK/img.png" data-phocus="https://blog.kakaocdn.net/dn/caAapQ/btsIEb4yBZk/rBOBI8LVVM1DlX2uG0RjpK/img.png" data-alt="virtio iso 연결"><img src="https://blog.kakaocdn.net/dn/caAapQ/btsIEb4yBZk/rBOBI8LVVM1DlX2uG0RjpK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcaAapQ%2FbtsIEb4yBZk%2FrBOBI8LVVM1DlX2uG0RjpK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1685"/></span><figcaption>virtio iso 연결</figcaption> </figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1674"><span data-url="https://blog.kakaocdn.net/dn/bvKFhY/btsICjwuhb2/thbuvVEW94sXFbkpyLZ4YK/img.png" data-phocus="https://blog.kakaocdn.net/dn/bvKFhY/btsICjwuhb2/thbuvVEW94sXFbkpyLZ4YK/img.png"><img src="https://blog.kakaocdn.net/dn/bvKFhY/btsICjwuhb2/thbuvVEW94sXFbkpyLZ4YK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvKFhY%2FbtsICjwuhb2%2FthbuvVEW94sXFbkpyLZ4YK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1674"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1501"><span data-url="https://blog.kakaocdn.net/dn/c6vQSV/btsIB6c8tyt/wfAte7UjNlz1tDncj9oAYk/img.png" data-phocus="https://blog.kakaocdn.net/dn/c6vQSV/btsIB6c8tyt/wfAte7UjNlz1tDncj9oAYk/img.png"><img src="https://blog.kakaocdn.net/dn/c6vQSV/btsIB6c8tyt/wfAte7UjNlz1tDncj9oAYk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc6vQSV%2FbtsIB6c8tyt%2FwfAte7UjNlz1tDncj9oAYk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1501"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1508"><span data-url="https://blog.kakaocdn.net/dn/cGVGg0/btsIDVgAynU/QJiSCMhTemx4YN9glGXNd0/img.png" data-phocus="https://blog.kakaocdn.net/dn/cGVGg0/btsIDVgAynU/QJiSCMhTemx4YN9glGXNd0/img.png"><img src="https://blog.kakaocdn.net/dn/cGVGg0/btsIDVgAynU/QJiSCMhTemx4YN9glGXNd0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcGVGg0%2FbtsIDVgAynU%2FQJiSCMhTemx4YN9glGXNd0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1508"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1500"><span data-url="https://blog.kakaocdn.net/dn/W4aiO/btsIEdVBSbA/Pxh0ykDWnn7QNZLxBKUvkK/img.png" data-phocus="https://blog.kakaocdn.net/dn/W4aiO/btsIEdVBSbA/Pxh0ykDWnn7QNZLxBKUvkK/img.png"><img src="https://blog.kakaocdn.net/dn/W4aiO/btsIEdVBSbA/Pxh0ykDWnn7QNZLxBKUvkK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FW4aiO%2FbtsIEdVBSbA%2FPxh0ykDWnn7QNZLxBKUvkK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1500"/></span></figure> <figure class="imageblock alignCenter" data-ke-mobileStyle="widthOrigin" data-origin-width="2000" data-origin-height="1495"><span data-url="https://blog.kakaocdn.net/dn/bVIQlt/btsIB7Xnu5J/skDGKXb1rK7sr2OSJdDGe1/img.png" data-phocus="https://blog.kakaocdn.net/dn/bVIQlt/btsIB7Xnu5J/skDGKXb1rK7sr2OSJdDGe1/img.png" data-alt="연결 확인"><img src="https://blog.kakaocdn.net/dn/bVIQlt/btsIB7Xnu5J/skDGKXb1rK7sr2OSJdDGe1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbVIQlt%2FbtsIB7Xnu5J%2FskDGKXb1rK7sr2OSJdDGe1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="2000" data-origin-height="1495"/></span><figcaption>연결 확인</figcaption> </figure> </p></description>
<category>Virtual</category>
<category>KVM</category>
<category>Virtual</category>
<category>Windows</category>
<category>가상머신</category>
<category>네트워크</category>
<category>드라이브를 찾을 수 없습니다. 저장소 드라이버를 얻으려면 [드라이버 로드]를 클릭하세요</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/184</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-KVM%EC%97%90%EC%84%9C-window10-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-%EC%83%9D#entry184comment</comments>
<pubDate>Thu, 18 Jul 2024 12:00:17 +0900</pubDate>
</item>
<item>
<title>[Rocky linux 8] PXE할 서버 지정하기</title>
<link>https://estar987.com/entry/Rocky-linux-8-PXE%ED%95%A0-%EC%84%9C%EB%B2%84-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0</link>
<description><p data-ke-size="size16">같은 망에서 여러 pc를 갖고 pxe를 하다보면 dhcp가 중복되어서 내가 원하는 설정이 안 불러져 오는 경우가 빈번하게 있다. 회사에서도 dhcp 로그 분석 후 그 대역대를 쓰는 사람에게 가서 꺼달라고 항상 할 순 없는 노릇이다. 그래서 Network를 활용하여서 내가 원하는 서버에만 pxe로 OS를 설치하는 법을 포스팅하려고 한다.&nbsp;</p> <p data-ke-size="size16">&nbsp;</p> <p data-ke-size="size16">설정은 생각보다 간단하다. dhcpd.conf 파일만 조금 변경해주면 된다.</p> <p data-ke-size="size16">아래는 내 설정파일 내용이다.&nbsp;</p> <pre id="code_1720185550272" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>deny unknown-clients; 라인 추가</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>알 수 없는 클라이언트는 IP를 할당받지 않음</li> </ul> <pre id="code_1720185560513" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>host system1 { hardware ethernet 00:50:56:b6:df:a7; fixed-address 192.168.207.100; }</code></pre> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>특정 시스템에 대한 MAC 주소 기반 설정</li> <li>필요한 만큼 시스템을 추가( system1, system 2... 임의로 설정)</li> <li>hardware ethernet 과 fixed-address 192.168.207.100 설정으로 이더넷을 특정하고, 고정 아이피를 할당한다.</li> </ul> <pre id="code_1720185468960" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code># vim /etc/dhcp/dhcpd.conf ================================================== option space pxelinux; option pxelinux.magic code 208 = string; option pxelinux.configfile code 209 = text; option pxelinux.pathprefix code 210 = text; option pxelinux.reboottime code 211 = unsigned integer 32; option architecture-type code 93 = unsigned integer 16; subnet 192.168.207.0 netmask 255.255.255.0 { option routers 192.168.207.254; range dynamic-bootp 192.168.207.10 192.168.207.230; # 알 수 없는 클라이언트는 IP를 할당받지 않음 deny unknown-clients; class "pxeclients" { match if substring (option vendor-class-identifier, 0, 9) = "PXEClient"; next-server 192.168.207.10; if option architecture-type = 00:07 { filename "grubx64.efi"; } else { filename "pxelinux.0"; } } # 특정 시스템에 대한 MAC 주소 기반 설정 host system1 { hardware ethernet 00:50:56:b6:df:a7; fixed-address 192.168.207.100; } # 필요한 만큼 시스템을 추가 }</code></pre></description>
<category>OS</category>
<category>dhcp</category>
<category>kickstart</category>
<category>pxe</category>
<category>고정 IP</category>
<category>네트워크</category>
<category>이더넷</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/183</guid>
<comments>https://estar987.com/entry/Rocky-linux-8-PXE%ED%95%A0-%EC%84%9C%EB%B2%84-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0#entry183comment</comments>
<pubDate>Mon, 8 Jul 2024 12:00:03 +0900</pubDate>
</item>
<item>
<title>RAID 수준 이해하기: RAID 0, 1, 5, 6, 10, 01</title>
<link>https://estar987.com/entry/RAID-%EC%88%98%EC%A4%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-RAID-0-1-5-6-10-01</link>
<description><p data-ke-size="size16">RAID (Redundant Array of Independent Disks)은 데이터를 효율적으로 저장하고 보호하기 위한 기술입니다. 다양한 RAID 수준이 있으며, 각 수준마다 성능, 데이터 보호 및 저장 효율성이 다릅니다. 이번 글에서는 RAID 0, 1, 5, 6, 1+0, 0+1의 정의, 특성, 장단점, 사용 사례 등을 다루어보겠습니다.</p> <p data-ke-size="size16">&nbsp;</p> <h3 data-ke-size="size23">RAID 0: Striping</h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/k1849/btsImCWEJNV/OBJnKi7TBSWOopr3brxxhK/img.png" data-phocus="https://blog.kakaocdn.net/dn/k1849/btsImCWEJNV/OBJnKi7TBSWOopr3brxxhK/img.png" data-alt="여러 개의 하드 드라이브가 있으며, 데이터 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. &quot;Data Blocks&quot;와 &quot;No Redundancy&quot; 라벨이 포함되어 있으며, 데이터가 어떻게 분할되어 드라이브에 기록되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/k1849/btsImCWEJNV/OBJnKi7TBSWOopr3brxxhK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fk1849%2FbtsImCWEJNV%2FOBJnKi7TBSWOopr3brxxhK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="398" height="398" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>여러 개의 하드 드라이브가 있으며, 데이터 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. "Data Blocks"와 "No Redundancy" 라벨이 포함되어 있으며, 데이터가 어떻게 분할되어 드라이브에 기록되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>데이터를 블록으로 나누어 각 블록을 별도의 디스크에 저장하는 방식입니다. 이를 스트라이핑이라고 합니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>중복성 없음</b>: 하나의 디스크가 고장 나면 모든 데이터를 잃습니다.</li> <li><b>높은 성능</b>: 여러 디스크를 동시에 액세스하기 때문에 읽기 및 쓰기 속도가 향상됩니다.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>모든 디스크를 사용하여 저장 용량을 극대화합니다.</li> <li>읽기 및 쓰기 성능이 향상됩니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>데이터 보호나 장애 허용 기능이 없습니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>성능이 중요한 애플리케이션(예: 게임, 렌더링)에서 데이터 손실이 허용 가능한 경우 적합합니다.</li> </ul> <h3 data-ke-size="size23">RAID 1: <span data-token-index="0">Mirroring</span></h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/b2Day9/btsInw9eoCj/JhqKk5aJ9oTT6BRGf5yYh0/img.png" data-phocus="https://blog.kakaocdn.net/dn/b2Day9/btsInw9eoCj/JhqKk5aJ9oTT6BRGf5yYh0/img.png" data-alt="두 개의 하드 드라이브가 있으며, 동일한 데이터가 두 드라이브에 모두 기록되는 모습을 보여줍니다. &quot;Data Blocks&quot;, &quot;Mirroring&quot;, &quot;Fault Tolerance&quot; 라벨이 포함되어 있으며, 데이터가 어떻게 중복되어 드라이브에 기록되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/b2Day9/btsInw9eoCj/JhqKk5aJ9oTT6BRGf5yYh0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb2Day9%2FbtsInw9eoCj%2FJhqKk5aJ9oTT6BRGf5yYh0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="394" height="394" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>두 개의 하드 드라이브가 있으며, 동일한 데이터가 두 드라이브에 모두 기록되는 모습을 보여줍니다. "Data Blocks", "Mirroring", "Fault Tolerance" 라벨이 포함되어 있으며, 데이터가 어떻게 중복되어 드라이브에 기록되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>데이터를 두 개 이상의 디스크에 동일하게 복사하는 방식입니다. 이를 미러링이라고 합니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>데이터 중복성</b>: 각 디스크가 다른 디스크의 미러링이므로 하나의 디스크가 고장 나더라도 데이터가 안전합니다.</li> <li><b>읽기 속도 향상</b>: 데이터를 여러 디스크에서 읽을 수 있습니다.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>높은 신뢰성과 장애 허용 기능을 제공합니다.</li> <li>읽기 성능이 향상됩니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>저장 효율이 50%로 떨어집니다(데이터가 중복되므로).</li> <li>두 배의 디스크가 필요하므로 비용이 높습니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>금융 기록, 시스템 로그 등 데이터 가용성이 중요한 경우 적합합니다.</li> </ul> <h3 data-ke-size="size23">RAID 5: <span data-token-index="0">Striping with Parity</span></h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/uI3jE/btsInvoWDiS/9u6fIqC2d3ckzbqiKtkcx0/img.png" data-phocus="https://blog.kakaocdn.net/dn/uI3jE/btsInvoWDiS/9u6fIqC2d3ckzbqiKtkcx0/img.png" data-alt="최소 세 개의 하드 드라이브가 있으며, 데이터 블록과 패리티 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. &quot;Data Blocks&quot;, &quot;Parity Blocks&quot;, &quot;Fault Tolerance&quot; 라벨이 포함되어 있으며, 데이터와 패리티가 디스크에 어떻게 기록되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/uI3jE/btsInvoWDiS/9u6fIqC2d3ckzbqiKtkcx0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuI3jE%2FbtsInvoWDiS%2F9u6fIqC2d3ckzbqiKtkcx0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="440" height="440" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>최소 세 개의 하드 드라이브가 있으며, 데이터 블록과 패리티 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. "Data Blocks", "Parity Blocks", "Fault Tolerance" 라벨이 포함되어 있으며, 데이터와 패리티가 디스크에 어떻게 기록되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>데이터와 패리티(오류 검사 정보)를 세 개 이상의 디스크에 스트라이핑합니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>균형 잡힌 성능과 중복성</b>: 스트라이핑과 패리티의 장점을 결합하여 성능을 저해하지 않고 장애 허용 기능을 제공합니다.</li> <li><b>최소 세 개의 디스크가 필요합니다</b>.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>하나의 디스크가 고장 나더라도 데이터가 손실되지 않습니다.</li> <li>저장 효율이 좋습니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>패리티 계산 때문에 쓰기 성능이 느립니다.</li> <li>고장 후 복구 시간이 길 수 있습니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>파일 서버 및 애플리케이션 서버 등 성능, 데이터 보안, 저장 효율의 균형이 필요한 경우 적합합니다.</li> </ul> <h3 data-ke-size="size23">RAID 6: 더블 패리티 스트라이핑</h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/bmD0tw/btsInC9jQE8/yEsH3KfBbbjXGSeLBLgZr0/img.png" data-phocus="https://blog.kakaocdn.net/dn/bmD0tw/btsInC9jQE8/yEsH3KfBbbjXGSeLBLgZr0/img.png" data-alt="최소 네 개의 하드 드라이브가 있으며, 데이터 블록과 두 개의 패리티 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. &quot;Data Blocks&quot;, &quot;Double Parity Blocks&quot;, &quot;Fault Tolerance&quot; 라벨이 포함되어 있으며, 데이터와 패리티가 디스크에 어떻게 기록되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/bmD0tw/btsInC9jQE8/yEsH3KfBbbjXGSeLBLgZr0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbmD0tw%2FbtsInC9jQE8%2FyEsH3KfBbbjXGSeLBLgZr0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="453" height="453" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>최소 네 개의 하드 드라이브가 있으며, 데이터 블록과 두 개의 패리티 블록이 각 드라이브에 분산되어 저장되는 모습을 보여줍니다. "Data Blocks", "Double Parity Blocks", "Fault Tolerance" 라벨이 포함되어 있으며, 데이터와 패리티가 디스크에 어떻게 기록되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>RAID 5와 유사하지만 추가 패리티 블록을 사용하여 두 개의 디스크가 고장 나더라도 데이터를 보호합니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>높은 장애 허용성</b>: 두 개의 디스크가 동시에 고장 나도 데이터를 복구할 수 있습니다.</li> <li><b>최소 네 개의 디스크가 필요합니다</b>.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>RAID 5보다 더 높은 데이터 보호 수준을 제공합니다.</li> <li>데이터 가용성이 매우 높습니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>두 개의 패리티 블록 계산으로 인해 쓰기 성능이 더욱 느립니다.</li> <li>비용이 더 많이 듭니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>대규모 데이터베이스와 기업 환경 등 데이터 가용성이 중요한 경우 적합합니다.</li> </ul> <h3 data-ke-size="size23">RAID 10: RAID 1과 RAID 0의 결합</h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/b5A9VB/btsIm5c6fSn/03PwT15QWcJv1l14XfGnkk/img.png" data-phocus="https://blog.kakaocdn.net/dn/b5A9VB/btsIm5c6fSn/03PwT15QWcJv1l14XfGnkk/img.png" data-alt="최소 네 개의 하드 드라이브가 있으며, 데이터가 두 세트로 나뉘어 미러링되고, 그런 다음 미러링된 데이터가 다시 스트라이핑되어 저장되는 모습을 보여줍니다. &quot;Data Blocks&quot;, &quot;Mirrored Data&quot;, &quot;Striped Data&quot;, &quot;Fault Tolerance&quot; 라벨이 포함되어 있으며, 데이터가 어떻게 미러링되고 스트라이핑되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/b5A9VB/btsIm5c6fSn/03PwT15QWcJv1l14XfGnkk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5A9VB%2FbtsIm5c6fSn%2F03PwT15QWcJv1l14XfGnkk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="345" height="345" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>최소 네 개의 하드 드라이브가 있으며, 데이터가 두 세트로 나뉘어 미러링되고, 그런 다음 미러링된 데이터가 다시 스트라이핑되어 저장되는 모습을 보여줍니다. "Data Blocks", "Mirrored Data", "Striped Data", "Fault Tolerance" 라벨이 포함되어 있으며, 데이터가 어떻게 미러링되고 스트라이핑되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>미러링과 스트라이핑을 결합한 방식입니다. 데이터는 미러링된 후 여러 디스크에 스트라이핑됩니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>높은 성능과 중복성</b>: RAID 0의 속도와 RAID 1의 중복성을 제공합니다.</li> <li><b>최소 네 개의 디스크가 필요합니다</b>.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>읽기 및 쓰기 성능이 우수합니다.</li> <li>여러 디스크 고장을 견딜 수 있습니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>디스크가 많이 필요하여 비용이 높습니다.</li> <li>저장 효율이 50%로 떨어집니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>데이터베이스, 이메일, 웹 서버 등 고성능과 높은 장애 허용성이 필요한 애플리케이션에 적합합니다.</li> </ul> <h3 data-ke-size="size23">RAID 01: RAID 0과 RAID 1의 결합</h3> <p><figure class="imageblock alignLeft" data-ke-mobileStyle="widthOrigin" data-origin-width="1024" data-origin-height="1024"><span data-url="https://blog.kakaocdn.net/dn/be2nZT/btsImGdxv7V/A5bdsWYizn5GwLka2Td8L1/img.png" data-phocus="https://blog.kakaocdn.net/dn/be2nZT/btsImGdxv7V/A5bdsWYizn5GwLka2Td8L1/img.png" data-alt="최소 네 개의 하드 드라이브가 있으며, 데이터가 먼저 스트라이핑된 후, 각 스트라이핑된 세트가 다른 세트에 미러링되어 저장되는 모습을 보여줍니다. &quot;Data Blocks&quot;, &quot;Striped Data&quot;, &quot;Mirrored Data&quot;, &quot;Fault Tolerance&quot; 라벨이 포함되어 있으며, 데이터가 어떻게 스트라이핑되고 미러링되는지를 화살표로 표시하고 있습니다."><img src="https://blog.kakaocdn.net/dn/be2nZT/btsImGdxv7V/A5bdsWYizn5GwLka2Td8L1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbe2nZT%2FbtsImGdxv7V%2FA5bdsWYizn5GwLka2Td8L1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="401" height="401" data-origin-width="1024" data-origin-height="1024"/></span><figcaption>최소 네 개의 하드 드라이브가 있으며, 데이터가 먼저 스트라이핑된 후, 각 스트라이핑된 세트가 다른 세트에 미러링되어 저장되는 모습을 보여줍니다. "Data Blocks", "Striped Data", "Mirrored Data", "Fault Tolerance" 라벨이 포함되어 있으며, 데이터가 어떻게 스트라이핑되고 미러링되는지를 화살표로 표시하고 있습니다.</figcaption> </figure> </p> <h4 data-ke-size="size20">정의</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>스트라이핑된 미러링된 디스크 세트를 사용하는 방식입니다.</li> </ul> <h4 data-ke-size="size20">특성</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li><b>성능과 중복성</b>: 스트라이핑과 미러링의 장점을 결합합니다.</li> </ul> <h4 data-ke-size="size20">장점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>좋은 성능과 중복성을 제공합니다.</li> </ul> <h4 data-ke-size="size20">단점</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>구현 및 관리가 더 복잡합니다.</li> <li>RAID 10보다 덜 견고합니다.</li> </ul> <h4 data-ke-size="size20">사용 사례</h4> <ul style="list-style-type: disc;" data-ke-list-type="disc"> <li>RAID 10과 비슷하지만 덜 사용됩니다.</li> </ul> <p data-ke-size="size16">&nbsp;</p></description>
<category>OS</category>
<category>OS</category>
<category>Raid 0</category>
<category>Raid 01</category>
<category>raid 1</category>
<category>Raid 10</category>
<category>RAID 5</category>
<category>RAID 6</category>
<category>디스크</category>
<category>레이드</category>
<author>Yoon_estar</author>
<guid isPermaLink="true">https://estar987.com/182</guid>
<comments>https://estar987.com/entry/RAID-%EC%88%98%EC%A4%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-RAID-0-1-5-6-10-01#entry182comment</comments>
<pubDate>Thu, 4 Jul 2024 12:00:16 +0900</pubDate>
</item>
</channel>
</rss>
